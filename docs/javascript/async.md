# 异步

## 异步：现在与将来

### 分块的程序

+ 分块

  JavaScript程序是由多个块构成的，这些块中只有一个是现在执行的块，其余的则在将来执行的块。最常见的块单位是**函数**。

  任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax 响应等）时执行，就是在代码中创建了一个将来执行的块。

  现在无法完成的任务将会异步完成 —— 回调函数

+ 异步控制台：
  + 问题：在某些条件下，某些浏览器的console.log(..) 并不会把传入的内容立即输出。
  + 原因：在许多程序（不只是JavaScript）中，I/O 是非常低速的阻塞部分。所以，（从页面/UI 的角度来说）浏览器在后台异步处理控制台I/O 能够提高性能，这时用户甚至可能根本意识不到其发生。
  + 方法：最好使用 JavaScript调试器中的断点，不要依赖控制台输出。次优的方案是把对象序列化到一个字符串中，以强制执行一次“快找”。

### 事件循环

JavaScript引擎的宿主环境提供了一种机制用来处理程序中多个块的执行，且执行每块时调用JavaScript引擎，这种机制被称为`事件循环`。

JavaScript引擎本身没有时间的概念，只是一个按需执行JavaScript任意代码片段的环境。“事件”（JavaScript代码执行）调度总是由包含它的环境执行。

一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个
tick。用户交互、IO 和定时器会向事件队列中加入事件。

任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一
个或多个后续事件。

`setTimeout(...)` 设置一个定时器，当定时器到时后，环境会把回调函数放在事件循环中。在未来某个时候的 tick（在事件循环中，每进行一次循环操作称为tick） 会摘下并执行这个回调。

严格说来，`setTimeout(..., 0)` 并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。

### 并行线程

并行计算最常见的工具就是`进程`和`线程`。进程和线程独立运行，并可以同时运行。在不同的处理器，甚至不同的计算机上，多个线程能过共享单个进程的内存。

进程与线程的关系：[进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可共存。

完整运行：由于JavaScript的单线程特性，函数中的代码具有原子性，也就是说一旦开始运行，函数中的代码会在其他函数运行之前完成。

在JavaScript的特性中，函数顺序的不确定性成为竞态条件。例如，两个函数互相竞争，看谁先运行。

### 并发

并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时
在运行（尽管在任意时刻只处理一个事件）。

并发：需要（至少）两个独立的“进程”同时运行。（在同一段时间，并不需要再同一时刻）

通常需要对这些并发执行的“进程”（有别于操作系统中的进程概念）进行某种形式的交
互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身
分割为更小的块，以便其他“进程”插入进来。

注意：“进程”并不是计算机科学意义上的真正操作系统进程。这是虚拟进程，或者任务，表示一个逻辑上相关的运算序列。

JavaScript 一次只能处理一个事件。多个“进程”并发运行（任务级并行），但它们的各个事件是在事件循环队列中一次运行的。

+ 非交互
  
  两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/ 事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接受的。

+ 交互
  
  并发的“进程”需要相互交流，通过作用域或DOM间接交互。如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。

+ 协作

  取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。

### 任务

任务队列：挂在事件循环队列的每个tick 之后的一个队列。在事件循环的每个tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick 的任务队列末尾添加一个项目（一个任务）。

一个任务可能引起更多任务被添加到同一个队列末尾。

### 语句顺序

代码中语句的顺序和JavaScript 引擎执行语句的顺序并不一定要一致。

编译器语句重排序几乎就是并发和交互的微型隐喻。

## 回调

### continuation

回调函数包裹或者说封装了程序的延续（continuation）。

一旦以回调函数的形式引入了单个continuation（或者几十个），就容许了大脑工作方式和代码执行方式的分歧。一旦这两者出现分歧，代码变得更加难以理解、追踪、调试和维护。

## Promise

`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

``` javascript
const promise = new Promise(function(resolve, reject) {
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```

`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

+ `resolve`函数：将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。
+ `reject`函数：将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。`then`方法可以接受两个回调函数作为参数。

+ 第一个回调函数是：`Promise`对象的状态变为`resolved`时调用。
+ 第二个回调函数是：`Promise`对象的状态变为`rejected`时调用。可选的。

特点：

+ 对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
+ 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled` 和 从`pending`变为`rejected`。

缺点：

+ 无法取消`Promise`,**一旦新建它就会立即执行**，无法中途取消
  
  ``` javascript
  let promise = new Promise(function(resolve, reject) {
    console.log('Promise');
    resolve();
  });
  promise.then(function() {
    console.log('resolved');
  });
  console.log('Hi!');
  // 输出：Promise  Hi!  resolved
  ```

+ 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部
+ 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

注意：调用`resolve`或`reject`并不会终结 `Promise` 的参数函数的执行。

``` javascript
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2 1
// 调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。
// 因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
```
