# 手写代码系列

## 手写call、apply及bind函数

+ 手写 `call`（接受的是一个参数列表）

  ``` javascript
  Function.prototype.myCall = function(context) {
    if (typeof this !== 'function') {
      throw new TypeError('Error);
    }
    context = context || window;
    context.fn = this;
    const args = [...argumets].slice(1);
    const result = context.fn(...args);
    delete context.fn;
    return result;
  }
  ```

  + `context`为可选参数，如果不传的话默认上下文为 `window`
  + 给 `context` 创建一个 `fn` 属性，并将值设置为需要调用的函数
  + `call` 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来
  + 然后调用函数并将对像上的函数删除

+ 手写 `apply`（接受的是一个包含多个参数的数组）

  ``` javascript
  Function.prototype.myApply = function(context) {
    if (typeof this !== 'function') {
      throw new TypeError('Error');
    }
    context = context || window;
    context.fn = this;
    let result;
    // 处理参数和 call 有区别
    if (arguments[1]) {
      result = context.fn(...arguments[1]);
    } else {
      result = context.fn();
    }
    delete context.fn;
    return result;
  }
  ```

+ 手写 `bind`（返回对应函数）
  
  ``` javascript
  Function.prototype.myBind = function (context) {
    if (typeof this !== 'function') {
      throw new TypeError('Error')
    }
    const _this = this
    const args = [...arguments].slice(1)
    // 返回一个函数
    return function F() {
      // 因为返回了一个函数，我们可以 new F()，所以需要判断
      if (this instanceof F) {
        return new _this(...args, ...arguments)
      }
      return _this.apply(context, args.concat(...arguments))
    }
  }
  ```

  `bind` 返回了一个函数，对于函数来说有两种方式调用：
  + 直接调用

    使用 `apply` 的方式实现，但对于参数需要注意一下情况：因为 `bind` 可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以需要将两边的参数拼接起来，于是就有了这样的实现 `args.concat(...arguments)`
  + 通过 `new` 的方式

    对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况需要忽略传入的 `this`
