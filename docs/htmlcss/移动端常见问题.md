# H5常见问题

## 1. 解决移动端浏览器 300 毫秒点击延迟问题 - FastClick

### 1.1 原因

由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，看用户有没有下一次点击，也就是这次操作是不是双击。

### 1.2 FastClick 实现原理

检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。

### 1.3 使用

  ``` javascript
  // 引入
  import FastClick from 'fastclick'
  // 初始化FastClick实例。在页面的DOM文档加载完成后
  FastClick.attach(document.body)
  ```

### 1.4 如何解决ios input框唤启软键盘不灵敏问题
  
  ``` javascript
  // 在引用fastclick的地方，重写focus方法. 如果是vue项目，可以在main.js文件里面，引入fastclick模块后，重写focus方法。
  FastClick.prototype.focus = function(targetElement) {
    var length;
    // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
    if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email') {
        length = targetElement.value.length;
        targetElement.focus();// 加入这一句话
        targetElement.setSelectionRange(length, length);
    } else {
        targetElement.focus();
    }
  };
  ```

### 1.5 FastClick导致下拉框焦点冲突

+ 问题：移动端使用 Fastclick 之后，在ios环境下，有几个连续的下拉框，第一个select框突然填充了第二个下拉框的内容
+ 原因：Fastclick 导致 ios 下多个select ，点击某一个，焦点不停变换的bug。
+ 解决办法：
  + 修改源码，在 `onTouchStart事件` 内判断设备是否为IOS
  + 再判断当前 `nodeName` 是否为select，如果是 return false 去阻止 Fastclick 执行其他事件

  ``` javascript
    FastClick.prototype.onTouchStart = function(event) {
      // 添加判断符 合ios 或者 select 的时候 不返回事件
      if(deviceIsIOS && this.targetElement === 'select')
        this.targetElement = null
        event.preventDefault();
      }

    FastClick.prototype.onTouchEnd = function(event) {
      // 判断非ios或者非select的事件
      if (!deviceIsIOS || targetTagName !== 'select') {
        this.targetElement = null;
        event.preventDefault();
      }
    }
  ```

> 作者：RobinsonZhang  
> 链接：<https://juejin.im/post/5b163eb5e51d4506c4751e44>  
> 来源：掘金  
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 1.6 点击穿透问题

+ 场景：
  + 假如页面上有两个元素A和B。B元素在A元素之上。在B元素的`touchstart事件`上注册了一个回调函数，该回调函数的作用是隐藏B元素。
  + 当点击B元素，B元素被隐藏了，随后，A元素触发了`click事件`。这是因为在移动端浏览器，`事件执行的顺序是touchstart > touchend > click`。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。
+ 解决方法：
  + 只使用 `touch`：把页面内所有click全部换成touch事件（`touchstart`、`touchend`、`tap`）。`需特别注意`：a标签的href是click，需要去掉换成js控制的跳转，或者直接改成`span + tap`控制跳转
  + 只用 `click`：会带来 300ms 延迟
  + `tap`后延迟 350ms 再隐藏mask：隐藏mask变慢
  + `pointer-events`：mask隐藏后，给按钮下面元素添上`pointer-events: none;`样式，让click穿过去，350ms后去掉这个样式，恢复响应。缺陷是mask消失后的的350ms内，用户可以看到按钮下面的元素点着没反应。
  + 在下面元素的事件处理器里做检测（配合全局flag）：全局 flag 记录按钮点击的位置（坐标点），在下面元素的事件处理器里判断event的坐标点，如果相同则拒绝响应。
  + Fastclick

> 作者：李赫feixuan  
> 链接：<https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0>  
> 来源：掘金  
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 2. ios 微信公众号中弹出键盘再收起时，原虚拟键盘位点击事件无效

+ 原因：
  + H5端无法监控键盘的弹起与收起，resize 事件（文档视图调整大小时会触发 resize 事件）触发的机型极其有限。Android 弹起键盘时会修改视窗的大小，ios并不会。如果在ios上设置一个100%高度的body，弹起键盘后这个body是可以上下滚动。
  + 在H5中，键盘被收起的时候，body视图还在键盘弹起时的状态。导致原来处于虚拟键盘位置的点击事件失效
+ 解决方法：

  在input输入框失去焦点的钩子中设置滚动到原有位置`(document.body.scrollTop = document.body.scrollTop)`，触发浏览器的重绘，使的错误的渲染回复正常，滚动位置也不会有改变，没有影响体验。

  ``` javascript
  onBlur = (e) => {
    const { onBlur } = this.props;
    document.body && (document.body.scrollTop = document.body.scrollTop);
    onBlur && onBlur(e);
  }
  ```

  ``` javascript
  // 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug
  ;(/iphone|ipod|ipad/i.test(navigator.appVersion)) && document.addEventListener('blur', (e) => {
      // 这里加了个类型判断，因为a等元素也会触发blur事件
      ['input', 'textarea'].includes(e.target.localName) && document.body.scrollIntoView(false)
  }, true)
  ```

> 作者：ZoenLeo  
> 链接：<https://juejin.im/post/5c07442f51882528c4469769>  
> 来源：掘金  
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 3. 滚动穿透

### 3.1 场景

有一层遮罩蒙层覆盖在body上时，当滚动遮罩层，它下面的内容也会跟着一起滚动，看起来好像是上面的滚动事件穿透到下面的DOM元素上一样，这种现象称为滚动穿透。

### 3.2 阻止冒泡 [ 并没有什么用 ]

+ 首先，一般而言滚动不是监听事件去改变元素的位置而实现的，当设置 `overflow:scroll/auto` 时，实际上是 `浏览器原生实现的滚动效果`。
+ 其次， `scroll`事件对于普通Element元素是不冒泡的，但是 document 的 defaultView 的 scroll 事件冒泡

所有的滚动都是在 Document上形成了一个 pending队列，然后按照一定的规则触发，详见W3C规范:

``` txt
When asked to run the scroll steps for a Document doc, run these steps:
For each item target in doc’s pending scroll event targets, in the order they were added to the list, run these substeps:
If target is a Document, fire an event named scroll that bubbles at target.
Otherwise, fire an event named scroll at target.
Empty doc’s pending scroll event targets.
```

当滚动鼠标滚轮，或者滑动手机屏幕时，触发对象可分为两种类型（详见W3C规范）：

+ viewport（用户网页的可视区域）被触发滚动， eventtarget 为关联的 Document
+ element元素 被触发滚动，通常也就是添加 overflow 滚动属性的 element元素， eventtarget 为相应的 node element

当我们触发滚轮或滑动时，如果当前元素没有设置 overflow 这样的属性，同时也没有 preventDefault（通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）） 掉原生的滚动/滑动事件，那么此时触发的是 viewport的滚动， position:fixed的元素并没有什么例外。

滚动穿透问题其实并不是一个浏览器的bug（虽然在ios下fixed定位确实会导致很多bug），它是完全符合规范的，滚动的原则应该是 `scrollforwhat can scroll`，不应该因为某个元素的 CSS定位导致滚轮失效或者滑动失效

### 3.3 加 `overflow:hidden`

滚动穿透触发了整个viewport的滚动，那么给 body上加个 `overflow:hidden`，让整个body变成不可滚动的元素：

``` css
html, body {
  overflow: hidden;
}
```

**只加 overflow:hidden对移动端是无效的！** 当body的高度被内容撑开而滚动时，如果不对body的高度加以限制，只加入 `overflow:hidden`，此时在移动端依然可以滚动。加入 `overflow:hidden` 的同时选择性做：

+ 将 `html, body` 的高度设置为 100%
+ 将 `html, body` 设置为绝对定位

带来的问题：**会让浏览器的滚动条默认重置于初始位置**

解决方法：在添加 `overflow` 之前，先记录当前浏览器的 `scrollTop` 值，然后在添加之后重置 `scrollTop`

### 3.4 阻止body的默认滚动

直接阻止 document的 touchmove事件：

``` javascript
document.ontouchmove = (e) =>{
  e.preventDefault();
};
```

**该方案好像在Android中不生效？**

原因：`passive event` 。

+ chrome 51引入了 `passive event listeners` 以提高滚动性能。
+ 当监听 `touchmove` 事件时，在之前是有一个小延迟触发的，因为浏览器不知道我们是否要 `preventDefault` ，所以等到大概200ms左右才能真正收到监听回调。
+ chrome在56版本将 `addEventListner` 默认的 `passive` 置为 true，这样浏览器就能知道这个 addEventListner 是不用 preventDefault的，立即可触发滚动事件。（passive，设置为 true 时，表示 listener 永远不会调用 preventDefault()。）

在Android的手q和微信中使用的是X5内核，它是基于blink内核的，因此同样有关于 passiveevent的优化。所以我们需要加入 addEventListner的第三个参数：

``` javascript
document.addEventListener(
  'touchmove',
  e => {
    e.preventDefault();
  },
  { passive: false }
)
```

带来的问题：**所有的滚动事件全部被禁止了！**

### 3.5 有选择性地阻止默认事件

浮层上面有需要滚动的元素，最简单的方案就是有选择性地阻止默认事件：

``` javascript
document.addEventListener(
  'touchmove',
  e => {
    const excludeEl = document.querySelectorAll('.can-scroll');
    const isExclude = [].some.call(excludeEl, (el) =>
      el.contains(e.target),
    );
    if (isExclude) {
      return true;
    }
    e.preventDefault();
  },
  { passive: false },
);
```

规定带有 `can-scroll`类名的元素是可滚动的，这些元素以及他们的子元素全部采用不阻止默认事件策略。

带来的问题：**当滚动到元素顶部和底部（即：当滑动超出边界时）再继续滚动时，又会触发滚动穿透！**

解决方法：在边界条件时阻止滚动。

``` javascript
// 监听所有可滚动元素的滚动事件
[].forEach.call(scrollEl, (el) => {
  let initialY = 0;
  el.addEventListener('touchstart', e => {
    if (e.targetTouches.length === 1) {
      // 单点滑动
      initialY = e.targetTouches[0].clientY;
    }
  });
  el.addEventListener('touchmove', e => {
    if (e.targetTouches.length === 1) {
      // 单点滑动
      const clientY = e.targetTouches[0].clientY - initialY;
      if (el.scrollTop + el.clientHeight >= el.scrollHeight && clientY < 0) {
        // 向下滑至底部
        return e.preventDefault();
      }
      if (el.scrollTop <= 0 && clientY > 0) {
        // 向上滑至顶部
        return e.preventDefault();
      }
    }
  });
});
```

### 3.6 支持多浮层

场景：当多个浮层同时存在时，滚动穿透将再次触发。

原因：出现多浮层问题，是因为往 `document`上绑事件只绑一次，这个是对的，但是每个浮层关闭的时候都会触发 `unbind`（移除被选元素的事件处理程序），就会导致绑定的事件直接解绑，但其实这时还有其他浮层需要阻止滚动穿透。

解决方法：每一个浮层作为一个实例，定义一个Set来存储当前锁定的浮层

``` javascript
const lockedList = new Set();
lock() {
  lockedList.add(this);
  // 省略其他逻辑}unlock()
}

unlock() {
  lockedList.delete(this);
  if (lockedList.size <= 0) {
    this.destroy();
  }
}
```

只有当这个set没有值的时候，也就是所有的弹框均调用 unlock之后，再去解绑事件。

### 3.7 组件调用（React）

组件传入一个 lock参数，当组件挂载时创建一个实例（保证了每个浮层一个实例），在lock变化时调用 `lock` 或 `unlock` 来解决滚动穿透。

``` javascript
componentDidMount() {
  const opts = this.props.selector ? {
    selector: this.props.selector
  } : undefined;
  this.lockScroll = new LockScroll(opts);
  this.updateScrollFix();
}
updateScrollFix() {
  const {
    lock
  } = this.props;
  if (lock) {
    this.lockScroll.lock();
  } else {
    this.lockScroll.unlock();
  }
}
componentDidUpdate(prevProps: ScrollFixProps) {
  if (prevProps.lock !== this.props.lock) {
    this.updateScrollFix();
  }
}
componentWillUnmount() {
  console.log('scrollfix component will unmount!');
  this.lockScroll.unlock();
}
```

使用：只需要将浮层包裹在组件内，并且传入 lock属性，即可不用再关注滚动穿透的问题

``` javascript
<ScrollFix lock={show}>  
  <!-- 浮层内容 -->
</ScrollFix>
```

> 来源：IMWeb前端社区(公众号)  
> 作者：IMWeb  
> 链接：<https://mp.weixin.qq.com/s/Vr-R4FYLcb7CzDR2pkxzjg>

## 4. IOS滚动 以及 `-webkit-overflow-scrolling:touch`

### 4.1 IOS Safari 布局抖动

+ 场景：
  + 一个布局为header、main、bottom的布局，其中 头部(header) 和 底部(bottom) 通过fixed固定，中间部分(main) 可以通过滚动条滑动。
  + 实现只要中间的内容超过屏幕高度时，中间内容会自动滚动的效果。只需要在中间部分(main)上下添加`padding`
  + 在 Safari 上，当超出页面高度，页面往下滑时，底部(bottom) 会随着页面一起滑动（向下滚动时会拉起底部(bottom)），造成不好的体验。

+ 解决方法：
  + 在中间部分(main)使用 `fixed定位`，加上 `overflow-y` 属性

    ``` css
    .main {
      position: fixed;
      top: 50px;
      bottom: 50px;
      overflow-y: scroll;
    }
    ```

  + 中间部分(main)不设定位，高度100%，使用padding防止头部和尾部遮挡

    ``` css
    html, body {
      height: 100%;
    }
    .main {
      padding: 50px 0;
      height: 100%;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
    }
    ```

### 4.2 `-webkit-overflow-scrolling: touch`

`-webkit-overflow-scrolling` 属性控制元素在移动设备上是否使用滚动回弹效果：

+ `auto`: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。
+ `touch`: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。

使用 `overflow-y:scorll` 属性的时候，滚动不流畅，可以使用 `-webkit-overflow-scrolling: touch` 属性，让滚动条产生滚动回弹的效果，就像IOS原生的滚动条一样流畅。

### 4.3 `-webkit-overflow-scrolling: touch` 偶尔卡住或不能滑动的bug

+ 常见示例：
  + 在Safari上，使用了 `-webkit-overflow-scrolling: touch` 之后，页面偶尔会卡住不动
  + 在Safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug
  + 通过动态添加内容撑开容器，结果根本不能滑动的bug

+ 解决方法：
  + 保证使用了该属性的元素上 `不设置定位` 或者手动设置定位为 `position: static`
  + 如果添加动态内容页面不能滚动，让子元素 `height + 1`

    在 `webkit-overflow-scrolling:touch` 属性的下一层子元素上，将`(height + 1%) 或 (height + 1px)`。从而主动触发scrollbar。

    ``` css
    .main {
      min-height: calc(100% + 1px);
      /* 或者 */
      min-height: calc(100% + 1%);
    }

    /* 也可以直接添加到伪元素上 */
    .main:after {
      min-height: calc(100% + 1px);
      /* 或者 */
      min-height: calc(100% + 1%);
    }
    ```

+ 出现卡住不动 bug
  Safari对于 `overflow-scrolling` 用了原生控件来实现。对于有 `-webkit-overflow-scrolling` 的网页，会创建一个 `UIScrollView` ，提供 `子layer` 给渲染模块使用。

### 4.4 `-webkit-overflow-scrolling: touch`的其他坑

+ 滚动中 `scrollTop` 属性不会变化
+ 手势可穿过其他元素触发元素滚动
+ 滚动时暂停其他 transition

### 4.5 针对 Safari 滚动问题，可以使用 `iScroll` 或者 `better-scroll`

> 来源：博客  
> 作者：夏大师  
> 链接：<https://www.cnblogs.com/xiahj/p/8036419.html>
