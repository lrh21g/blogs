# TypeScript基础

## 类型

### 基础类型

``` typescript
// 布尔值 - true / false
let bool: boolean = false;

// 数字 - 支持二、八、十、十六进制的数值
let num: number = 6;

// 字符串 - 单引号/双引号/模板字符串包裹的内容、字符串字面量类型
let str1: string = "Bob";
str1 = 'Tom'
// 字符串字面量类型，即把一个字符串字面量作为一种类型
// 当把一个变量指定为字符串类型的时候，就不能再赋值为其他字符串值
let str2:'Bob'
str2 = 'Jerry' // error 不能将类型 "Jerry"，分配给类型 "Bob"

// 数组
// 格式: type[] 或 Array<type> - type为元素类型
// 设置元素类型均为 number 类型的数组类型，如下所示：
let arr1: number[] = [1, 2, 3]; // type[] 格式 - 推荐使用格式
let arr2: Array<number> = [1, 2, 3]; // Array<type> 格式
// 指定数组里的元素既可以是数值也是字符串，如下所示：
let arr3: number|string[] = [1, 'str'];

// Object
// 希望一个变量或者函数的参数的类型是一个对象时，使用此类型
let obj: object
obj = { name: 'Tom' }
// 问题一: 访问对象中的某个属性，会报错，提示类型 object 上没有这个属性
obj.name // error: 类型 object 上不存在属性 name
// 问题一解决方法：可以使用接口（interface）
interface User {
  name: string;
}
let obj: User = { name: 'Tom' }
// 问题二: 当定义一个函数，参数必须为对象，此时需要用到 object 类型，
function getValue(obj: object, key: string) {
  return obj[key]; // error
}
getValue(obj, 'name')
// 问题二解决方法：使用泛型
function getValue<T extends object, U extends keyof T>(obj: T, key: U) {
  return obj[key];
}

// null 和 undefined
// 默认情况下， undefined 和 null 可以赋值给任意类型的值
// 在 tsconfig.json 的"compilerOptions"里设置了"strictNullChecks": true时，
// >>> undefined 和 null 将只能赋值给它们自身和 void 类型
let u: undefined = undefined;
let n: null = null;

// Symbol：表示独一无二的值，通过 Symbol 函数生成。
// 注意：使用 Symbol 的时候，必须添加 es6 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom"]
let sym1 = Symbol('key');

// BigInt：可以安全地存储和操作大整数。（即超出 Number 能够表示的安全整数范围）
// 使用 BigInt(number) 把 Number 转换为 BigInt
// 如果类型是 BigInt，那么数字后面需要加 n。
// eg: const max1 = max + 1n
// 注意：使用 BigInt 的时候，必须添加 ESNext 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom", "ESNext"]
// declare 定义的类型只会用于编译时的检查，编译结果中会被删除。
declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.
```

### 补充类型

``` typescript
// 元组（Tuple）
// 表示一个已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型。
// TypeScript 2.6+ 要求元组赋值必须类型和个数都对应。
let tuple: [string, number] = ['hello', 10];
// TypeScript 2.6+ [string, number]元组类型的声明效果上可以看做等同于下面的声明：
interface Tuple extends Array<number | string> {
  0: string;
  1: number;
  length: 2;
}

// 枚举（enum）
// 默认情况下，从 0 开始为元素编号
enum Color { Red, Green, Blue };
let c: Color = Color.Green; // 1
console.log(Color[1]) // 'Green'
// 也可以为每个值都赋予不同的、不按顺序排列的值
enum Color { Red = 1, Green = 2, Blue = 4 }
let c: Color = Color.Green; // 2

// Any
// 在编程阶段，不清楚为一个变量指定什么类型，则需要用到 Any 类型
let notSure: any = 4;
notSure = 'maybe a string instead';
// 使用 any 来指定数组中元素类型为任意类型
let list: any[] = [1, true, 'free'];

// void
// 表示没有任何类型。
// 使用场景：当一个函数没有返回值时，通常返回值类型是 void。
// 声明一个 void 类型的变量，只能赋予 undefined 和 null
function warnUser(): void {
  console.log('This is my warning message');
}

// never
// 永不存在的值的类型。使用场景有：
// >>> 1.抛出异常的返回值类型
// >>> 2.根本不会有返回值的函数表达式 或 箭头函数表达式的返回值类型
// >>> 3.变量被用不为真的类型保护所约束时
// never 是任何类型的子类型，可以赋值给任何类型。
// 没有任何类型是 never 的子类型或可以赋值给 never 类型（除了never本身之外）。
// any 也不可以赋值给 never。
// 示例一：抛出异常场景
const errorFunc = (message: string): never => {
  throw new Error(message); // 抛出异常
}
// 示例二：根本不会有返回值的函数，需要区分在定义函数时没有给返回值的情况
const infiniteFunc = (): never => {
  while (true) {}
}
// 示例三：
// 右边的函数体内是一个死循环，所以此函数调用后的返回值类型为 never
// 当给 neverVariable 赋值就会报错
let neverVariable = (() => { while (true) {}; })();
neverVariable = 123; // error 不能将类型"number"分配给类型"never"

// unknown：表示未知类型，相对于 any 是安全的。
// 1、任何类型的值都可以赋值给 unknown 类型
let value1: unknown;
value1 = "a";
value1 = 123;
///2、如果没有类型断言或基于控制流的类型细化时 unknown 不可以赋值给其它类型，此时它只能赋值给 unknown 和 any 类型
let value2: unknown;
let value3: string = value2; // error 不能将类型“unknown”分配给类型“string”
value1 = value2;
// 3、如果没有类型断言或基于控制流的类型细化，则不能在它上面进行任何操作
let value4: unknown;
value4 += 1; // error 对象的类型为 "unknown"
// 4、unknown 与任何其它类型组成的交叉类型，最后都等于其它类型
type type1 = unknown & string; // type1 => string
type type2 = number & unknown; // type2 => number
type type3 = unknown & unknown; // type3 => unknown
type type4 = unknown & string[]; // type4 => string[]
// 5、unknown 与任何其它类型组成的联合类型，都等于 unknown 类型，但只有any例外，unknown与any组成的联合类型等于any
type type5 = string | unknown; // type5 => unknown
type type6 = any | unknown; // type6 => any
type type7 = number[] | unknown; // type7 => unknown
// 6、never 类型是 unknown 的子类型
type type8 = never extends unknown ? true : false; // type8 => true
// 7、keyof unknown 等于类型 never
type type9 = keyof unknown; // type9 => never
// 8、只能对 unknown 进行等或不等操作，不能进行其它操作
value1 === value2;
value1 !== value2;
value1 += value2; // error
// 9、unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例
let value5: unknown;
value5.age; // error
value5(); // error
new value5(); // error
// 10、使用映射类型时如果遍历的是 unknown 类型，则不会映射任何属性
type Types<T> = { [P in keyof T]: number };
type type10 = Types<any>; // type10 => { [x: string]: number }
type type11 = Types<unknown>; // type10 => {}

// 交叉类型：取多个类型的并集。使用 & 符号，被 & 符链接的多个类型构成一个交叉类型。
const merge = <T, U>(arg1: T, arg2: U): T & U => {
  let res = <T & U>{}; // 指定返回值的类型兼备T和U两个类型变量代表的类型的特点
  res = Object.assign(arg1, arg2); // 使用Object.assign方法，返回一个合并后的对象；
  return res;
};

// 联合类型：使用 | 符号，只要符合联合类型中的任何一种类型即可
const getLength = (content: string | number): number => {
  if (typeof content === "string") return content.length;
  else return content.toString().length;
};
```

### 枚举类型

枚举使用 `enum` 关键字定义，支持数字和字符串枚举。

+ 数字枚举
  
  枚举默认为数字类型，从 0 开始一次累加。

  数字枚举在定义的时候，可以使用计算值和常量。如果某个字段使用了计算值或常量，那么该字段后面紧接着的字段必须设置初始值，不能使用默认的递增值。

  ``` typescript
  // 指定部分字段，其他使用默认递增索引
  enum Status {
    Ok = 200,
    Created, // 201
    Accepted, // 202
    BadRequest = 400,
    Unauthorized // 401
  }

  const Start = 1;
  enum Index {
    a = Start,
    b, // error 枚举成员必须具有初始化的值
    c
  }
  ```

+ 反向映射

  定义一个枚举值的时候，可以通过 `Enum['key']` 或者 `Enum.key` 的形式获取对应的值 value。**TypeScript 支持反向映射，但是只支持数字枚举**。

  ``` typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    Error = 500
  }
  console.log(Status["Success"]); // 200
  console.log(Status[200]); // 'Success'
  console.log(Status[Status["Success"]]); // 'Success'

  // 编译为 JavaScript 为
  var Status;
  (function (Status) {
    Status[Status["Success"] = 200] = "Success";
    Status[Status["NotFound"] = 404] = "NotFound";
    Status[Status["Error"] = 500] = "Error";
  })(Status || (Status = {}));
  ```

+ 字符串枚举
  
  字符串枚举值要求每个字段的值都必须是**字符串字面量**，或者是**该枚举值中另一个字符串枚举成员**。

  枚举值中可以使用其他枚举成员。**其他枚举成员指的是同一个枚举值中的枚举成员**，因为字符串枚举不能使用常量或者计算值，所以不能使用其他枚举值中的成员。

  ``` typescript
  enum Message {
    Error = "Sorry, error",
    Success = "Hoho, success"
  }

  enum Message {
    Error = "error message",
    ServerError = Error,
    ClientError = Error
  }
  console.log(Message.Error); // 'error message'
  console.log(Message.ServerError); // 'error message'
  ```

+ 异构枚举
  
  异构枚举就是枚举值中既有数字类型又有字符串类型。**不建议使用**，因为枚举值的特点往往是相似的。

  ``` typescript
  enum Result {
    Faild = 0,
    Success = "Success"
  }
  ```

+ 枚举成员类型和联合枚举类型

  如果枚举值里**所有成员的值都是字面量类型的值**，那么这个枚举的每个成员和枚举值本身都可作为类型来使用。满足条件的枚举成员的值有：
  + 不带初始值的枚举成员: `enum E { A }`
  + 值为字符串字面量: `enum E { A = 'a' }`
  + 值为数值字面量，或者带 `-` 符号的数值字面量：`enum E { A = 1 }`、`enum E { A = -1 }`

  1. 枚举成员类型

     ``` typescript
      enum Animal {
        Dog = 1,
        Cat = 2
      }
      interface Dog {
        type: Animal.Dog; // 这里使用Animal.Dog作为类型，指定接口Dog的必须有一个type字段，且类型为Animal.Dog
      }
      let dog: Dog = {
        type: Animal.Dog
      };
      ```

  2. 联合枚举类型

    ``` typescript
    enum Status {
      Off,
      On
    }
    interface Light {
      status: Status;
    }
    const light1: Light = {
      status: Status.Off
    };
    ```

+ const enum

  如果使用枚举只是为了让程序可读性好，而不需要编译后的对象，则可以使用 `const enum`（完全嵌入的枚举），在代码编译后不会创建这个对象，只会从枚举里拿到相应的值进行替换。

  ``` typescript
  const enum Animal {
    Dog,
    Cat
  }
  const animal = Animal.Dog;
  ```

### 类型断言

类型断言，把某个值强行指定为特定类型。主要形式有:

+ `<type>value` 形式: 这种形式在JSX代码中不可以使用，而且也是TSLint不建议的写法
+ `value as type` 形式: 推荐写法

TypeScript 有时不如我们了解一个值的类型，这时希望 TypeScript 进行类型检查，而是交给我们自己进行处理，则需要用到类型断言。

``` typescript
const getStrLength = (target: string | number): number => {
  // 当 TypeScript 不确定一个联合类型的变量是哪个类型的时候
  // 而此时只能访问此联合类型的所有类型里共有的属性或方法
  // 所以需要用到了类型断言进行判断
  if ((<string>target).length) {
    return (target as string).length;
  } else {
    return target.toString().length;
  }
};
```

### 类型推断

在一些定义中如果没有明确指定类型，编译器会自动推断出适合的类型。

+ 基础推论: 根据右侧的值推断左侧变量的类型。

  ``` typescript
  let name = "lison";
  name = 123; // error 不能将类型“123”分配给类型“string”
  ```

+ 多类型联合: 当定义一个数组或元组这种包含多个元素的值的时候，多个元素可以有不同的类型，TypeScript 会将多个类型合并起来，组成一个联合类型。

  ``` typescript
  let arr = [1, "a"];
  arr = ["b", 2, false]; // error 不能将类型“false”分配给类型“string | number”
  ```

+ 上下文类型: 根据左侧的类型推断右侧的一些类型。

  ``` typescript
  // 表达式左侧是 window.onmousedown(鼠标按下时发生事件)
  // 因此 TypeScript 会推断赋值表达式右侧函数的参数是事件对象
  // 表达式左侧是 mousedown 事件，所以 TypeScript 推断 mouseEvent 的类型是 MouseEvent。
  // 在回调函数中使用 mouseEvent 的时候，可以访问鼠标事件对象的所有属性和方法，当访问不存在属性的时候，就会报错。
  window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.a); // error 类型“MouseEvent”上不存在属性“a”
  };
  ```

## 接口（interface）

使用interface来定义接口。

在定义接口的时候，`{}` 括号包裹的是一个代码块，是声明类型的语句。使用冒号指定类型，每条声明之间使用换行分隔，也可以使用分号或逗号。

``` javascript
interface Say {
  (words: string) : string
}

interface User {
  name: string
  age?: number // 可选属性
  readonly isMale: boolean // 只读属性
  say: (words: string) => string // 函数类型描述方法一：在 interface 内部描述函数
  // say: Say // 函数类型描述方法二：先用接口直接描述函数类型，然后再 User 内使用
}
const getUserName = (user: User) => user.name
```

### 多余属性检查

对于多余属性检查，定义的变量比接口少了一些或者多了一些属性是不允许的。

绕开多余属性检查的方法如下：

+ 使用类型断言

  ``` typescript
  interface Vegetables {
    color?: string;
    type: string;
  }
  const getVegetables = ({ color, type }: Vegetables) => {
    return `A ${color ? color + " " : ""}${type}`;
  };
  getVegetables({
    type: "tomato",
    size: 12,
    price: 1.2
  } as Vegetables);
  ```

+ 添加索引签名

  ``` typescript
  interface Vegetables {
    color: string;
    type: string;
    [prop: string]: any;
  }
  const getVegetables = ({ color, type }: Vegetables) => {
    return `A ${color ? color + " " : ""}${type}`;
  };
  getVegetables({
    color: "red",
    type: "tomato",
    size: 12,
    price: 1.2
  });
  ```

+ 利用类型兼容性

  ``` typescript
  interface Vegetables {
    type: string;
  }
  const getVegetables = ({ type }: Vegetables) => {
    return `A ${type}`;
  };
  const option = { type: "tomato", size: 12 };
  getVegetables(option);
  ```

### 索引类型

使用接口描述索引的类型和通过索引得到的值的类型，也可以给索引设置 `readonly`，从而防止索引返回值被修改。

``` typescript
interface RoleDic {
  readonly [id: number]: string;
}
const role1: RoleDic = {
  0: "super_admin",
  1: "admin"
};
role1[0] = "admin"; // error 类型"RoleDic"中的索引签名仅允许读取
const role2: RoleDic = {
  s: "super_admin",  // error 不能将类型"{ s: string; a: string; }"分配给类型"RoleDic"。
  a: "admin"
};
// role3 定义了一个数组，索引为数值类型，值为字符串类型
const role3: RoleDic = ["super_admin", "admin"];
```

注意：如果设置索引类型为字符串类型，即便属性名设置的是数值类型，也没有问题。因为 JavaScript 在访问属性值的时候，如果属性名是数值类型，会先将数值类型转为字符串，然后再去访问。

``` javascript
const obj = {
  123: "a", // 定义一个数值类型的123这个属性
  // 在定义一个字符串类型的123这个属性
  // 这里会报错：标识符“"123"”重复。
  "123": "b"
};
console.log(obj); // { '123': 'b' }
```

### 继承接口

接口可以继承，和类一样，提高了接口的可复用性

一个接口可以被多个接口继承，同样，一个接口也可以继承多个接口，多个接口用逗号隔开。

``` typescript
interface Vegetables {
  color: string;
}
interface Food {
  type: string;
}
interface Tomato extends Food, Vegetables {
  radius: number;
}
const tomato: Tomato = {
  type: "vegetables",
  color: "red",
  radius: 1.2
};  // 在定义tomato变量时将继承过来的color和type属性同时声明
```

### 混合类型接口

在 JavaScript 中，函数是对象类型，对象可以有属性，所以有时一个对象既是一个函数，也包含一些属性。TypeScript 3.1+ 支持直接给函数添加属性

``` typescript
interface Counter {
  // 函数，函数的要求是无参数，返回值为void，即无返回值
  (): void;
  // 值的类型为 number 类型的属性
  count: number;
}
// 定义一个函数用来返回这个计数器
const getCounter = (): Counter => {
  const c = () => { c.count++; };
  c.count = 0; // 给函数添加一个 count 属性初始值为 0
  return c; // 返回函数对象
};
// 通过 getCounter 函数得到这个计数器
const counter: Counter = getCounter();
counter();
console.log(counter.count); // 1
counter();
console.log(counter.count); // 2
```

## 函数（Function）

### 函数类型

+ 为函数定义类型

  ``` typescript
  function add(arg1: number, arg2: number): number {
    return x + y;
  }
  // 或者
  const add = (arg1: number, arg2: number): number => {
    return x + y;
  };
  ```

+ 完整的函数类型
  
  一个函数的定义包括函数名、参数、逻辑和返回值。

  ``` typescript
  let add: (x: number, y: number) => number;
  add = (arg1: number, arg2: number): number => arg1 + arg2;
  // error
  add = (arg1: string, arg2: string): string => arg1 + arg2;
  ```

+ 使用接口定义函数类型

  ``` typescript
  interface Add {
    (x: number, y: number): number;
  }
  // error 不能将类型“(arg1: string, arg2: string) => string”分配给类型“Add”
  let add: Add = (arg1: string, arg2: string): string => arg1 + arg2;
  ```

+ 使用类型别名

  ``` typescript
  type Add = (x: number, y: number) => number;
  // error 不能将类型“(arg1: string, arg2: string) => string”分配给类型“Add”
  let add: Add = (arg1: string, arg2: string): string => arg1 + arg2;
  ```

### 参数

``` typescript
const add = (
  // 必选参数
  a: number,
  // 可选参数
  // 接口类型定义的函数类型必选参数和可选参数位置是无所谓的
  // 但是此方式需要将必选参数不能位于可选参数后。
  b?: number,
  // 默认参数：放在必选参数前后都可以
  c = 3,
  // 剩余参数：使用 ... 来表示剩余参数
  ...rest: number[]
) => { // 函数操作... }
```

### 函数重载

在其他一些强类型语言中，函数重载指定义几个函数名相同，但是参数个数或类型不同的函数，在调用时传入不同的参数，编译器会自动调用适合的函数。

TypeScript的函数重载是在类型系统层面的，是为了更好地进行类型推断。与其他一些强类型语言中的定义不同。

TypeScript的函数重载通过为一个函数指定多个函数类型定义，从而对函数调用的返回值进行检查。

**重载只能用 function 来定义，不能使用接口、类型别名等。**

``` typescript
// 重载的一部分，指定当参数类型为string时，返回值为string类型的元素构成的数组
function handleData(x: string): string[];
// 重载的一部分，指定当参数类型为number时，返回值类型为string
function handleData(x: number): string;
// 重载的内容，是实体函数，不算做重载的部分
function handleData(x: any): any {
  if (typeof x === "string") {
    return x.split("");
  } else {
    return x
      .toString()
      .split("")
      .join("_");
  }
}
handleData("abc").join("_");
handleData(123).join("_"); // error 类型"string"上不存在属性"join"
handleData(false); // error 类型"boolean"的参数不能赋给类型"number"的参数。
```

## 泛型（generic）

泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

``` typescript
// 使用 <> 符号定义了一个泛型变量 T
// T 代表某一种类型，可以是基础类型、联合类型等高级类型
// 定义泛型变量之后，在函数中任何地方指定类型使用 T，都代这一种类型
const getArray = <T>(value: T, times: number = 5): T[] => {
  return new Array(times).fill(value);
};
// 可以省略 <number[]>，TypeScript会根据传入函数的value值的类型进行推断
getArray<number[]>([1, 2], 3).forEach(item => {
  console.log(item.length);
});
```

### 泛型变量

**当使用泛型的时候，必须在处理类型涉及到泛型的数据的时候，把这个数据当做任意类型来处理。**这就意味着不是所有类型都能做的操作不能做，不是所有类型都能调用的方法不能调用。

``` typescript
const getLength = <T>(param: T): number => {
  return param.length; // error 类型“T”上不存在属性“length”
};
```

### 泛型函数类型

``` typescript
// 简单定义
const getArray: <T>(arg: T, times: number) => T[] = (arg, times) => {
  return new Array(times).fill(arg);
};

// 使用类型别名
type GetArray = <T>(arg: T, times: number) => T[];
const getArray: GetArray = <T>(arg: T, times: number): T[] => {
  return new Array(times).fill(arg);
};

// 使用接口形式
interface GetArray {
  <T>(arg: T, times: number): T[];
}
const getArray: GetArray = <T>(arg: T, times: number): T[] => {
  return new Array(times).fill(arg);
};

// 将接口中泛型变量提升到接口最外层
// 接口中所有属性和方法都能使用这个泛型变量
interface GetArray<T> {
  (arg: T, times: number): T[];
  tag: T;
}
const getArray: GetArray<number> = <T>(arg: T, times: number): T[] => {
  // error 不能将类型“{ <T>(arg: T, times: number): T[]; tag: string; }”分配给类型“GetArray<number>”。
  // 属性“tag”的类型不兼容。
  return new Array(times).fill(arg);
};
getArray.tag = "a"; // 不能将类型“"a"”分配给类型“number”
getArray("a", 1); // 不能将类型“"a"”分配给类型“number”
```

### 泛型约束

泛型约束就是使用一个类型和 `extends` 对泛型进行约束。

``` typescript
interface ValueWithLength {
  length: number;
}
// 泛型变量 T 受到约束
// 必须满足接口 ValueWithLength，即不管是什么类型，但必须有一个 length 属性，且类型为数值类型。
const getLength = <T extends ValueWithLength>(param: T): number => {
  return param.length;
};
getLength("abc"); // 3
getLength([1, 2, 3]); // 3
getLength({ length: 3 }); // 3
getLength(123); // error 类型“123”的参数不能赋给类型“ValueWithLength”的参数
```

### 在泛型约束中使用类型参数

+ 场景：当定义一个对象，想要只能访问对象上存在的属性时

  使用 K 来继承索引类型 `keyof T`，`keyof T` 相当于一个由泛型变量 T 的属性名构成的联合类型。

  ``` typescript
  const getProp = <T, K extends keyof T>(object: T, propName: K) => {
    return object[propName];
  };
  const obj = { a: "aa", b: "bb" };
  getProp(obj, "c"); // 类型“"c"”的参数不能赋给类型“"a" | "b"”的参数
  ```

+ 场景：当泛型需要被所规定接口约束时

  ``` typescript
  interface FirstInterface {
    doSomething(): number
  }
  interface SecondInterface {
    doSomethingElse(): string
  }

  // 方法一：将接口 FirstInterface 与 SecondInterface 作为超接口来解决问题
  interface ChildInterface extends FirstInterface, SecondInterface {}
  class Demo<T extends ChildInterface> {
    private genericProperty: T

    useT() {
      this.genericProperty.doSomething()
      this.genericProperty.doSomethingElse()
    }
  }

  // 方法二：利用交叉类型进行多类型约束
  class Demo<T extends FirstInterface & SecondInterface> {
    private genericProperty: T
    useT() {
      this.genericProperty.doSomething() // ok
      this.genericProperty.doSomethingElse() // ok
    }
  }
  ```

+ 场景：当声明一个泛型拥有构造函数时
  
  问题：编译器会提示表达式不能构造，因为没有声明这个泛型 T 是构造函数

  ``` typescript
  function factory<T>(type: T): T {
    return new type(); // error: This expression is not constructable
  }

  // 解决方法：使用 new
  // 参数 type 的类型 { new(): T }
  // 表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T
  function factory<T>(type: {new(): T}): T {
    return new type() // ok
  }
  ```

## 类（class）

TypeScript 的类与 ES 中的类并无差异，可参考 ES6 标准类

### 修饰符

+ `public`: 表示**公共的**，用来指定在创建实例后可以通过实例访问的，也就是类定义的外部可以访问的属性和方法
+ `private`: 表示**私有的**，它修饰的属性在类的定义外面是无法访问的
+ `protected`: 表示**受保护的**，它修饰的成员在继承该类的子类中可以访问

  `protected` 可以用来修饰 `constructor` 构造函数，加了 `protected` 修饰符之后，这个类不能再用来创建实例，只能被子类继承。
+ `readonly`: 将属性设置为**只读**，实例只能读取这个属性，但不能修改

``` typescript
class Parent {
  public name: string; // 公共属性
  private sex: string; // 私有属性
  protected age: number; // 受保护的属性
  readonly card: string; // 只读属性
  constructor (age: number) {
    this.age = age
  }
  protected getAge() { return this.age; }
  // constructor 加了 `protected` 修饰符之后，这个类不能再用来创建实例，只能被子类继承。
  // protected constructor () {}
}
const p = new Parent(18);
class Child extends Parent {
  constructor (age: number) {
    super(age);
    console.log(super.age) // undefined
    console.log(super.getAge()); // 18
  }
}
new Child(18);
```

### 属性与存取器

+ 参数属性: 在 `constructor` 构造函数的参数前面加上访问限定符（即`public`、`private`、`protected`、`readonly`中的任意一个）
+ 静态属性: 使用 `static` 关键字来指定属性或方法是静态的，实例将不会添加这个静态属性，也不会继承这个静态方法。也可以使用修饰符和 `static` 关键字来指定一个属性或方法
+ 可选类属性: 使用 `?` 符号来标记
+ 存取器
  + 存值函数 - 在设置属性值的时候调用的函数
  + 取值函数 - 在访问属性值的时候调动的函数

``` typescript
class Parent {
  private _fullName: string = "";
  sex?: string;
  public static age: number = 18;
  public static getAge() { return Parent.age }
  constructor (public name: string, sex?: string, public card?: string) {
    this.name = name;
    this.sex = sex;
  }
  get fullName() { return this._fullName }
  set fullName(value) { this._fullName = value }
}
const p1 = new Parent('Tom')
const p2 = new Parent('Tom', '男')
const p3 = new Parent('Tom', '男', '101')
p1.fullName = "Jerry"; // setter: Jerry
console.log(p1.fullName); // Jerry
console.log(p1.age); // error Property 'age' is a static member of type 'Parent'
console.log(Parent.age); // 18
```

### 抽象类

抽象类一般用来被其他类继承，而不直接用它创建实例。抽象类和类内部定义抽象方法，使用 `abstract` 关键字

``` typescript
abstract class People {
  constructor(public name: string) {}
  abstract printName(): void;
}
class Man extends People {
  constructor(name: string) {
    super(name);
    this.name = name;
  }
  // 在抽象类里定义的抽象方法，在子类中是不会继承的，所以在子类中必须实现该方法的定义。
  // error 非抽象类“Man”不会实现继承自“People”类的抽象成员"printName"
  // printName() { console.log(this.name); }
}
const m = new Man("lison");
m.printName(); // error m.printName is not a function
```

### 实例类型

定义一个类并创建实例后，这个实例的类型就是创建他的类。如果想实现对创建实例的类的判断，需要用到 `instanceof` 关键字

``` typescript
class People {
  constructor(public name: string) {}
}
let p: People = new People("lison");
```

### 其他

+ 类类型接口: 使用接口可以强制一个类的定义必须包含某些内容
  
  + `implements` 关键字：用来指定一个类要继承的接口（类继承接口）
  + `extends` 关键字：用于接口和接口、类和类直接的继承

  ``` typescript
  interface FoodInterface {
    type: string;
  }
  class FoodClass implements FoodInterface {
    // error Property 'type' is missing in type 'FoodClass' but required in type 'FoodInterface'
    // 定义了静态属性 type，但静态属性不会添加到实例上，所以还是报错
    static type: string;
    constructor() {}
  }

  // 错误解决方法一：
  interface FoodInterface {
    type: string;
  }
  class FoodClass implements FoodInterface {
    constructor(public type: string) {}
  }
  // 错误解决方法二：
  abstract class FoodAbstractClass {
    abstract type: string;
  }
  class Food extends FoodAbstractClass {
    constructor(public type: string) {
      super();
    }
  }
  ```

+ 接口继承类

  接口可以继承一个类，当接口继承了该类后，会继承类的成员，但是不包括其实现，也就是**只继承成员以及成员类型**。
  
  接口还会**继承类的 `private` 和 `protected` 修饰的成员**，当接口继承的这个类中包含这两个修饰符修饰的成员时，这个接口**只可被这个类或他的子类实现**。

  ``` typescript
  class A {
    protected name: string;
  }
  interface I extends A {}
  class B implements I {} // error Property 'name' is missing in type 'B' but required in type 'I'
  class C implements I {
    // error 属性“name”受保护，但类型“C”并不是从“A”派生的类
    name: string;
  }
  class D extends A implements I {
    getName() {
      return this.name;
    }
  }
  ```

+ 在泛型中使用类类型

  ``` typescript
  // 参数 c 的类型定义中，new()代表调用类的构造函数
  // 他的类型也就是类创建实例后的实例的类型。
  const create = <T>(c: { new (): T }): T => {
    // 使用传进来的类 c 创建一个实例并返回
    // 返回的实例类型也就是函数的返回值类型。
    return new c();
  };
  class Info {
    age: number;
  }
  // 通过定义 create，TS 就知道:
  // 调用 create 函数，传入的和返回的值都应该是同一个类类型。
  create(Info).age;
  create(Info).name; // error 类型“Info”上不存在属性“name”
  ```

## 类型兼容性

### 函数兼容性

+ 函数参数个数: 对函数 y 进行赋值，要求 x 中的每个参数都应在 y 中有对应，也就是参数个数小于等于 y 的参数个数。
+ 函数参数类型: 除了参数个数，参数的类型需要对应。
+ 剩余参数和可选参数: 当要被赋值的函数参数中包含剩余参数（...arg）时，赋值的函数可以用任意个数参数代替，但是类型需要对应。
+ 函数参数双向协变: 参数类型无需绝对相同。

  ``` typescript
  let funcA = function(arg: number | string): void {};
  let funcB = function(arg: number): void {};
  // funcA = funcB 和 funcB = funcA都可以
  ```

+ 函数返回值类型

  ``` typescript
  let x = (a: number): string | number => 0;
  let y = (b: number) => "a";
  let z = (c: number) => false;
  x = y;
  x = z; // 不能将类型“(c: number) => boolean”分配给类型“(a: number) => string | number”
  ```

+ 函数重载: 带有重载的函数，要求被赋值的函数的每个重载都能在用来赋值的函数上找到对应的签名

  ``` typescript
  function merge(arg1: number, arg2: number): number; // merge函数重载的一部分
  function merge(arg1: string, arg2: string): string; // merge函数重载的一部分
  function merge(arg1: any, arg2: any) { // merge函数实体
    return arg1 + arg2;
  }
  function sum(arg1: number, arg2: number): number; // sum函数重载的一部分
  function sum(arg1: any, arg2: any): any { // sum函数实体
    return arg1 + arg2;
  }
  let func = merge;
  func = sum; // error 不能将类型“(arg1: number, arg2: number) => number”分配给类型“{ (arg1: number, arg2: number): number; (arg1: string, arg2: string): string; }”
  ```

### 枚举

+ 数字枚举成员类型与数字类型互相兼容，但是不同枚举值之间是不兼容的

  ``` typescript
  enum Status { On, Off }
  enum Color { White, Black }
  let s = Status.On;
  s = Color.White; // error Type 'Color.White' is not assignable to type 'Status'
  ```

+ 字符串枚举成员类型和字符串类型是不兼容的

  ``` typescript
  enum Status { On = 'on', Off = 'off' }
  let s = Status.On
  s = 'Lison' // error 不能将类型“"Lison"”分配给类型“Status”
  ```

### 类

+ 比较两个类类型的值的兼容性时，**只比较实例的成员**，类的静态成员和构造函数不进行比较

  ``` typescript
  class Animal {
    static age: number;
    constructor(public name: string) {}
  }
  class People {
    static age: string;
    constructor(public name: string) {}
  }
  class Food {
    constructor(public name: number) {}
  }
  let a: Animal;
  let p: People;
  let f: Food;
  a = p; // right
  a = f; // error Type 'Food' is not assignable to type 'Animal'
  ```

+ 类的私有成员和受保护成员会影响兼容性。当检查类的实例兼容性时，如果目标（也就是要被赋值的那个值）类型（这里实例类型就是创建它的类）包含一个私有成员，那么源（也就是用来赋值的值）类型必须包含**来自同一个类的这个私有成员**，这就允许子类赋值给父类。

  ``` typescript
  class Parent {
    private age: number;
    constructor() {}
  }
  class Children extends Parent {
    constructor() {
      super();
    }
  }
  class Other {
    private age: number;
    constructor() {}
  }
  // Children类继承Parent类，且实例属性没有差异，Parent类有私有属性age
  // 但因为Children类继承了Parent类，所以可以赋值。
  const children: Parent = new Children();
  // 不能将类型“Other”分配给类型“Parent”。类型具有私有属性“age”的单独声明
  // Parent 的 age 属性是私有成员，外界是无法访问到的，所以会类型不兼容
  const other: Parent = new Other();
  ```

### 泛型

泛型包含类型参数，这个类型参数可能是任意类型，使用时类型参数会被指定为特定的类型，而这个类型**只影响使用了类型参数的部分**。

``` typescript
interface Data<T> {
  data: T;
}
let data1: Data<number>;
let data2: Data<string>;
data1 = data2; // error 不能将类型“Data<string>”分配给类型“Data<number>”。不能将类型“string”分配给类型“number”
```

## 类型保护

类型保护就是一些表达式，会在运行的时检查以确保在某个作用域的类型，要定义一个类型保护，只要简单地定义一个函数。

``` typescript
const valueList = [123, "abc"];
const getRandomValue = () => {
  // 取一个[0, 10)范围内的随机值
  const number = Math.random() * 10;
  // 如果随机数小于5则返回valueList里的第一个值，也就是123
  if (number < 5) return valueList[0];
  else return valueList[1]; // 否则返回"abc"
};
function isString(value: number | string): value is string {
  const number = Math.random() * 10
  return number < 5;
}
const item = getRandomValue();
// 使用类型保护后，if 的判断逻辑和代码块无需对类型做指定工作
// 定义一个函数用于判断类型是否为字符串类型，进行类型保护
if (isString(item)) {
  console.log(item.length); // 此时item是string类型
} else {
  console.log(item.toFixed()); // 此时item是number类型
}
```

### typeof 类型保护

在 TypeScript 中，如果是基础类型，而不是复杂的类型判断，可以直接使用 `typeof` 来做类型保护。

对 `typeof` 的处理有特殊要求：**只能使用 `=` 和 `!` 两种形式来比较**。`type` 只能是`number`、`string`、`boolean`和`symbol`四种类型

``` typescript
if (typeof item === "string") {
  console.log(item.length);
} else {
  console.log(item.toFixed());
}
```

### instanceof 类型保护

`instanceof` 用来判断一个实例是不是某个构造函数创建的，或者是不是使用 ES6 语法的某个类创建的。

``` typescript
class CreateByClass1 {
  public age = 18;
  constructor() {}
}
class CreateByClass2 {
  public name = "lison";
  constructor() {}
}
function getRandomItem() {
  // 如果随机数小于0.5就返回CreateByClass1的实例，否则返回CreateByClass2的实例
  return Math.random() < 0.5 ? new CreateByClass1() : new CreateByClass2();
}
const item = getRandomItem();
// 判断item是否是CreateByClass1的实例
if (item instanceof CreateByClass1) {
  console.log(item.age);
} else {
  console.log(item.name);
}
```

## 显示赋值断言

当开启 `strictNullChecks` 时，有些情况下编译器无法在声明一些变量前知道一个值是否是 `null` 的，所以需要使用类型断言手动指明该值不为 `null`。

使用显式赋值断言，写法是**在不为 `null` 的值后面加个 `!`**。

``` typescript
function getSplicedStr(num: number | null): string {
  // 在函数 getSplicedStr 里定义一个函数getRes
  // 最后调用 getSplicedStr 返回的值，实际是 getRes 运行后的返回值
  function getRes(prefix: string) {
    // 使用参数num，num的类型为 number 或 null
    // 在运行前编译器是无法知道在运行时 num 参数的实际类型的
    // 所以这里会报错，因为num参数可能为null
    return prefix + num.toFixed().toString();
    // return prefix + num!.toFixed().toString(); // 修改
  }
  // 如果 num 为 null 则会将 0.1 赋给 num，
  // 所以实际调用 getRes 的时候，getRes 里的 num 拿到的始终不为 null
  num = num || 0.1;
  return getRes("lison");
}
```

## null 和 undefined 知识点补充

+ 严格模式下，null和undefined赋值给其它类型值

  在 `tsconfig.json` 中将 `strictNullChecks` 设为 `true` 后，**不能**再将 `undefined` 和 `null` **赋值给除它们自身和void 之外的任意类型值**，但有时需要给一个其它类型的值设置初始值为空，然后再进行赋值，这时可以自己**使用联合类型**来实现 `null` 或 `undefined` 赋值给其它类型

  注意：`string | undefined`、`string | null` 和 `string | undefined | null` 是三种不同的类型。

  ``` typescript
  let str = "lison";
  str = null; // error 不能将类型“null”分配给类型“string”
  // string | null - 表示既可以是 string 类型也可以是 null 类型
  let strNull: string | null = "lison";
  strNull = null; // right
  strNull = undefined; // error 不能将类型“undefined”分配给类型“string | null”
  ```

+ 可选参数和可选属性

  开启了 `strictNullChecks`，可选参数会被自动加上 `| undefined`

  ``` typescript
  const sum = (x: number, y?: number) => {
    return x + (y || 0);
  };
  sum(1, 2); // 3
  sum(1); // 1
  sum(1, undefined); // 1
  sum(1, null); // error Argument of type 'null' is not assignable to parameter of type 'number | undefined'
  ```

## is 关键字

``` typescript
// test is string
// 判断 test 是不是 string 类型，并根据结果返回 boolean 相关类型
function isString(test: any): test is string {
  return typeof test === 'string';
}
// 如果修改为 function isString(test: any): boolean
// 会直接报错
// 因为 is 为关键字的「类型谓语」把参数的类型范围缩小了
// 当使用了 test is string 之后,
// 通过 isString(foo) === true 明确知道其中的参数是 string,而 boolean 并没有这个能力,这就是 is 关键字存在的意义.

function example(foo: number | string){
  if(isString(foo)){
    console.log('it is a string' + foo);
    console.log(foo.length); // string function
  }
}
example('hello world');
```

## 类型别名和字面量类型

### 类型别名

**使用 type 关键字定义类型别名**，之后只要使用这个类型的地方，都可以用类型别名替代，但并不是创建了一个新类型。

``` typescript
// 基本使用
type TypeString = string;
let str: TypeString;
str = 123; // error Type '123' is not assignable to type 'string'

// 使用泛型
type PositionType<T> = { x: T; y: T };
const position: PositionType<number> = {
  x: 1,
  y: -1
};

// 在属性中引用自己
type Child<T> = {
  current: T;
  child?: Child<T>;
};
let ccc: Child<string> = {
  current: "first",
  child: {
    // error
    current: "second",
    child: {
      current: "third",
      child: "test" // 这个地方不符合type，造成最外层child处报错
    }
  }
};
```

注意：

+ 只能在对象属性中引用自己，不能直接使用。
+ 当类型别名为接口起别名时，不能使用 `extends` 和 `implements`

接口和类型别名有时可以起到同样的作用，什么时候用类型别名，什么时候用接口：

+ 当定义的类型要用于拓展，即使用 `implements` 等修饰符时，用接口。
+ 当无法通过接口，并且需要使用联合类型或元组类型时，用类型别名。

### 字面量类型

字面量类型的要和实际的值的字面量一一对应,如果不一致就会报错。

当字面量类型与联合类型结合的时候,可以模拟一个类似于枚举的效果。

+ 字符串字面量类型：即字符串常量，与字符串类型不同的是它是**具体的值**。

  ``` typescript
  type Name = "Tom";
  const name1: Name = "test"; // error 不能将类型“"test"”分配给类型“"Tom"”
  const name2: Name = "Tom";

  type Direction = "north" | "east" | "south" | "west";
  function getDirectionFirstLetter(direction: Direction) {
    return direction.substr(0, 1);
  }
  getDirectionFirstLetter("test"); // error 类型“"test"”的参数不能赋给类型“Direction”的参数
  getDirectionFirstLetter("east");
  ```

+ 数字字面量类型：指定类型为**具体的值**。

  ``` typescript
  type Age = 18;
  interface Info {
    name: string;
    age: Age;
  }
  const info: Info = {
    name: "Lison",
    age: 28 // error 不能将类型“28”分配给类型“18”
  };

  // 经典逻辑错误示例
  function getValue(index: number) {
    // 在判断逻辑处使用了 || 符号
    // 当 index !== 0 不成立时，则 index 就是 0，不应该再判断 index !== 1
    // 当 index !== 0 成立时，后面的判断也不会执行
    // 所以这个地方报错
    if (index !== 0 || index !== 1) {
      // error This condition will always return 'true' since the types '0' and '1' have no overlap
      // ...
    }
  }
  ```

## 可辨识联合类型保证每个 case 都被处理

把单例类型、联合类型、类型保护和类型别名这几种类型进行合并，来创建一个叫做可辨识联合的高级类型，它也可称作标签联合或代数数据类型。

可辨识联合要求具有两个要素：

+ 具有普通的单例类型属性（单例类型，符合单例模式的数据类型，比如枚举成员类型，字面量类型。）
+ 一个类型别名，包含了那些类型的联合（即把几个类型封装为联合类型，并起一个别名）。

### 利用 strictNullChecks

``` typescript
interface Square {
  kind: "square";
  size: number;
}
interface Rectangle {
  kind: "rectangle";
  height: number;
  width: number;
}
interface Circle {
  kind: "circle";
  radius: number;
}
interface Triangle {
  kind: "triangle";
  bottom: number;
  height: number;
}
type Shape = Square | Rectangle | Circle | Triangle;
// Shape 联合有四种接口，但函数的 switch 里只包含三个 case，编译器并没有提示任何错误
// 因为当传入函数的是类型是 Triangle 时，没有任何一个 case 符合，则不会有 return 语句执行，那么函数是默认返回 undefined。
// 开启 strictNullChecks，然后让函数的返回值类型为 number，那么当返回 undefined 的时候，就会报错
function getArea(s: Shape) {
  // error Function lacks ending return statement and return type does not include 'undefined'
  switch (s.kind) {
    case "square":
      return s.size * s.size;
    case "rectangle":
      return s.height * s.width;
    case "circle":
      return Math.PI * s.radius ** 2;
  }
}
```

### 使用 never 类型

当函数返回一个错误或者不可能有返回值的时候，返回值类型为 `never`。

可以给 `switch` 添加一个 `default` 流程，当前面的 `case` 都不符合的时候，会执行 `default` 后的逻辑。

采用这种方式，需要定义一个额外的 `asserNever` 函数，但是这种方式不仅能够在编译阶段提示遗漏了判断条件，而且在运行时也会报错。

``` typescript
function assertNever(value: never): never {
  throw new Error("Unexpected object: " + value);
}
function getArea(s: Shape) {
  switch (s.kind) {
    case "square":
      return s.size * s.size;
    case "rectangle":
      return s.height * s.width;
    case "circle":
      return Math.PI * s.radius ** 2;
    default:
      return assertNever(s); // error 类型“Triangle”的参数不能赋给类型“never”的参数
  }
}
```

## this

在 JavaScript 中，`this` 可以用来获取对全局对象、类实例对象、构建函数实例等的引用，在 TypeScript 中，`this` 也是一种类型

TypeScript 1.7+，编译器对有继承行为的类中 `this` 的类型有推断

对象的属性值可以是一个函数（也称为方法），在方法内如果访问`this`，`this` 的类型的规则有：

+ 如果该方法具有显式声明的此参数，则该参数具有该参数的类型。
  
  ``` typescript
  let info = {
    name: 'Tom',
    getName(this: { age: number }) {
      this; // 这里的this的类型是{ age: number }
    }
  };
  ```

+ 否则，如果该方法由具有此参数的签名进行上下文类型化，则该参数具有该参数的类型。

  ``` typescript
  let info = {
    name: 'Tom',
    getName () {
      return this.name // "Tom"
      // 这里this的类型为 { name: string; getName(): string; }
    }
  }
  ```

+ 否则，如果在 `tsconfig.json` 里将 `noImplicitThis` 设为 `true`，且包含的对象文字具有包含 `ThisType<T>` 的上下文类型，则其类型为 `T`。

  ``` typescript
  // 使用类型别名定义一个接口，这里用了泛型，两个泛型变量 D 和 M
  type ObjectDescriptor<D, M> = {
    data?: D; // 可选字段，类型为D
    // methods: 可选字段，类型为 M 和 ThisType<D & M> 组成的交叉类型；  
    // ThisType 是一个内置的接口，用来在对象字面量中键入 this
    // 这里指定this的类型为 D & M  
    methods?: M & ThisType<D & M>;  
  }

  // 参数desc的类型为 ObjectDescriptor<D, M>
  function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
    let data: object = desc.data || {};
    let methods: object = desc.methods || {};
    // 返回对象的类型是 D & M，因为同时包含 D 和 M 两个类型的字段  
    return { ...data, ...methods } as D & M;
  }

  let obj = makeObject({
    // data 的类型是 ObjectDescriptor<D, M> 类型中的 D
    data: { x: 0, y: 0 },
    // methods 的类型是 ObjectDescriptor<D, M> 类型中的 M
    methods: {
      moveBy(dx: number, dy: number) {
        // 这里的 this 是通过 ThisType<D & M> 指定的
        // this的类型就是 D & M
        this.x += dx;
        this.y += dy;
      }
    }
  });
  obj.x = 10;
  obj.y = 20;
  obj.moveBy(5, 5);
  ```

+ 否则，如果启用了 `--noImplicitThis` 并且包含的对象文字具有不包含 `ThisType<T>` 的上下文类型，则它具有上下文类型。

  使用了 `ThisType<T>` 的例子中，`ObjectDescriptor<D, M>` 类型中指定 `methods` 的类型中的 `& ThisType<D & M>` 去掉
  
  会发现 `moveBy` 方法中 `this.x` 和 `this.y` 报错，因为此时 `this` 的类型是 `methods` 这个对象字面量的类型。

+ 否则，`this` 的类型为 `any` 任何类型。

## 索引类型

### 索引类型查询操作符（keyof）

`keyof` 操作符，连接一个类型，会返回一个由这个类型的所有属性名组成的联合类型。支持用 `number` 和 `symbol` 命名的属性

通过和泛型结合使用，TypeScript 就可以检查使用了动态属性名的代码。

``` typescript
// 使用泛型，并且约束泛型变量 K 的类型是 "keyof T"
// 即：类型 T 的所有字段名组成的联合类型
function getValue<T, K extends keyof T>(obj: T, names: K[]): T[K][] {
  // 指定 getValue 的返回值类型为 T[K][]
  // 即：类型为 T 的值的属性值组成的数组
  return names.map(n => obj[n]);
}
const info = {
  name: "lison",
  age: 18
};
let values: string[] = getValue(info, ["name"]);
// error 不能将类型 “number[]” 分配给类型 “string[]”
values = getValue(info, ["age"]);
```

### 索引访问操作符

索引访问操作符 —— `[]`，与访问对象的某个属性值是一样的语法，但是在 TS 中它可以用来访问某个属性的类型。

当 `tsconfig.json` 里 `strictNullChecks` 设为 `false` 时，通过索引访问操作符和索引类型查询操作符可以选出类型不为 `never & undefined & null` 的类型。

``` typescript
// 接口的索引类型是 string 类型
// 实现该接口的对象的属性名可以设置为数值类型的值
// 因为数值最后会先转换为字符串
// 则 keyof Obj<number> 等同于类型 number | string：
interface Obj<T> {
  [key: string]: T;
}
let key: keyof Obj<number>; // keys的类型为number | string
key = 123; // right

// 使用访问操作符，获取索引签名的类型
interface Obj<T> {
  [key: string]: T;
}
const obj: Obj<number> = { age: 18 };
// value 的类型是 number，也就是 name 的属性值 18 的类型
let value: Obj<number>["age"];

interface Type {
  a: never;
  b: never;
  c: string;
  d: number;
  e: undefined;
  f: null;
  g: object;
}
// test的类型是 string | number | object
type test = Type[keyof Type];
```

## 映射类型

TypeScript 借助旧类型创建一个新类型的方式，就是映射类型，它可以用相同的形式去转换旧类型中的每个属性。TypeScript 2.9+，支持用 `number` 和 `symbol` 命名的属性

``` typescript
const stringIndex = "a";
const numberIndex = 1;
const symbolIndex = Symbol();
type Obj = {
  [stringIndex]: string;
  [numberIndex]: number;
  [symbolIndex]: symbol;
};
type keys = keyof Obj;
let key: keys = 2; // error
let key: keys = 1; // right
let key: keys = "b"; // error
let key: keys = "a"; // right
let key: keys = Symbol(); // error
let key: keys = symbolIndex; // right
```

### 基础

+ `Readonly<Type>`: 适用于将一个对象中的每一个属性转换为**只读**的场景
  
  ``` typescript
  type Readonly<T> = {
    readonly [P in keyof T]: T[P];
  }

  interface User {
    username: string
    id: number
    avatar: string
  }
  type ReadonlyUser = Readonly<User>
  // { readonly username: string; readonly id: number; readonly avatar: string; }
  ```

+ `Partial<Type>`: 适用于将一个对象中的每一个属性转换为**可选**的场景

  ``` typescript
  type Partial<T> = {
    [P in keyof T]?: T[P];
  }

  interface User {
    username: string
    id: number
    avatar: string
  }
  type PartialUser = Partial<User>
  // { username?: string; id?: number; avatar?: string; }
  ```

+ `Pick<Type, Keys>`: 返回一个对象中指定字段的值组成的对象

  ``` typescript
  type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  }

  interface User {
    username: string
    id: number
    avatar: string
  }
  type PickUser = Pick<User, "username" | "id">
  // { username: string; id: number; }
  ```

+ `Record<Keys, Type>`: 适用于将一个对象中的每一个属性转换为**其他值**的场景

  ``` typescript
  type Record<K extends string | number | symbol, T> = {
    [P in K]: T;
  }

  function mapObject<K extends string | number, T, U>(
    obj: Record<K, T>,
    f: (x: T) => U
  ): Record<K, U> {
    let res = {} as Record<K, U>;
    for (const key in obj) {
      res[key] = f(obj[key]);
    }
    return res;
  }
  const names = { 0: "hello", 1: "world", 2: "bye" };
  const lengths = mapObject(names, s => s.length);
  // { 0: 5, 1: 5, 2: 3 }
  ```

注意：

同态：两个相同类型的代数结构之间的结构保持映射。`Readonly`、`Partial` 和 `Pick` 是同态的，而 `Record` 不是，因为 `Record` 映射出的对象属性值是新的，和输入的值的属性值不同。

### 由映射类型进行推断

使用映射类型包装一个类型的属性后，也可以进行逆向操作，也就是拆包

``` typescript
// 定义映射类型，将一个属性拆分成get/set方法
type Proxy<T> = {
  get(): T;
  set(value: T): void;
};
// 定义映射类型
// 将一个对象的所有属性值类型都变为Proxy<T>处理之后的类型
type Proxify<T> = { [P in keyof T]: Proxy<T[P]> };
// 定义 proxify 函数
// 用来将对象中所有属性的属性值改为一个包含get和set方法的对象
function proxify<T>(obj: T): Proxify<T> {
  let result = {} as Proxify<T>;
  for (const key in obj) {
    result[key] = {
      get: () => obj[key],
      set: value => (obj[key] = value)
    };
  }
  return result;
}
let props = {
  name: "lison",
  age: 18
};
let proxyProps = proxify(props);
console.log(proxyProps.name.get()); // "lison"
proxyProps.name.set("li");

// 拆包函数
// 利用每个属性的get方法获取到当前属性值
// 然后将原本是包含get和set方法的对象改为这个属性值
function unproxify<T>(t: Proxify<T>): T {
  let result = {} as T;
  for (const k in t) {
    // 通过调用属性值这个对象的get方法获取到属性值
    // 然后赋给这个属性，替换掉这个对象
    result[k] = t[k].get();
  }
  return result;
}
let originalProps = unproxify(proxyProps);
```

### 增加或移除特定修饰符

使用 `+` 和 `-` 符号作为前缀来指定增加还是删除修饰符

``` typescript
interface Info { name: string; age: number; }
// 经过 ReadonlyInfo 创建的接口类型，属性是可选且只读的
type ReadonlyInfo<T> = { +readonly [P in keyof T]+?: T[P] };
// 等同于 type ReadonlyInfo = { readonly [P in keyof T]?: T[P] }
let info: ReadonlyInfo<Info> = { name: "lison" };
info.name = ""; // error：因为每个属性是只读额

type RemoveModifier<T> = { -readonly [P in keyof T]-?: T[p] };
// Readonly<Partial<Info>> 是返回一个既属性可选又只读的接口类型
// 所以 InfoType 类型则表示属性必含而且非只读。
type InfoType = RemoveModifier<Readonly<Partial<Info>>>;
let info1: InfoType = { name: "lison" }; // error missing "age"
let info2: InfoType = { name: "lison", age: 18 };
info2.name = ""; // right, can edit
```

### 元组和数组上的映射类型

在元组和数组上的映射类型会生成新的元组和数组，并不会创建一个新的类型，这个类型上会具有 `push`、`pop` 等数组方法和数组属性。

``` typescript
// MapToPromise 返回一个将传入的类型的所有字段的值转为 Promise，
// 且 Promise 的 resolve 回调函数的参数类型为这个字段类型
type MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };
type Tuple = [number, string, boolean];
type promiseTuple = MapToPromise<Tuple>;
// 当指定变量 tuple 的类型为 promiseTuple 后，
// 它的三个元素类型都是一个Promise，
// 且 resolve 的参数类型依次为 number、string 和 boolean。
let tuple: promiseTuple = [
  new Promise((resolve, reject) => resolve(1)),
  new Promise((resolve, reject) => resolve("a")),
  new Promise((resolve, reject) => resolve(false))
];
```

## 条件类型

以一个条件表达式进行类型关系检测，然后在后面两种类型中选择一个。

``` typescript
// 如果 T 可以赋值给 U 类型，则是 X 类型，否则是 Y 类型。
T extends U ? X : Y
```

### 分布式条件类型

当待检测的类型是联合类型，则该条件类型被称为“分布式条件类型”，在实例化时会自动分发成联合类型

``` typescript
// 条件类型的作用：找出从 T 中出去 U 中存在的类型，得到剩下的类型
type Diff<T, U> = T extends U ? never : T;
type Test = Diff<string | number | boolean, undefined | number>;
// Test的类型为 string | boolean


// [K in keyof T] 用于遍历 T 的所有属性名
// 如果属性值为 Function 类型，则值为属性名字面量类型，否则为 never 类型
// 使用 keyof T 获取 T 的属性名
// 通过索引访问类型 [keyof T] 获取不为 never 的类型
type Type<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
interface Part {
  id: number;
  name: string;
  subparts: Part[];
  updatePart(newName: string): void;
}
type Test = Type<Part>; // Test的类型为"updatePart"
```

### 条件类型的类型推断（infer）

如果传入的类型是一个数组，则返回它元素的类型；如果是一个普通类型，则直接返回这个类型。

``` typescript
// 需要通过索引访问类型 T[number] 来获取类型的
type Type<T> = T extends any[] ? T[number] : T;
type test = Type<string[]>; // test的类型为string
type test2 = Type<string>; // test2的类型为string

// 使用 infer 关键字则无需手动获取
// infer 能够推断出 U 的类型，并且供后面使用
// 可以理解为定义了一个变量 U 来接收数组元素的类型
type Type<T> = T extends Array<infer U> ? U : T;
type test = Type<string[]>; // test的类型为string
type test2 = Type<string>; // test2的类型为string
```

### TS 预定义条件类型

+ `Exclude<Type, ExcludedUnion>`: 从 Type 中去掉可以赋值给 ExcludedUnion 的类型

  ``` typescript
  type Exclude<T, U> = T extends U ? never : T;

  type Type = Exclude<"a" | "b" | "c", "a" | "b">;
  // Type => 'c'
  type Type2 = Exclude<string | number | boolean, string | number>;
  // Type2 => boolean
  ```

+ `Extract<Type, Union>`: 选取 Type 中可以赋值给 Union 的类型

  ``` typescript
  type Extract<T, U> = T extends U ? T : never;

  type Type = Extract<"a" | "b" | "c", "a" | "c" | "f">;
  // Type => 'a' | 'c'
  type Type2 = Extract<number | string | boolean, string | boolean>;
  // Type2 => string | boolean
  ```

+ `NonNullable<Type>`: 从 Type 中去掉 `null` 和 `undefined`

  ``` typescript
  type NonNullable<T> = T extends null | undefined ? never : T;

  type Type = NonNullable<string | number | undefined | null>;
  // Type => string | number
  ```

+ `ReturnType<Type>`: 获取函数类型返回值类型

  ``` typescript
  type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

  type Type = ReturnType<() => string>;
  // Type => string
  type Type2 = ReturnType<(arg: number) => void)>
  // Type2 => void
  ```

+ `InstanceType<Type>`: 获取构造函数类型的实例类型

  InstanceType 条件类型要求泛型变量 T 类型是创建实例为 any 类型的构造函数，而它本身则通过判断 T 是否是构造函数类型来确定返回的类型。如果是构造函数，使用 infer 可以自动推断出 R 的类型，即实例类型；否则返回的是 any 类型。

  ``` typescript
  type InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;

  class A {
    constructor() {}
  }
  // T1 的定义中，typeof A返回的的是类 A 的类型，也就是 A
  // 不能使用 A 因为它是值不是类型，类型 A 是构造函数
  // 所以 T1 是 A 构造函数的实例类型，也就是 A
  type T1 = InstanceType<typeof A>; // T1的类型为 A
  // T2 传入的类型为 any，因为 any 是任何类型的子类型
  // 所以它满足 T extends new (…args: any[]) => infer R，这里 infer 推断的 R 为 any
  type T2 = InstanceType<any>; // T2的类型为 any
  // 传入 never 和 any 同理。
  // 传入 string 时因为 string 不能不给构造函数类型，所以报错。
  type T3 = InstanceType<never>; // T3的类型为 never
  type T4 = InstanceType<string>; // error
  ```

## 装饰器

### 基础

+ 装饰器定义

  装饰器能够作用于类声明、方法、访问符、属性和参数上。使用 `@` 符号加一个名字来定义，如 @decorat，decorat 必须是一个函数或者求值后是一个函数。函数在运行的时候被调用，被装饰的声明作为参数会自动传入。

  注意：装饰器要紧挨着要修饰的内容的前面，而且所有的装饰器不能用在声明文件(.d.ts)中，和任何外部上下文中。

+ 装饰器工厂

  装饰器工厂是一个函数，它的返回值是一个函数，返回的函数作为装饰器的调用函数。如果使用装饰器工厂，那么在使用的时候，就要加上函数调用。

+ 装饰器组合

  装饰器可以组合，也就是对于同一个目标，引用多个装饰器。

  多个装饰器的执行顺序：
  + 装饰器工厂从上到下依次执行，但是只是用于返回函数但不调用函数；
  + 装饰器函数从下到上依次执行，也就是执行工厂函数返回的函数。

  ``` typescript
  function setName () {
    console.log('get setName')
    return function (target) {
      console.log('setName')
    }
  }
  function setAge () {
    console.log('get setAge')
    return function (target) {
      console.log('setAge')
    }
  }
  @setName()
  @setAge()
  class Test {}
  // 打印出来的内容如下：
  // 'get setName -> get setAge -> setAge -> setName
  ```

+ 装饰器求值

  类的定义中,不同声明上的装饰器将按以下规定的顺序引用：
  + 参数装饰器，方法装饰器，访问符装饰器或属性装饰器应用到每个实例成员；
  + 参数装饰器，方法装饰器，访问符装饰器或属性装饰器应用到每个静态成员；
  + 参数装饰器应用到构造函数；
  + 类装饰器应用到类。

### 类装饰器

类装饰器在类声明之前声明，类装饰器应用于类的声明。

类装饰器表达式会在运行时当做函数被调用，它有唯一一个参数，就是装饰的这个类。

通过装饰器，可以修改类的原型对象和构造函数。

``` typescript
// 装饰器，返回一个类，这个类继承要修饰的类
// 所以最后创建的实例不仅包含原 Greeter 类中定义的实例属性，还包含装饰器中定义的实例属性。
// 在装饰器里给实例添加的属性，设置的属性值会覆盖被修饰的类里定义的实例属性
// 所以创建实例的时候虽然传入了字符串，但是 hello 还是装饰器里设置的"override"。
function classDecorator<T extends { new (...args: any[]): {} }>(target: T) {
  return class extends target {
    newProperty = "new property";
    hello = "override";
  };
}
@classDecorator
class Greeter {
  property = "property";
  hello: string;
  constructor(m: string) {
    this.hello = m;
  }
}
console.log(new Greeter("world"));
/*
{
  hello: "override"
  newProperty: "new property"
  property: "property"
}
*/
```

### 方法装饰器

方法装饰器用来处理类中方法，它可以处理方法的属性描述符，可以处理方法定义。方法装饰器在运行时也是被当做函数调用，含 3 个参数：

+ 装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；
+ 成员的名字；
+ 成员的属性描述符。

  对象可以设置属性，如果属性值是函数，那这个函数称为方法。每一个属性和方法在定义的时候，都伴随三个属性描述符 `configurable`、 `writable` 和 `enumerable`，分别用来描述这个属性的可配置性、可写性和可枚举性。这三个描述符，需要使用 ES5 的 `Object.defineProperty` 方法来设置。

  + `writable`: 设置为 false 时，为无法修改它起初定义的属性值的
  + `enumerable`: 设置为 false 时，为不可枚举的，就遍历不到了
  + `configurable`: 设置为 false 时，为无法通过 `Object.defineProperty` 修改该属性的三个描述符的值了，所以这是个不可逆的设置

如果方法装饰器返回一个值，那么会用这个值作为方法的属性描述符对象。

``` typescript
// 在方法装饰器中返回一个对象
// 对象中包含 value 用来修改方法，enumerable 用来设置可枚举性。
function enumerable(bool: boolean): any {
  return function(
    target: any,
    propertyName: string,
    descriptor: PropertyDescriptor
  ) {
    return {
      value: function() {
        return "not age";
      },
      enumerable: bool
    };
  };
}
class Info {
  constructor(public age: number) {}
  @enumerable(false)
  getAge() {
    return this.age;
  }
}
const info = new Info();
console.log(info.getAge()); // "not age"
```

### 访问器装饰器

访问器也就是 `set` 和 `get` 方法，一个在设置属性值的时候触发，一个在获取属性值的时候触发。

TypeScript 不允许同时装饰一个成员的 `get` 和 `set` 访问器，只需要这个成员 `get` / `set` 访问器中定义在前面的一个即可。

访问器装饰器也有三个参数，和方法装饰器是一样。如果访问器装饰器有返回值，这个值会被作为属性的属性描述符。

+ 装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；
+ 成员的名字；
+ 成员的属性描述符。

``` typescript
function enumerable(bool: boolean) {
  return function(
    target: any,
    propertyName: string,
    descriptor: PropertyDescriptor
  ) {
    descriptor.enumerable = bool;
  };
}
class Info {
  private _name: string;
  constructor(name: string) {
    this._name = name;
  }
  @enumerable(false)
  get name() {
    return this._name;
  }
  @enumerable(false) // error 不能向多个同名的 get/set 访问器应用修饰器
  set name(name) {
    this._name = name;
  }
}
```

### 属性装饰器

属性装饰器声明在属性声明之前，它有 2 个参数：

+ 装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；
+ 成员的名字。

属性装饰器没法操作属性的属性描述符，它只能用来判断某各类中是否声明了某个名字的属性。

``` typescript
function printPropertyName(target: any, propertyName: string) {
  console.log(propertyName);
}
class Info {
  @printPropertyName
  name: string;
  @printPropertyName
  age: number;
}
```

### 参数装饰器

参数装饰器有 3 个参数：

+ 装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；
+ 成员的名字；
+ 参数在函数参数列表中的索引。

``` typescript
function required(target: any, propertName: string, index: number) {
  console.log(`修饰的是${propertName}的第${index + 1}个参数`);
}
class Info {
  name: string = "lison";
  age: number = 18;
  getInfo(prefix: string, @required infoType: string): any {
    return prefix + " " + this[infoType];
  }
}
interface Info {
  [key: string]: string | number | Function;
}
const info = new Info();
info.getInfo("hihi", "age"); // 修饰的是getInfo的第2个参数
```

## 使用模块封装代码

### export

`export` 能够导出声明、变量、函数、类，还包括 TypeScript 特有的类型别名和接口。

``` typescript
// funcInterface.ts
export interface Func {
  (arg: number): string;
}
export class C {
  constructor() {}
}
class B {}
export { B };
export { B as ClassB };

// main.ts
export * from "./moduleB";
// main.ts
export { name } from "./moduleB";
// main.ts
export { name as nameProp } from "./moduleB";
```

### import

使用 `import` 引入模块

``` typescript
// main.ts
import { name } from "./moduleB";
// main.ts
import * as info from "./moduleB";
// main.ts
import { name as nameProp } from "./moduleB";
// 使用 import 直接接模块名或文件路径，进行具有副作用的导入
import "./set-title.ts";
```

### export default

``` typescript
// 在 TypeScript 中使用 export default 默认导出
// moduleB.ts
export default "lison";
// main.ts
import name from "./moduleB.ts";
console.log(name); // 'lison'
```

### export = 和 import = require()

TypeScript 为了兼容 CommonJS 和 AMD 两种模块系统语法，使得编译后的声明文件同时支持这两种模块系统，增加了 `export =` 和 `import xx = require()` 两个语句。

使用 `export =` 导出的模块，必须使用 `import xx = require()` 来引入

``` typescript
// moduleC.ts
class C {}
export = C;

// 如果模块不需要同时支持这两种模块系统，可以不使用 export = 来导出内容
// main.ts
import ClassC = require("./moduleC");
const c = new ClassC();
```

### 相对和非相对模块导入

根据引入模块的路径是相对还是非相对，模块的导入会以不同的方式解析。

+ 相对导入
  
  相对导入是以 `./`（当前目录） 或 `../`（当前目录的上一级目录） 开头的。

  模块解析策略：

  ``` typescript
  import moduleA from "../module/moduleA";
  ```

  + 编译器在解析模块引用的时候，如果遇到**省略后缀**的情况，会依次查找以该名称为文件名的`.ts`、`.tsx`、`.d.ts`文件。
  + 如果没找到，会在当前文件夹下的 package.json 文件里查找 types 字段指定的模块路径，然后通过这个路径去查找模块
  + 如果没找到 package.json 文件或者 types 字段，则会将 moduleA 当做文件夹去查找，如果它确实是文件夹，将会在这个文件夹下依次查找 `index.ts`、`index.tsx`、`index.d.ts`。
  + 如果还没找到，会在上面例子中 module 文件夹的上级文件夹继续查找，查找规则和前面这些顺序一致。

+ 非相对导入
  
  除了 `./` 或 `../` 开头的路径，都被当做非相对路径。非相对模块的导入可以相对于 baseUrl，也可以通过路径映射，还可以解析为外部模块。

## 使用命名空间封装代码

命名空间与模块的区别：

+ 当在程序内部用于防止全局污染，把相关的内容都放在一起的时候，使用命名空间
+ 当封装了一个工具或者库，要适用于模块系统中引入使用时，适合使用模块。

### 定义和使用

命名空间的定义实际相当于定义了一个大的对象，里面可以定义变量、接口、类、方法等等，但是如果不使用 `export` 关键字指定此内容要对外可见的话，外部是没法访问到的。

命名空间如果不是使用 webpack 等工具编译，而是使用 tsc 编译，那只需要在使用外部命名空间的地方使用 `/// <reference path=“namespace.ts”/>` 来引入，注意三斜线 ”///“ 开头，然后在 path 属性指定相对于当前文件，这个命名空间文件的路径。编译时，需要指定一个参数 outFile（–outFile 用来指定输出的文件路径和文件名，最后指定要编译的文件）。

注意：使用 outFile 只支持amd和system两种模块标准，所以需要在tsconfig.json里，设置 module 编译选项。

``` typescript
// Validation.ts
namespace Validation {
  const isLetterReg = /^[A-Za-z]+$/; // 定义正则
  // 定义正则，与 isLetterReg 的区别在于使用 export 导出了
  export const isNumberReg = /^[0-9]+$/;
  export const checkLetter = (text: any) => {
    return isLetterReg.test(text);
  };
}

// index.ts
// 命名空间在引入的时候，使用 tsc 命令行编译文件，命名空间的引入如下：
/// <reference path="validation.ts"/>
let isLetter = Validation.checkLetter("sdfsd");
const reg = Validation.isNumberReg;
console.log(isLetter);
console.log(reg);

// 使用 tsc 命令行编译后的 js 文件
var Validation;
(function(Validation) {
  var isLetterReg = /^[A-Za-z]+$/;
  Validation.isNumberReg = /^[0-9]+$/;
  Validation.checkLetter = function(text) {
    return isLetterReg.test(text);
  };
})(Validation || (Validation = {}));
/// <reference path="namespace.ts"/>
var isLetter = Validation.checkLetter("sdfsd");
var reg = Validation.isNumberReg;
console.log(isLetter);
console.log(reg);

// 在项目中时时使用，需要使用 export 将命名空间导出
// 其实就是作为模块导出，然后在 index.ts 中引入
// 注意：命名空间本来就是防止变量污染，但是模块也可以。这种情况应该使用模块

// Validation.ts
export namespace Validation {
  const isLetterReg = /^[A-Za-z]+$/;
  export const isNumberReg = /^[0-9]+$/;
  export const checkLetter = (text: any) => {
    return isLetterReg.test(text);
  };
}

// index.ts
import { Validation } from "./Validation.ts";
let isLetter = Validation.checkLetter("sdfsd");
const reg = Validation.isNumberReg;
console.log(isLetter); // true
console.log(reg); // /^[0-9]+$/
```

### 拆分为多个文件

随着内容不断增多，可以将同一个命名空间拆成多个文件分开维护，但仍然是同一个命名空间。

使用 `reference` 引入的命名空间都会被编译在一个文件，而且是按照引入的顺序编译的。

``` typescript
// Validation.ts
namespace Validation {
  const isLetterReg = /^[A-Za-z]+$/;
  export const isNumberReg = /^[0-9]+$/;
  export const checkLetter = (text: any) => {
    return isLetterReg.test(text);
  };
}

// 将 Validation.ts 拆开成 LetterValidation.ts 和 NumberValidation.ts

// LetterValidation.ts
namespace Validation {
  export const isLetterReg = /^[A-Za-z]+$/;
  export const checkLetter = (text: any) => {
    return isLetterReg.test(text);
  };
}
// NumberValidation.ts
namespace Validation {
  export const isNumberReg = /^[0-9]+$/;
  export const checkNumber = (text: any) => {
    return isNumberReg.test(text);
  };
}
// index.ts
/// <reference path="./LetterValidation.js"/>
/// <reference path="./NumberValidation.js"/>
let isLetter = Validation.checkLetter("sdfsd");
const reg = Validation.isNumberReg;
console.log(isLetter); // true
```

### 别名

可以使用 `import` 给常用的对象起一个别名。

注意，这个别名和类型别名不是一回事，而且这儿的 import 也只是为了创建别名不是引入模块。

使用 `import` 关键字来定义命名空间中某个输出元素的别名，可以减少我们深层次获取属性的成本。

``` typescript
namespace Shapes {
  export namespace Polygons {
    export class Triangle {}
    export class Squaire {}
  }
}
// 使用 import 关键字给 Shapes.Polygons 取一个别名 polygons
import polygons = Shapes.Polygons;
let sq = new polygons.Square();
```

## 声明合并

声明合并：将名字相同的多个声明合并为一个声明，合并后的声明同时拥有多个声明的特性。

TypeScript的所有声明概括起来，会创建这三种实体之一：

+ 命名空间: 创建一个对象，对象的属性是在命名空间里 export 导出的内容
+ 类型: 创建一个类型并赋给一个名字
+ 值: 创建一个在 JavaScript 中可以使用的值

| 声明类型            | 创建了命名空间 | 创建了类型 | 创建了值 |
| :------------------ | :------------: | :--------: | :------: |
| Namespace           |       √        |            |    √     |
| Class               |                |     √      |    √     |
| Enum                |                |     √      |    √     |
| Interface           |                |     √      |          |
| Type Alias 类型别名 |                |     √      |          |
| Function            |                |            |    √     |
| Variable            |                |            |    √     |

注意：`Variable` 是变量，不是常量，常量是可以作为类型使用的。

### 合并接口

多个同名接口，定义的非函数的成员命名应该是不重复的，如果重复了，类型应该是相同的，否则将会报错。

``` typescript
interface Info { name: string }
interface Info { age: number }
// error 后续属性声明必须属于同一类型。
// 属性“age”的类型必须为“number”，但此处却为类型“boolean”
interface Info { age: boolean }
```

对于函数成员，每个同名函数成员都会被当成这个函数的重载，且合并时后面的接口具有更高的优先级。

``` typescript
interface Res {
  getRes(input: string): number
}
interface Res {
  getRes(input: number): string
}
const res: Res = {
  getRes: (input: any): any => {
    if (typeof input === 'string') return input.length
    else return String(input)
  }
}
// error 类型“number”上不存在属性“length”
res.getRes('123').length
```

### 合并命名空间

同名命名空间最后会将多个命名空间导出的内容进行合并

``` typescript
namespace Validation {
  export const checkNumber = () => {}
}
namespace Validation {
  export const checkString = () => {}
}

// 等同于
namespace Validation {
  export const checkNumber = () => {}
  export const checkString = () => {}
}
```

在命名空间里，有时并不是把所有内容都对外部可见，对于没有导出的内容，在其它同名命名空间内是无法访问的

``` typescript
namespace Validation {
  const numberReg = /^[0-9]+$/
  export const stringReg = /^[A-Za-z]+$/
  export const checkString = () => {}
}
namespace Validation {
  export const checkNumber = (value: any) => {
    // error 找不到名称“numberReg”
    // numberReg没有使用 export 导出，所以在此同名命名空间内是无法使用的
    return numberReg.test(value)
  }
}
```

### 不同类型合并

+ 命名空间和类

  要求同名的类和命名空间在定义的时候，类的定义必须在命名空间前面，最后合并之后的效果，一个包含一些以命名空间导出内容为静态属性的类

  ``` typescript
  class Validation { checkType() {} }
  namespace Validation {
    export const numberReg = /^[0-9]+$/
    export const stringReg = /^[A-Za-z]+$/
    export const checkString = () => { }
  }
  namespace Validation {
    export const checkNumber = (value: any) => {
      return numberReg.test(value)
    }
  }
  console.log(Validation.prototype)
  // { checkType: fun () {} }
  console.log(Validation.prototype.constructor)
  /* {
    checkNumber: ...
    checkString: ...
    numberReg: ...
    stringReg: ...
  } */
  ```

+ 命名空间和函数

  在JavaScript中，函数也是对象，所以可以给一个函数设置属性，在TypeScript中，可以通过声明合并实现。要求函数的定义要在同名命名空间前面

  ``` typescript
  function countUp () {
    countUp.count++
  }
  namespace countUp {
    export let count = 0
  }
  countUp()
  countUp()
  console.log(countUp.count) // 2
  ```

+ 命名空间和枚举

  通过命名空间和枚举的合并，为枚举拓展内容，枚举和同名命名空间的先后顺序没有要求

  ``` typescript
  enum Colors { red, green, blue }
  namespace Colors {
    export const yellow = 3
  }
  console.log(Colors)
  /*
  {
    0: "red",
    1: "green",
    2: "blue",
    red: 0,
    green: 1,
    blue: 2,
    yellow: 3
  }
  */
  ```

## 混入

混入即把两个对象或者类的内容，混合起来，从而实现一些功能的复用。

``` typescript
class ClassAa {
  isA: boolean;
  funcA() {}
}
class ClassBb {
  isB: boolean;
  funcB() {}
}
// 定义一个类类型接口 AB
// 让类 AB 继承 ClassAa 和 ClassBb 的类型
// 所以使用 implements 关键字，而不是用 extends
// 类 AB 会同时拥有类 A 和 B 的类型定义，还有自身定义的一些类型和值。
class AB implements ClassAa, ClassBb {
  constructor() {}
  // 定义两个实例属性
  isA: boolean = false;
  isB: boolean = false;
  // 定义两个方法，并指定类型
  funcA: () => void;
  funcB: () => void;
}
// mixins 直接传入类，而非其原型对象
// base是最后要汇总而成的类
// from是数组，是要混入的源类组成的数组
function mixins(base: any, from: any[]) {
  from.forEach(fromItem => {
    // Object.getOwnPropertyNames方法获取一个对象自身的属性，
    // 这里自身指除去继承的属性，获取到属性后将属性赋值给目标对象。
    Object.getOwnPropertyNames(fromItem.prototype).forEach(key => {
      base.prototype[key] = fromItem.prototype[key];
    });
  });
}
mixins(AB, [ClassAa, ClassBb]);
const ab = new AB();
console.log(ab);
/*
{
  isA: false,
  isB: false,
  __proto__: {
    funcA: f ()
    funcB: f ()
    constructor: f
  }
}
*/
```

## Promise

``` typescript
// 定义接口，用来定义接口返回结果的结构
interface Res {
  data: {
    [key: string]: any;
  };
}
// 定义命名空间，用来模拟 axios 实现接口调用
namespace axios {
  // 函数返回类型使用TS内置的条件类型 Promise<T> 来指定返回类型
  // T 的类型就是在 resolve 回调函数中返回的值的类型
  export function post(url: string, config: object): Promise<Res> {
    // 返回值类型是一个Promise，resolve传的参数的类型是Res
    // 然后返回一个Promise
    return new Promise((resolve, reject) => {
      setTimeout(() => { // 通过setTimeout实现异步效果
        let res: Res = { data: {} };
        // 通过简单判断，来模拟调用不同接口返回不同数据的效果
        if (url === "/login") res.data.user_id = 111;
        else res.data.role = "admin";
        console.log(2);
        resolve(res); // 在这里传入res结果
      }, 1000);
    });
  }
}
interface Info {
  user_name: string;
  password: string;
}
// 使用async关键字修饰这个函数，内部就可以包含异步逻辑了
async function loginReq({ user_name, password }: Info) {
  try {
    console.log(1);
    // 调用 /login 接口
    const res = await axios.post("/login", { data: { user_name, password } });
    console.log(3);
    return res;
  } catch (error) {
    throw new Error(error);
  }
}
async function getRoleReq(user_id: number) {
  try {
    const res = await axios.post("/user_roles", { data: { user_id } });
    return res;
  } catch (error) {
    throw new Error(error);
  }
}
loginReq({ user_name: "lison", password: "123" }).then(res => {
  const { data: { user_id } } = res;
  getRoleReq(user_id).then(res => {
    const { data: { role } } = res;
    console.log(role);
  });
});
```
