# TypeScript基础

## 类型

### 基础类型

``` typescript
// 布尔值 - true / false
let bool: boolean = false;

// 数字 - 支持二、八、十、十六进制的数值
let num: number = 6;

// 字符串 - 单引号/双引号/模板字符串包裹的内容、字符串字面量类型
let str1: string = "Bob";
str1 = 'Tom'
// 字符串字面量类型，即把一个字符串字面量作为一种类型
// 当把一个变量指定为字符串类型的时候，就不能再赋值为其他字符串值
let str2:'Bob'
str2 = 'Jerry' // error 不能将类型 "Jerry"，分配给类型 "Bob"

// 数组
// 格式: type[] 或 Array<type> - type为元素类型
// 设置元素类型均为 number 类型的数组类型，如下所示：
let arr1: number[] = [1, 2, 3]; // type[] 格式 - 推荐使用格式
let arr2: Array<number> = [1, 2, 3]; // Array<type> 格式
// 指定数组里的元素既可以是数值也是字符串，如下所示：
let arr3: number|string[] = [1, 'str'];

// Object
// 希望一个变量或者函数的参数的类型是一个对象时，使用此类型
let obj: object
obj = { name: 'Tom' }
// 问题一: 访问对象中的某个属性，会报错，提示类型 object 上没有这个属性
obj.name // error: 类型 object 上不存在属性 name
// 问题一解决方法：可以使用接口（interface）
interface User {
  name: string;
}
let obj: User = { name: 'Tom' }
// 问题二: 当定义一个函数，参数必须为对象，此时需要用到 object 类型，
function getValue(obj: object, key: string) {
  return obj[key]; // error
}
getValue(obj, 'name')
// 问题二解决方法：使用泛型
function getValue<T extends object, U extends keyof T>(obj: T, key: U) {
  return obj[key];
}

// null 和 undefined
// 默认情况下， undefined 和 null 可以赋值给任意类型的值
// 在 tsconfig.json 的"compilerOptions"里设置了"strictNullChecks": true时，
// >>> undefined 和 null 将只能赋值给它们自身和 void 类型
let u: undefined = undefined;
let n: null = null;

// Symbol：表示独一无二的值，通过 Symbol 函数生成。
// 注意：使用 Symbol 的时候，必须添加 es6 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom"]
let sym1 = Symbol('key');

// BigInt：可以安全地存储和操作大整数。（即超出 Number 能够表示的安全整数范围）
// 使用 BigInt(number) 把 Number 转换为 BigInt
// 如果类型是 BigInt，那么数字后面需要加 n。
// eg: const max1 = max + 1n
// 注意：使用 BigInt 的时候，必须添加 ESNext 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom", "ESNext"]
// declare 定义的类型只会用于编译时的检查，编译结果中会被删除。
declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.
```

### 补充类型

``` typescript
// 元组（Tuple）
// 表示一个已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型。
// TypeScript 2.6+ 要求元组赋值必须类型和个数都对应。
let tuple: [string, number] = ['hello', 10];
// TypeScript 2.6+ [string, number]元组类型的声明效果上可以看做等同于下面的声明：
interface Tuple extends Array<number | string> {
  0: string;
  1: number;
  length: 2;
}

// 枚举（enum）
// 默认情况下，从 0 开始为元素编号
enum Color { Red, Green, Blue };
let c: Color = Color.Green; // 1
console.log(Color[1]) // 'Green'
// 也可以为每个值都赋予不同的、不按顺序排列的值
enum Color { Red = 1, Green = 2, Blue = 4 }
let c: Color = Color.Green; // 2

// Any
// 在编程阶段，不清楚为一个变量指定什么类型，则需要用到 Any 类型
let notSure: any = 4;
notSure = 'maybe a string instead';
// 使用 any 来指定数组中元素类型为任意类型
let list: any[] = [1, true, 'free'];

// void
// 表示没有任何类型。
// 使用场景：当一个函数没有返回值时，通常返回值类型是 void。
// 声明一个 void 类型的变量，只能赋予 undefined 和 null
function warnUser(): void {
  console.log('This is my warning message');
}

// never
// 永不存在的值的类型。使用场景有：
// >>> 1.抛出异常的返回值类型
// >>> 2.根本不会有返回值的函数表达式 或 箭头函数表达式的返回值类型
// >>> 3.变量被用不为真的类型保护所约束时
// never 是任何类型的子类型，可以赋值给任何类型。
// 没有任何类型是 never 的子类型或可以赋值给 never 类型（除了never本身之外）。
// any 也不可以赋值给 never。
// 示例一：抛出异常场景
const errorFunc = (message: string): never => {
  throw new Error(message); // 抛出异常
}
// 示例二：根本不会有返回值的函数，需要区分在定义函数时没有给返回值的情况
const infiniteFunc = (): never => {
  while (true) {}
}
// 示例三：
// 右边的函数体内是一个死循环，所以此函数调用后的返回值类型为 never
// 当给 neverVariable 赋值就会报错
let neverVariable = (() => { while (true) {}; })();
neverVariable = 123; // error 不能将类型"number"分配给类型"never"

// unknown
// 表示未知类型，相对于 any 是安全的。
// 当指定值为 unknown 类型的时候，如果没有通过基于控制流的类型断言来缩小范围的话，是不能对它进行任何操作的。
// 当指定值为 any 类型的时候，可以随意对它进行操作
let value: unknown;
value.foo.bar; // ERROR
value(); // Error

// 交叉类型：取多个类型的并集。使用 & 符号，被 & 符链接的多个类型构成一个交叉类型。
const merge = <T, U>(arg1: T, arg2: U): T & U => {
  let res = <T & U>{}; // 指定返回值的类型兼备T和U两个类型变量代表的类型的特点
  res = Object.assign(arg1, arg2); // 使用Object.assign方法，返回一个合并后的对象；
  return res;
};

// 联合类型：使用 | 符号，只要符合联合类型中的任何一种类型即可
const getLength = (content: string | number): number => {
  if (typeof content === "string") return content.length;
  else return content.toString().length;
};
```

### 枚举类型

枚举使用 `enum` 关键字定义，支持数字和字符串枚举。

+ 数字枚举
  
  枚举默认为数字类型，从 0 开始一次累加。

  数字枚举在定义的时候，可以使用计算值和常量。如果某个字段使用了计算值或常量，那么该字段后面紧接着的字段必须设置初始值，不能使用默认的递增值。

  ``` typescript
  // 指定部分字段，其他使用默认递增索引
  enum Status {
    Ok = 200,
    Created, // 201
    Accepted, // 202
    BadRequest = 400,
    Unauthorized // 401
  }

  const Start = 1;
  enum Index {
    a = Start,
    b, // error 枚举成员必须具有初始化的值
    c
  }
  ```

+ 反向映射

  定义一个枚举值的时候，可以通过 `Enum['key']` 或者 `Enum.key` 的形式获取对应的值 value。**TypeScript 支持反向映射，但是只支持数字枚举**。

  ``` typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    Error = 500
  }
  console.log(Status["Success"]); // 200
  console.log(Status[200]); // 'Success'
  console.log(Status[Status["Success"]]); // 'Success'

  // 编译为 JavaScript 为
  var Status;
  (function (Status) {
    Status[Status["Success"] = 200] = "Success";
    Status[Status["NotFound"] = 404] = "NotFound";
    Status[Status["Error"] = 500] = "Error";
  })(Status || (Status = {}));
  ```

+ 字符串枚举
  
  字符串枚举值要求每个字段的值都必须是**字符串字面量**，或者是**该枚举值中另一个字符串枚举成员**。

  枚举值中可以使用其他枚举成员。**其他枚举成员指的是同一个枚举值中的枚举成员**，因为字符串枚举不能使用常量或者计算值，所以不能使用其他枚举值中的成员。

  ``` typescript
  enum Message {
    Error = "Sorry, error",
    Success = "Hoho, success"
  }

  enum Message {
    Error = "error message",
    ServerError = Error,
    ClientError = Error
  }
  console.log(Message.Error); // 'error message'
  console.log(Message.ServerError); // 'error message'
  ```

+ 异构枚举
  
  异构枚举就是枚举值中既有数字类型又有字符串类型。**不建议使用**，因为枚举值的特点往往是相似的。

  ``` typescript
  enum Result {
    Faild = 0,
    Success = "Success"
  }
  ```

+ 枚举成员类型和联合枚举类型

  如果枚举值里**所有成员的值都是字面量类型的值**，那么这个枚举的每个成员和枚举值本身都可作为类型来使用。满足条件的枚举成员的值有：
  + 不带初始值的枚举成员: `enum E { A }`
  + 值为字符串字面量: `enum E { A = 'a' }`
  + 值为数值字面量，或者带 `-` 符号的数值字面量：`enum E { A = 1 }`、`enum E { A = -1 }`

  1. 枚举成员类型

     ``` typescript
      enum Animal {
        Dog = 1,
        Cat = 2
      }
      interface Dog {
        type: Animal.Dog; // 这里使用Animal.Dog作为类型，指定接口Dog的必须有一个type字段，且类型为Animal.Dog
      }
      let dog: Dog = {
        type: Animal.Dog
      };
      ```

  2. 联合枚举类型

    ``` typescript
    enum Status {
      Off,
      On
    }
    interface Light {
      status: Status;
    }
    const light1: Light = {
      status: Status.Off
    };
    ```

+ const enum

  如果使用枚举只是为了让程序可读性好，而不需要编译后的对象，则可以使用 `const enum`（完全嵌入的枚举），在代码编译后不会创建这个对象，只会从枚举里拿到相应的值进行替换。

  ``` typescript
  const enum Animal {
    Dog,
    Cat
  }
  const animal = Animal.Dog;
  ```

### 类型断言

类型断言，把某个值强行指定为特定类型。主要形式有:

+ `<type>value` 形式: 这种形式在JSX代码中不可以使用，而且也是TSLint不建议的写法
+ `value as type` 形式: 推荐写法

TypeScript 有时不如我们了解一个值的类型，这时希望 TypeScript 进行类型检查，而是交给我们自己进行处理，则需要用到类型断言。

``` typescript
const getStrLength = (target: string | number): number => {
  // 当 TypeScript 不确定一个联合类型的变量是哪个类型的时候
  // 而此时只能访问此联合类型的所有类型里共有的属性或方法
  // 所以需要用到了类型断言进行判断
  if ((<string>target).length) {
    return (target as string).length;
  } else {
    return target.toString().length;
  }
};
```

## 接口（interface）

使用interface来定义接口。

在定义接口的时候，`{}` 括号包裹的是一个代码块，是声明类型的语句。使用冒号指定类型，每条声明之间使用换行分隔，也可以使用分号或逗号。

``` javascript
interface Say {
  (words: string) : string
}

interface User {
  name: string
  age?: number // 可选属性
  readonly isMale: boolean // 只读属性
  say: (words: string) => string // 函数类型描述方法一：在 interface 内部描述函数
  // say: Say // 函数类型描述方法二：先用接口直接描述函数类型，然后再 User 内使用
}
const getUserName = (user: User) => user.name
```

### 多余属性检查

对于多余属性检查，定义的变量比接口少了一些或者多了一些属性是不允许的。

绕开多余属性检查的方法如下：

+ 使用类型断言

  ``` typescript
  interface Vegetables {
    color?: string;
    type: string;
  }
  const getVegetables = ({ color, type }: Vegetables) => {
    return `A ${color ? color + " " : ""}${type}`;
  };
  getVegetables({
    type: "tomato",
    size: 12,
    price: 1.2
  } as Vegetables);
  ```

+ 添加索引签名

  ``` typescript
  interface Vegetables {
    color: string;
    type: string;
    [prop: string]: any;
  }
  const getVegetables = ({ color, type }: Vegetables) => {
    return `A ${color ? color + " " : ""}${type}`;
  };
  getVegetables({
    color: "red",
    type: "tomato",
    size: 12,
    price: 1.2
  });
  ```

+ 利用类型兼容性

  ``` typescript
  interface Vegetables {
    type: string;
  }
  const getVegetables = ({ type }: Vegetables) => {
    return `A ${type}`;
  };
  const option = { type: "tomato", size: 12 };
  getVegetables(option);
  ```

### 索引类型

使用接口描述索引的类型和通过索引得到的值的类型，也可以给索引设置 `readonly`，从而防止索引返回值被修改。

``` typescript
interface RoleDic {
  readonly [id: number]: string;
}
const role1: RoleDic = {
  0: "super_admin",
  1: "admin"
};
role1[0] = "admin"; // error 类型"RoleDic"中的索引签名仅允许读取
const role2: RoleDic = {
  s: "super_admin",  // error 不能将类型"{ s: string; a: string; }"分配给类型"RoleDic"。
  a: "admin"
};
// role3 定义了一个数组，索引为数值类型，值为字符串类型
const role3: RoleDic = ["super_admin", "admin"];
```

注意：如果设置索引类型为字符串类型，即便属性名设置的是数值类型，也没有问题。因为 JavaScript 在访问属性值的时候，如果属性名是数值类型，会先将数值类型转为字符串，然后再去访问。

``` javascript
const obj = {
  123: "a", // 定义一个数值类型的123这个属性
  // 在定义一个字符串类型的123这个属性
  // 这里会报错：标识符“"123"”重复。
  "123": "b"
};
console.log(obj); // { '123': 'b' }
```

### 继承接口

接口可以继承，和类一样，提高了接口的可复用性

一个接口可以被多个接口继承，同样，一个接口也可以继承多个接口，多个接口用逗号隔开。

``` typescript
interface Vegetables {
  color: string;
}
interface Food {
  type: string;
}
interface Tomato extends Food, Vegetables {
  radius: number;
}
const tomato: Tomato = {
  type: "vegetables",
  color: "red",
  radius: 1.2
};  // 在定义tomato变量时将继承过来的color和type属性同时声明
```

### 混合类型接口

在 JavaScript 中，函数是对象类型，对象可以有属性，所以有时一个对象既是一个函数，也包含一些属性。TypeScript 3.1+ 支持直接给函数添加属性

``` typescript
interface Counter {
  // 函数，函数的要求是无参数，返回值为void，即无返回值
  (): void;
  // 值的类型为 number 类型的属性
  count: number;
}
// 定义一个函数用来返回这个计数器
const getCounter = (): Counter => {
  const c = () => { c.count++; };
  c.count = 0; // 给函数添加一个 count 属性初始值为 0
  return c; // 返回函数对象
};
// 通过 getCounter 函数得到这个计数器
const counter: Counter = getCounter();
counter();
console.log(counter.count); // 1
counter();
console.log(counter.count); // 2
```

## 函数（Function）

### 函数类型

+ 为函数定义类型

  ``` typescript
  function add(arg1: number, arg2: number): number {
    return x + y;
  }
  // 或者
  const add = (arg1: number, arg2: number): number => {
    return x + y;
  };
  ```

+ 完整的函数类型
  
  一个函数的定义包括函数名、参数、逻辑和返回值。

  ``` typescript
  let add: (x: number, y: number) => number;
  add = (arg1: number, arg2: number): number => arg1 + arg2;
  // error
  add = (arg1: string, arg2: string): string => arg1 + arg2;
  ```

+ 使用接口定义函数类型

  ``` typescript
  interface Add {
    (x: number, y: number): number;
  }
  // error 不能将类型“(arg1: string, arg2: string) => string”分配给类型“Add”
  let add: Add = (arg1: string, arg2: string): string => arg1 + arg2;
  ```

+ 使用类型别名

  ``` typescript
  type Add = (x: number, y: number) => number;
  // error 不能将类型“(arg1: string, arg2: string) => string”分配给类型“Add”
  let add: Add = (arg1: string, arg2: string): string => arg1 + arg2;
  ```

### 参数

``` typescript
const add = (
  // 必选参数
  a: number,
  // 可选参数
  // 接口类型定义的函数类型必选参数和可选参数位置是无所谓的
  // 但是此方式需要将必选参数不能位于可选参数后。
  b?: number,
  // 默认参数：放在必选参数前后都可以
  c = 3,
  // 剩余参数：使用 ... 来表示剩余参数
  ...rest: number[]
) => { // 函数操作... }
```

### 函数重载

在其他一些强类型语言中，函数重载指定义几个函数名相同，但是参数个数或类型不同的函数，在调用时传入不同的参数，编译器会自动调用适合的函数。

TypeScript的函数重载是在类型系统层面的，是为了更好地进行类型推断。与其他一些强类型语言中的定义不同。

TypeScript的函数重载通过为一个函数指定多个函数类型定义，从而对函数调用的返回值进行检查。

**重载只能用 function 来定义，不能使用接口、类型别名等。**

``` typescript
// 重载的一部分，指定当参数类型为string时，返回值为string类型的元素构成的数组
function handleData(x: string): string[];
// 重载的一部分，指定当参数类型为number时，返回值类型为string
function handleData(x: number): string;
// 重载的内容，是实体函数，不算做重载的部分
function handleData(x: any): any {
  if (typeof x === "string") {
    return x.split("");
  } else {
    return x
      .toString()
      .split("")
      .join("_");
  }
}
handleData("abc").join("_");
handleData(123).join("_"); // error 类型"string"上不存在属性"join"
handleData(false); // error 类型"boolean"的参数不能赋给类型"number"的参数。
```

## 泛型（generic）

泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

``` typescript
// 使用 <> 符号定义了一个泛型变量 T
// T 代表某一种类型，可以是基础类型、联合类型等高级类型
// 定义泛型变量之后，在函数中任何地方指定类型使用 T，都代这一种类型
const getArray = <T>(value: T, times: number = 5): T[] => {
  return new Array(times).fill(value);
};
// 可以省略 <number[]>，TypeScript会根据传入函数的value值的类型进行推断
getArray<number[]>([1, 2], 3).forEach(item => {
  console.log(item.length);
});
```

### 泛型变量

**当使用泛型的时候，必须在处理类型涉及到泛型的数据的时候，把这个数据当做任意类型来处理。**这就意味着不是所有类型都能做的操作不能做，不是所有类型都能调用的方法不能调用。

``` typescript
const getLength = <T>(param: T): number => {
  return param.length; // error 类型“T”上不存在属性“length”
};
```

### 泛型函数类型

``` typescript
// 简单定义
const getArray: <T>(arg: T, times: number) => T[] = (arg, times) => {
  return new Array(times).fill(arg);
};

// 使用类型别名
type GetArray = <T>(arg: T, times: number) => T[];
const getArray: GetArray = <T>(arg: T, times: number): T[] => {
  return new Array(times).fill(arg);
};

// 使用接口形式
interface GetArray {
  <T>(arg: T, times: number): T[];
}
const getArray: GetArray = <T>(arg: T, times: number): T[] => {
  return new Array(times).fill(arg);
};

// 将接口中泛型变量提升到接口最外层
// 接口中所有属性和方法都能使用这个泛型变量
interface GetArray<T> {
  (arg: T, times: number): T[];
  tag: T;
}
const getArray: GetArray<number> = <T>(arg: T, times: number): T[] => {
  // error 不能将类型“{ <T>(arg: T, times: number): T[]; tag: string; }”分配给类型“GetArray<number>”。
  // 属性“tag”的类型不兼容。
  return new Array(times).fill(arg);
};
getArray.tag = "a"; // 不能将类型“"a"”分配给类型“number”
getArray("a", 1); // 不能将类型“"a"”分配给类型“number”
```

### 泛型约束

泛型约束就是使用一个类型和 `extends` 对泛型进行约束。

``` typescript
interface ValueWithLength {
  length: number;
}
// 泛型变量 T 受到约束
// 必须满足接口 ValueWithLength，即不管是什么类型，但必须有一个 length 属性，且类型为数值类型。
const getLength = <T extends ValueWithLength>(param: T): number => {
  return param.length;
};
getLength("abc"); // 3
getLength([1, 2, 3]); // 3
getLength({ length: 3 }); // 3
getLength(123); // error 类型“123”的参数不能赋给类型“ValueWithLength”的参数
```

### 在泛型约束中使用类型参数

+ 场景：当定义一个对象，想要只能访问对象上存在的属性时

  使用 K 来继承索引类型 `keyof T`，`keyof T` 相当于一个由泛型变量 T 的属性名构成的联合类型。

  ``` typescript
  const getProp = <T, K extends keyof T>(object: T, propName: K) => {
    return object[propName];
  };
  const obj = { a: "aa", b: "bb" };
  getProp(obj, "c"); // 类型“"c"”的参数不能赋给类型“"a" | "b"”的参数
  ```

+ 场景：当泛型需要被所规定接口约束时

  ``` typescript
  interface FirstInterface {
    doSomething(): number
  }
  interface SecondInterface {
    doSomethingElse(): string
  }

  // 方法一：将接口 FirstInterface 与 SecondInterface 作为超接口来解决问题
  interface ChildInterface extends FirstInterface, SecondInterface {}
  class Demo<T extends ChildInterface> {
    private genericProperty: T

    useT() {
      this.genericProperty.doSomething()
      this.genericProperty.doSomethingElse()
    }
  }

  // 方法二：利用交叉类型进行多类型约束
  class Demo<T extends FirstInterface & SecondInterface> {
    private genericProperty: T
    useT() {
      this.genericProperty.doSomething() // ok
      this.genericProperty.doSomethingElse() // ok
    }
  }
  ```

+ 场景：当声明一个泛型拥有构造函数时
  
  问题：编译器会提示表达式不能构造，因为没有声明这个泛型 T 是构造函数

  ``` typescript
  function factory<T>(type: T): T {
    return new type(); // error: This expression is not constructable
  }

  // 解决方法：使用 new
  // 参数 type 的类型 { new(): T }
  // 表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T
  function factory<T>(type: {new(): T}): T {
    return new type() // ok
  }
  ```

## 类

### 抽象类

抽象类作为其他派生类的基类使用，一般不会直接被实例化，不同于接口，抽象类可以成员的实现细节。

`abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法。

``` javascript
abstract class Animal {
  abstract makeSound(): void;
  move(): void {
    console.log('roaming the earch...');
  }
}

class Cat extends Animal {
  makeSound() {
    console.log('miao miao')
  }
}
const cat = new Cat()
cat.makeSound() // miao miao
cat.move() // roaming the earch...
```

### 访问限定符

+ `public`: 可以被外部访问
+ `private`: 只可以被类的内部访问
+ `protected`: 只可以被类的内部以及子类访问

### class 作为接口

``` javascript
// props的类型
export default class Props {
  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = 'easeInOutQuad'
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () => {}
  public beforeChange: () => {}
  public selesctedColor: string
  public showDots: boolean = true
}

// 当需要传入 props 类型的时候，直接将 Props 作为接口传入
// 设置 defaultProps 初始值的时候，如下设置：
public static defaultProps = new Props()
```
