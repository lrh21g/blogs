# TypeScript基础

## 类型

### 基础类型

``` typescript
// 布尔值 - true / false
let bool: boolean = false;

// 数字 - 支持二、八、十、十六进制的数值
let num: number = 6;

// 字符串 - 单引号/双引号/模板字符串包裹的内容、字符串字面量类型
let str1: string = "Bob";
str1 = 'Tom'
// 字符串字面量类型，即把一个字符串字面量作为一种类型
// 当把一个变量指定为字符串类型的时候，就不能再赋值为其他字符串值
let str2:'Bob'
str2 = 'Jerry' // error 不能将类型 "Jerry"，分配给类型 "Bob"

// 数组
// 格式: type[] 或 Array<type> - type为元素类型
// 设置元素类型均为 number 类型的数组类型，如下所示：
let arr1: number[] = [1, 2, 3]; // type[] 格式 - 推荐使用格式
let arr2: Array<number> = [1, 2, 3]; // Array<type> 格式
// 指定数组里的元素既可以是数值也是字符串，如下所示：
let arr3: number|string[] = [1, 'str'];

// Object
// 希望一个变量或者函数的参数的类型是一个对象时，使用此类型
let obj: object
obj = { name: 'Tom' }
// 问题一: 访问对象中的某个属性，会报错，提示类型 object 上没有这个属性
obj.name // error: 类型 object 上不存在属性 name
// 问题一解决方法：可以使用接口（interface）
interface User {
  name: string;
}
let obj: User = { name: 'Tom' }
// 问题二: 当定义一个函数，参数必须为对象，此时需要用到 object 类型，
function getValue(obj: object, key: string) {
  return obj[key]; // error
}
getValue(obj, 'name')
// 问题二解决方法：使用泛型
function getValue<T extends object, U extends keyof T>(obj: T, key: U) {
  return obj[key];
}

// null 和 undefined
// 默认情况下， undefined 和 null 可以赋值给任意类型的值
// 在 tsconfig.json 的"compilerOptions"里设置了"strictNullChecks": true时，
// >>> undefined 和 null 将只能赋值给它们自身和 void 类型
let u: undefined = undefined;
let n: null = null;

// Symbol：表示独一无二的值，通过 Symbol 函数生成。
// 注意：使用 Symbol 的时候，必须添加 es6 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom"]
let sym1 = Symbol('key');

// BigInt：可以安全地存储和操作大整数。（即超出 Number 能够表示的安全整数范围）
// 使用 BigInt(number) 把 Number 转换为 BigInt
// 如果类型是 BigInt，那么数字后面需要加 n。
// eg: const max1 = max + 1n
// 注意：使用 BigInt 的时候，必须添加 ESNext 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom", "ESNext"]
// declare 定义的类型只会用于编译时的检查，编译结果中会被删除。
declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.
```

### 补充类型

``` typescript
// 元组（Tuple）
// 表示一个已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型。
// TypeScript 2.6+ 要求元组赋值必须类型和个数都对应。
let tuple: [string, number] = ['hello', 10];
// TypeScript 2.6+ [string, number]元组类型的声明效果上可以看做等同于下面的声明：
interface Tuple extends Array<number | string> {
  0: string;
  1: number;
  length: 2;
}

// 枚举（enum）
// 默认情况下，从 0 开始为元素编号
enum Color { Red, Green, Blue };
let c: Color = Color.Green; // 1
console.log(Color[1]) // 'Green'
// 也可以为每个值都赋予不同的、不按顺序排列的值
enum Color { Red = 1, Green = 2, Blue = 4 }
let c: Color = Color.Green; // 2

// Any
// 在编程阶段，不清楚为一个变量指定什么类型，则需要用到 Any 类型
let notSure: any = 4;
notSure = 'maybe a string instead';
// 使用 any 来指定数组中元素类型为任意类型
let list: any[] = [1, true, 'free'];

// void
// 表示没有任何类型。
// 使用场景：当一个函数没有返回值时，通常返回值类型是 void。
// 声明一个 void 类型的变量，只能赋予 undefined 和 null
function warnUser(): void {
  console.log('This is my warning message');
}

// never
// 永不存在的值的类型。使用场景有：
// >>> 1.抛出异常的返回值类型
// >>> 2.根本不会有返回值的函数表达式 或 箭头函数表达式的返回值类型
// >>> 3.变量被用不为真的类型保护所约束时
// never 是任何类型的子类型，可以赋值给任何类型。
// 没有任何类型是 never 的子类型或可以赋值给 never 类型（除了never本身之外）。
// any 也不可以赋值给 never。
// 示例一：抛出异常场景
const errorFunc = (message: string): never => {
  throw new Error(message); // 抛出异常
}
// 示例二：根本不会有返回值的函数，需要区分在定义函数时没有给返回值的情况
const infiniteFunc = (): never => {
  while (true) {}
}
// 示例三：
// 右边的函数体内是一个死循环，所以此函数调用后的返回值类型为 never
// 当给 neverVariable 赋值就会报错
let neverVariable = (() => { while (true) {}; })();
neverVariable = 123; // error 不能将类型"number"分配给类型"never"

// unknown
// 表示未知类型，相对于 any 是安全的。
// 当指定值为 unknown 类型的时候，如果没有通过基于控制流的类型断言来缩小范围的话，是不能对它进行任何操作的。
// 当指定值为 any 类型的时候，可以随意对它进行操作
let value: unknown;
value.foo.bar; // ERROR
value(); // Error

// 交叉类型：取多个类型的并集。使用 & 符号，被 & 符链接的多个类型构成一个交叉类型。
const merge = <T, U>(arg1: T, arg2: U): T & U => {
  let res = <T & U>{}; // 指定返回值的类型兼备T和U两个类型变量代表的类型的特点
  res = Object.assign(arg1, arg2); // 使用Object.assign方法，返回一个合并后的对象；
  return res;
};

// 联合类型：使用 | 符号，只要符合联合类型中的任何一种类型即可
const getLength = (content: string | number): number => {
  if (typeof content === "string") return content.length;
  else return content.toString().length;
};
```

### 枚举类型

枚举使用 `enum` 关键字定义，支持数字和字符串枚举。

+ 数字枚举
  
  枚举默认为数字类型，从 0 开始一次累加。

  数字枚举在定义的时候，可以使用计算值和常量。如果某个字段使用了计算值或常量，那么该字段后面紧接着的字段必须设置初始值，不能使用默认的递增值。

  ``` typescript
  // 指定部分字段，其他使用默认递增索引
  enum Status {
    Ok = 200,
    Created, // 201
    Accepted, // 202
    BadRequest = 400,
    Unauthorized // 401
  }

  const Start = 1;
  enum Index {
    a = Start,
    b, // error 枚举成员必须具有初始化的值
    c
  }
  ```

+ 反向映射

  定义一个枚举值的时候，可以通过 `Enum['key']` 或者 `Enum.key` 的形式获取对应的值 value。**TypeScript 支持反向映射，但是只支持数字枚举**。

  ``` typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    Error = 500
  }
  console.log(Status["Success"]); // 200
  console.log(Status[200]); // 'Success'
  console.log(Status[Status["Success"]]); // 'Success'

  // 编译为 JavaScript 为
  var Status;
  (function (Status) {
    Status[Status["Success"] = 200] = "Success";
    Status[Status["NotFound"] = 404] = "NotFound";
    Status[Status["Error"] = 500] = "Error";
  })(Status || (Status = {}));
  ```

+ 字符串枚举
  
  字符串枚举值要求每个字段的值都必须是**字符串字面量**，或者是**该枚举值中另一个字符串枚举成员**。

  枚举值中可以使用其他枚举成员。**其他枚举成员指的是同一个枚举值中的枚举成员**，因为字符串枚举不能使用常量或者计算值，所以不能使用其他枚举值中的成员。

  ``` typescript
  enum Message {
    Error = "Sorry, error",
    Success = "Hoho, success"
  }

  enum Message {
    Error = "error message",
    ServerError = Error,
    ClientError = Error
  }
  console.log(Message.Error); // 'error message'
  console.log(Message.ServerError); // 'error message'
  ```

+ 异构枚举
  
  异构枚举就是枚举值中既有数字类型又有字符串类型。**不建议使用**，因为枚举值的特点往往是相似的。

  ``` typescript
  enum Result {
    Faild = 0,
    Success = "Success"
  }
  ```

+ 枚举成员类型和联合枚举类型

  如果枚举值里**所有成员的值都是字面量类型的值**，那么这个枚举的每个成员和枚举值本身都可作为类型来使用。满足条件的枚举成员的值有：
  + 不带初始值的枚举成员: `enum E { A }`
  + 值为字符串字面量: `enum E { A = 'a' }`
  + 值为数值字面量，或者带 `-` 符号的数值字面量：`enum E { A = 1 }`、`enum E { A = -1 }`

  1. 枚举成员类型

     ``` typescript
      enum Animal {
        Dog = 1,
        Cat = 2
      }
      interface Dog {
        type: Animal.Dog; // 这里使用Animal.Dog作为类型，指定接口Dog的必须有一个type字段，且类型为Animal.Dog
      }
      let dog: Dog = {
        type: Animal.Dog
      };
      ```

  2. 联合枚举类型

    ``` typescript
    enum Status {
      Off,
      On
    }
    interface Light {
      status: Status;
    }
    const light1: Light = {
      status: Status.Off
    };
    ```

+ const enum

  如果使用枚举只是为了让程序可读性好，而不需要编译后的对象，则可以使用 `const enum`（完全嵌入的枚举），在代码编译后不会创建这个对象，只会从枚举里拿到相应的值进行替换。

  ``` typescript
  const enum Animal {
    Dog,
    Cat
  }
  const animal = Animal.Dog;
  ```

### 类型断言

类型断言，把某个值强行指定为特定类型。主要形式有:

+ `<type>value` 形式: 这种形式在JSX代码中不可以使用，而且也是TSLint不建议的写法
+ `value as type` 形式: 推荐写法

TypeScript 有时不如我们了解一个值的类型，这时希望 TypeScript 进行类型检查，而是交给我们自己进行处理，则需要用到类型断言。

``` typescript
const getStrLength = (target: string | number): number => {
  // 当 TypeScript 不确定一个联合类型的变量是哪个类型的时候
  // 而此时只能访问此联合类型的所有类型里共有的属性或方法
  // 所以需要用到了类型断言进行判断
  if ((<string>target).length) {
    return (target as string).length;
  } else {
    return target.toString().length;
  }
};
```

## 接口（interface）

使用interface来定义接口。

在定义接口的时候，`{}` 括号包裹的是一个代码块，是声明类型的语句。使用冒号指定类型，每条声明之间使用换行分隔，也可以使用分号或逗号。

``` javascript
interface Say {
  (words: string) : string
}

interface User {
  name: string
  age?: number // 可选属性
  readonly isMale: boolean // 只读属性
  say: (words: string) => string // 函数类型描述方法一：在 interface 内部描述函数
  // say: Say // 函数类型描述方法二：先用接口直接描述函数类型，然后再 User 内使用
}
const getUserName = (user: User) => user.name
```

### 多余属性检查

对于多余属性检查，定义的变量比接口少了一些或者多了一些属性是不允许的。

绕开多余属性检查的方法如下：

+ 使用类型断言

  ``` typescript
  interface Vegetables {
    color?: string;
    type: string;
  }
  const getVegetables = ({ color, type }: Vegetables) => {
    return `A ${color ? color + " " : ""}${type}`;
  };
  getVegetables({
    type: "tomato",
    size: 12,
    price: 1.2
  } as Vegetables);
  ```

+ 添加索引签名

  ``` typescript
  interface Vegetables {
    color: string;
    type: string;
    [prop: string]: any;
  }
  const getVegetables = ({ color, type }: Vegetables) => {
    return `A ${color ? color + " " : ""}${type}`;
  };
  getVegetables({
    color: "red",
    type: "tomato",
    size: 12,
    price: 1.2
  });
  ```

+ 利用类型兼容性

  ``` typescript
  interface Vegetables {
    type: string;
  }
  const getVegetables = ({ type }: Vegetables) => {
    return `A ${type}`;
  };
  const option = { type: "tomato", size: 12 };
  getVegetables(option);
  ```

### 索引类型

使用接口描述索引的类型和通过索引得到的值的类型，也可以给索引设置 `readonly`，从而防止索引返回值被修改。

``` typescript
interface RoleDic {
  readonly [id: number]: string;
}
const role1: RoleDic = {
  0: "super_admin",
  1: "admin"
};
role1[0] = "admin"; // error 类型"RoleDic"中的索引签名仅允许读取
const role2: RoleDic = {
  s: "super_admin",  // error 不能将类型"{ s: string; a: string; }"分配给类型"RoleDic"。
  a: "admin"
};
// role3 定义了一个数组，索引为数值类型，值为字符串类型
const role3: RoleDic = ["super_admin", "admin"];
```

注意：如果设置索引类型为字符串类型，即便属性名设置的是数值类型，也没有问题。因为 JavaScript 在访问属性值的时候，如果属性名是数值类型，会先将数值类型转为字符串，然后再去访问。

``` javascript
const obj = {
  123: "a", // 定义一个数值类型的123这个属性
  // 在定义一个字符串类型的123这个属性
  // 这里会报错：标识符“"123"”重复。
  "123": "b"
};
console.log(obj); // { '123': 'b' }
```

### 继承接口

接口可以继承，和类一样，提高了接口的可复用性

一个接口可以被多个接口继承，同样，一个接口也可以继承多个接口，多个接口用逗号隔开。

``` typescript
interface Vegetables {
  color: string;
}
interface Food {
  type: string;
}
interface Tomato extends Food, Vegetables {
  radius: number;
}
const tomato: Tomato = {
  type: "vegetables",
  color: "red",
  radius: 1.2
};  // 在定义tomato变量时将继承过来的color和type属性同时声明
```

### 混合类型接口

在 JavaScript 中，函数是对象类型，对象可以有属性，所以有时一个对象既是一个函数，也包含一些属性。TypeScript 3.1+ 支持直接给函数添加属性

``` typescript
interface Counter {
  // 函数，函数的要求是无参数，返回值为void，即无返回值
  (): void;
  // 值的类型为 number 类型的属性
  count: number;
}
// 定义一个函数用来返回这个计数器
const getCounter = (): Counter => {
  const c = () => { c.count++; };
  c.count = 0; // 给函数添加一个 count 属性初始值为 0
  return c; // 返回函数对象
};
// 通过 getCounter 函数得到这个计数器
const counter: Counter = getCounter();
counter();
console.log(counter.count); // 1
counter();
console.log(counter.count); // 2
```

## 类

### 抽象类

抽象类作为其他派生类的基类使用，一般不会直接被实例化，不同于接口，抽象类可以成员的实现细节。

`abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法。

``` javascript
abstract class Animal {
  abstract makeSound(): void;
  move(): void {
    console.log('roaming the earch...');
  }
}

class Cat extends Animal {
  makeSound() {
    console.log('miao miao')
  }
}
const cat = new Cat()
cat.makeSound() // miao miao
cat.move() // roaming the earch...
```

### 访问限定符

+ `public`: 可以被外部访问
+ `private`: 只可以被类的内部访问
+ `protected`: 只可以被类的内部以及子类访问

### class 作为接口

``` javascript
// props的类型
export default class Props {
  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = 'easeInOutQuad'
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () => {}
  public beforeChange: () => {}
  public selesctedColor: string
  public showDots: boolean = true
}

// 当需要传入 props 类型的时候，直接将 Props 作为接口传入
// 设置 defaultProps 初始值的时候，如下设置：
public static defaultProps = new Props()
```

## 函数（Function）

``` javascript
// 可选参数：在参数后面加上 ? 即代表参数可能不存在
// 默认参数：在参数后面赋值
// 剩余参数：使用 ... 来表示剩余参数
const add = (a: number, b?: number, c = 10, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)
```

### 重载（Overload）

TypeScript的函数重载是在类型系统层面的，是为了更好地进行类型推断。

TypeScript的函数重载通过为一个函数指定多个函数类型定义，从而对函数调用的返回值进行检查。

``` javascript
interface Direction {
  top: number,
  bottom?: number,
  left?: number,
  right?: number
}
function assigned(all: number): Direction
function assigned(topAndBottom: number, leftAndRight: number): Direction
function assigned(top: number, right: number, bottom: number, left: number): Direction

function assigned (a: number, b?: number, c?: number, d?: number) {
  if (b === undefined && c === undefined && d === undefined) {
    b = c = d = a
  } else if (c === undefined && d === undefined) {
    c = a
    d = b
  }
  return {
    top: a,
    right: b,
    bottom: c,
    left: d
  }
}

assigned(1)
assigned(1,2)
assigned(1,2,3)
assigned(1,2,3,4)
```

## 泛型（generic）

在静态编写的时候，并不确定传入的参数是什么类型，只有当在运行时传入参数后才能确定。此时需要一个变量代表传入的类型，然后在返回这个变量。是一种特殊的变量，只用于表示类型。这个类型变量就是**泛型**。

``` typescript
// 在函数名称后面声明泛型变量 <T>
// 用于捕获开发者传入的参数类型，则可以使用 T 做参数类型和返回值类型。
function returnItem<T>(para: T): T {
  return para;
}

// 多个类型参数
function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]];
}
swap([7, 'seven']); // ['seven', 7]
```

### 泛型应用的类型

``` typescript
// 泛型变量
function getArrayLength<T>(arg: Array<T>) {
  // 需要访问变量的 length 属性，而编译器不知道类型 T 上有没有 length 属性
  // 使用 Array<T> ，不管传入的类型如何，起码数组是可以确定的
  console.log((arg as Array<any>).length)
  return arg
}

// 泛型接口
interface ReturnItemFn<T> {
  (para: T): T
}
// 当传入一个 number 作为参数的时候，可以如下声明：
const returnItem: ReturnItemFn<number> = para => para

// 泛型类
// 泛型类使用 <> 括起泛型类型，跟在类名后面
class Stack<T> {
  private arr: T[] = []
  public push(item: T) {
    this.arr.push(item)
  }
  public pop() {
    this.arr.pop()
  }
}
```

### 泛型约束

可以使用 `<T extends xx>` 的方式约束泛型。

``` typescript
// Params 类型表示是 number 或 String 其中之一
type Params = number | string
// 约束泛型为 number 或者 string 之一，当传入其他类型的时候，会报错。
class Stack<T extends Params> {
  private arr: T[] = []
  public push(item: T) {
    this.arr.push(item)
  }
  public pop() {
    this.arr.pop()
  }
}
```

### 泛型约束与索引类型

``` typescript
// 报错场景：getValue函数通过参数获取属性的值，一个参数为对象，另一个参数为对象上的属性，
// 参数 obj 定义的类型是 object
// >>> 在默认情况下只能是 {}
// >>> 但是接受的对象是各种各样，需要一个泛型来表示传入的对象类型 - T extends object
// 参数 key 定义的类型是 string
// >>> key 是否存在于 obj 上无法确定，需要对 key 进行约束
// >>> 借助索引类型进行实现 - <U extends keyof T>
// >>> 索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，泛型 U 被约束在这个联合类型中
function getValue(obj: object, key: string) {
  return obj[key]; // error
}

// 修复问题
function getValue<T extends object, U extends keyof T>(obj: T, key: U) {
  return obj[key];
}
```

### 多重类型进行泛型约束

``` typescript
// 场景：泛型需要被约束，只被允许以下两个接口的类型
interface FirstInterface {
  doSomething(): number
}
interface SecondInterface {
  doSomethingElse(): string
}

// 方法一：将接口 FirstInterface 与 SecondInterface 作为超接口来解决问题
interface ChildInterface extends FirstInterface, SecondInterface {}
class Demo<T extends ChildInterface> {
  private genericProperty: T

  useT() {
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  }
}

// 方法二：利用交叉类型进行多类型约束
class Demo<T extends FirstInterface & SecondInterface> {
  private genericProperty: T
  useT() {
    this.genericProperty.doSomething() // ok
    this.genericProperty.doSomethingElse() // ok
  }
}
```

### 泛型与 new

``` typescript
// 声明一个泛型拥有构造函数
// 问题：编译器会提示表达式不能构造，因为没有声明这个泛型 T 是构造函数
function factory<T>(type: T): T {
  return new type(); // error: This expression is not constructable
}

// 解决方法：使用 new
// 参数 type 的类型 {new(): T} 表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T
function factory<T>(type: {new(): T}): T {
  return new type() // ok
}
```

## 类型推论

在有些没有明确指出类型的地方，类型推论会帮助提供类型。

## Interface 接口

+ 对对象的形状（shape）进行描述
+ 对类（class）进行抽象
+ Duck Typing（鸭子类型）

``` typescript
interface Person {
  readonly id: number;
  name: string;
  age?: number;
}
let onePerson: Person = {
  id: 1234,
  name: 'lrh'
  // age: 12
}
```

## 函数

``` typescript
function add(x: number, y: number = 10, z?: number): number {
  if (typeof z === 'number') {
    return x + y + z
  } else {
    return x + y
  }
}
let result = add(2, 3, 5)

const add = function add(x: number, y: number = 10, z?: number): number {
  if (typeof z === 'number') {
    return x + y + z
  } else {
    return x + y
  }
}
const add2: (x: number, y: number = 10, z?: number) => number = add // 类型推断
```

## 类 Class

+ 类(Class)：定义了一切事物的抽象特点
+ 对象(Obejct)：类的实例
+ 面向对象(OOP)三大特性：封装、继承、多态

`public` `private` `protected` `readonly` `static`

类 和 `Interface`

## 枚举 Enum

``` typescript
const enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'Right'
}
console.log(Direction.Up)
console.log(Direction[0])

// 解析之后
var Direction;
(function (Direction) {
  Direction[Direction["Up"] = 0] = "Up";
  Direction[Direction["Down"] = 0] = "Down";
  Direction[Direction["Left"] = 0] = "Left";
  Direction[Direction["Right"] = 0] = "Right";
})(Direction || (Direction = {}));
console.log(Direction.Up)
console.log(Direction[0])
```

## 泛型 Generics

在定义函数、接口、类的时候，不指定类型。而是在使用的时候指定类型的一种特征

``` javascript
function echo<T>(age: T): T {
  return age
}
const result = echo('123456')

function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}
const result = swap(['string', 123])

function echoWithArr<T>(arg: T[]): T[] {
  console.log(arg.length)
  return arg
}
const arrs = echoWithArr([1, 2, 3])

interface IWithLength {
  length: number
}
function echoWithLength<T extends IWithLength>(arg: T): T {
  console.log(arg.length)
  return arg
}
const str = echoWithLength('123')

class Queue<T> {
  private data = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}
const queue = new Queue<number>()
queue.push(1)
console.log(queue.pop().toFixed())

interface KeyPair<T, U> {
  key: T;
  value: U;
}
let kp1: KeyPair<number, string> = {key: 123, value: 'str'}
let kp2: KeyPair<number, string> = {key: 'str', value: 123}

let arr: number[] = [1, 2, 3]
let arrTwo: Array<number> = [1, 2, 3]

interface IPlus<T> {
  (a: T, b: T): T
}
function plus(a: number, b: number): number {
  return a + b
}
const a: IPlus<number> = plus
```

## 类型别名和类型断言

``` javascript
// 类型别名
type PlusType = (x: number, y: number) => number
function sum(x: number, y: number): number {
  return x + y
}
const sum2: PlusType = sum

type NameResolver = () => string
type NameOrResolver = string | NameResolver
function getName(n: NameOrResolver): string {
  if (typeof n === 'string') {
    return n
  } else {
    return n()
  }
}


// 类型断言
function getLength(input: string | number): number {
  // const str = input as String
  // if (str.length) {
  //   return str.length
  // } else {
  //   const number = input as Number
  //   return number.toString().length
  // }

  if((<string>input).length) {
    return (<string>input).length
  } else {
    return input.toString().length
  }
}
```

## 声明文件

``` javascript
// jQuery.d.ts
declare var jQuery: (selector: string) => any
```
