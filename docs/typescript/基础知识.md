# TypeScript基础

## 基础类型

### 原始类型与常用类型

``` javascript
// 布尔值
let isDone: boolean = false;

// 数字（支持二进制、八进制、十进制、十六进制）
let decLiteral: number = 6;

// 字符串（包括模板字符串）
let name: string = "bob";

// 数组
// 格式： 元素类型[] 或者 Array<元素类型>
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];

// 元组（Tuple）
// 表示一个已知元素数量和类型的数组，各元素的类型不必相同。
// 必须与声明的类型一致，不能多，不能少，甚至顺序不能不符。
let x: [string, number] = ['hello', 10];
// 当访问一个越界的元素，会使用联合类型替代，但是访问新元素的时候会报错
x[3] = 'world'; // 字符串可以赋值给 {string | number} 类型

// 枚举
// 默认情况下，从 0 开始为元素编号
enum Color { Red, Green, Blue };
let c: Color = Color.Green;
// 枚举也可以采用手动赋值
enum Color { Red = 1, Green = 2, Blue = 4 }
let c: Color = Color.Green;

// void
// 表示没有任何类型。当一个函数没有返回值时，通常返回值类型是 void。
// 声明一个 void 类型的变量，只能赋予 undefined 和 null
function warnUser(): void {
  console.log('This is my warning message');
}

// null 和 undefined
// 默认情况下，null 和 undefined 是所有类型的子类型。
// 指定 --strictNullChecks 标记时，null 和 undefined 只能赋值给 void 和它们各自。
let u: undefined = undefined;
let n: null = null;

// Symbol
// 注意：使用 Symbol 的时候，必须添加 es6 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom"]
let sym1 = Symbol('key');

// BigInt - 可以安全地存储和操作大整数。（即超出 Number 能够表示的安全整数范围）
// 使用 BigInt(number) 把 Number 转换为 BigInt
// 如果类型是 BigInt，那么数字后面需要加 n。
// eg: const max1 = max + 1n
// 注意：使用 BigInt 的时候，必须添加 ESNext 的编译辅助库
// tsconfig.json - "lib": ["es6", "dom", "ESNext"]
// declare 定义的类型只会用于编译时的检查，编译结果中会被删除。
declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.

// Any
// 在编程阶段还不清楚类型的变量指定一个类型
let notSure: any = 4;
notSure = 'maybe a string instead';
let list: any[] = [1, true, 'free'];

// unknown: 是 any 类型对应的安全类型，
// 当 unknown 类型被确定是某个类型之前,它不能被进行任何操作。
// 比如：实例化、getter、函数执行等等。而 any 可以
// >>> unknown: 类型的值执行大多数操作之前,必须进行某种形式的检查,
// >>> any: 类型的值执行操作之前,不必进行任何检查
let value: unknown;
value.foo.bar; // ERROR
value(); // Error

// never
// 永不存在的值的类型。通常是以下的返回值类型：
// 1.抛出异常的返回值类型
// 2.根本不会有返回值的函数表达式 或 箭头函数表达式的返回值类型
// 3.变量被用不为真的类型保护所约束时
// never 是任何类型的子类型，可以赋值给任何类型
// 没有任何类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。
// any 也不可以赋值给 never。
const empty: never[] = []; // 空数组，而且永远是空的
function error(message: string): never {
  // 返回never的函数必须存在无法达到的终点
  throw new Error(message);
}
function infiniteLoop(): never {
  // 返回never的函数必须存在无法达到的终点
  while (true) {}
}

// Object
// 非原始类型，除 number，string，boolean，symbol，null 或 undefined 之外的类型。
// 普通对象、枚举、数组、元组通通都是 object 类型。
enum Direction {
  Center = 1
}
let value: object
value = Direction
```

### 枚举类型

``` javascript
// 数字枚举
// 声明枚举类型，默认为数字类型，从 0 开始一次累加。
// 当把第一个值赋值后，后面会根据第一个值进行累加。
enum Direction {
  Up,
  Down,
  Left,
  Right
}
console.log(Direction.Up === 0); // true - 正向映射
console.log(Direction[0]); // Up - 反向映射

// 字符串枚举
enum Direction {
  Up = 'Up',
  Down = 'Down',
  Left = 'Left',
  Right = 'Right'
}
console.log(Direction['Right'], Direction.Up); // Right Up

// 异构枚举
enum BooleanLikeHeterogeneousEnum {
  No = 0,
  Yes = "YES",
}

// 常量枚举
const enum Direction {
  Up = 'Up',
  Down = 'Down',
  Left = 'Left',
  Right = 'Right'
}
const a = Direction.Up; // 解析为：var a = "Up";

// 枚举成员类型：枚举成员成了类型
enum Direction {
  Up,
  Down,
  Left,
  Right
}
const a = 0
console.log(a === Direction.Up) // true
type c = 0;
declare let b: c
b = 1 // 不能将类型“1”分配给类型“0”
b = Direction.Up // ok

// 联合枚举类型
enum Direction {
  Up,
  Down,
  Left,
  Right
}
declare let a: Direction
enum Animal {
  Dog,
  Cat
}
a = Direction.Up // ok
a = Animal.Dog // 不能将类型“Animal.Dog”分配给类型“Direction”

// 枚举合并：分开声明枚举，会自动合并
enum Direction {
  Up = 'Up',
  Down = 'Down',
  Left = 'Left',
  Right = 'Right'
}
enum Direction {
  Center = 1
}

// 为枚举添加静态方法：借助 namespace 命名空间，可以给枚举添加静态方法。
enum Month {
  January,
  February,
  March,
  April,
  May,
  June,
  July,
  August,
  September,
  October,
  November,
  December,
}
namespace Month {
  export function isSummer(month: Month) {
    switch (month) {
      case Month.June:
      case Month.July:
      case Month.August:
        return true;
      default:
        return false
    }
  }
}
console.log(Month.isSummer(Month.January)) // false
```

枚举的本质：如下示例所示，`Direction[Direction["Up"] = 10] = "Up"` 也就是 `Direction[10] = "Up"` ,所以可以把枚举类型看成一个JavaScript对象，而由于其特殊的构造，导致其拥有正反向同时映射的特性。

``` javascript
// 上面示例，编译为 JavaScript 如下所示
var Direction;
(function (Direction) {
  Direction[Direction["Up"] = 10] = "Up"; // 即：Direction[10] = "Up"
  Direction[Direction["Down"] = 11] = "Down";
  Direction[Direction["Left"] = 12] = "Left";
  Direction[Direction["Right"] = 13] = "Right";
})(Direction || (Direction = {}));
```

## 类型推论

在有些没有明确指出类型的地方，类型推论会帮助提供类型。

## 类型

``` typescript
let u: undefined = undefined
let n: null = null

let num: number = undefined // null、undefined为所有类型的子类型

let notSure: any = 4 // any类型
notSure = 'maybe it is a string'

let numberOrString: number | string = 234 // 联合类型
numberOrString = 'abc'

let arrOfNumbers: number[] = [1, 2, 3, 4] // Array
arrOfNumbers.push(5)

function test() {
  console.log(arguments) // 类数组 类似数组，但是不具有全部的数组方法
  console.log(arguments.length)
}

let user：[string, number] = ['viking', 1] // 元组 Tuple：允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。
```

## Interface 接口

+ 对对象的形状（shape）进行描述
+ 对类（class）进行抽象
+ Duck Typing（鸭子类型）

``` typescript
interface Person {
  readonly id: number;
  name: string;
  age?: number;
}
let onePerson: Person = {
  id: 1234,
  name: 'lrh'
  // age: 12
}
```

## 函数

``` typescript
function add(x: number, y: number = 10, z?: number): number {
  if (typeof z === 'number') {
    return x + y + z
  } else {
    return x + y
  }
}
let result = add(2, 3, 5)

const add = function add(x: number, y: number = 10, z?: number): number {
  if (typeof z === 'number') {
    return x + y + z
  } else {
    return x + y
  }
}
const add2: (x: number, y: number = 10, z?: number) => number = add // 类型推断
```

## 类 Class

+ 类(Class)：定义了一切事物的抽象特点
+ 对象(Obejct)：类的实例
+ 面向对象(OOP)三大特性：封装、继承、多态

`public` `private` `protected` `readonly` `static`

类 和 `Interface`

## 枚举 Enum

``` typescript
const enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'Right'
}
console.log(Direction.Up)
console.log(Direction[0])

// 解析之后
var Direction;
(function (Direction) {
  Direction[Direction["Up"] = 0] = "Up";
  Direction[Direction["Down"] = 0] = "Down";
  Direction[Direction["Left"] = 0] = "Left";
  Direction[Direction["Right"] = 0] = "Right";
})(Direction || (Direction = {}));
console.log(Direction.Up)
console.log(Direction[0])
```

## 泛型 Generics

在定义函数、接口、类的时候，不指定类型。而是在使用的时候指定类型的一种特征

``` javascript
function echo<T>(age: T): T {
  return age
}
const result = echo('123456')

function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}
const result = swap(['string', 123])

function echoWithArr<T>(arg: T[]): T[] {
  console.log(arg.length)
  return arg
}
const arrs = echoWithArr([1, 2, 3])

interface IWithLength {
  length: number
}
function echoWithLength<T extends IWithLength>(arg: T): T {
  console.log(arg.length)
  return arg
}
const str = echoWithLength('123')

class Queue<T> {
  private data = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}
const queue = new Queue<number>()
queue.push(1)
console.log(queue.pop().toFixed())

interface KeyPair<T, U> {
  key: T;
  value: U;
}
let kp1: KeyPair<number, string> = {key: 123, value: 'str'}
let kp2: KeyPair<number, string> = {key: 'str', value: 123}

let arr: number[] = [1, 2, 3]
let arrTwo: Array<number> = [1, 2, 3]

interface IPlus<T> {
  (a: T, b: T): T
}
function plus(a: number, b: number): number {
  return a + b
}
const a: IPlus<number> = plus
```

## 类型别名和类型断言

``` javascript
// 类型别名
type PlusType = (x: number, y: number) => number
function sum(x: number, y: number): number {
  return x + y
}
const sum2: PlusType = sum

type NameResolver = () => string
type NameOrResolver = string | NameResolver
function getName(n: NameOrResolver): string {
  if (typeof n === 'string') {
    return n
  } else {
    return n()
  }
}


// 类型断言
function getLength(input: string | number): number {
  // const str = input as String
  // if (str.length) {
  //   return str.length
  // } else {
  //   const number = input as Number
  //   return number.toString().length
  // }

  if((<string>input).length) {
    return (<string>input).length
  } else {
    return input.toString().length
  }
}
```

## 声明文件

``` javascript
// jQuery.d.ts
declare var jQuery: (selector: string) => any
```
