# 基础类型

## Undefined

一个没有被赋值的变量的类型是 `undefined`。如果方法或者是语句中操作的变量没有被赋值，则会返回 `undefined`。转为数值时为 `NaN`。

```javascript
// 变量声明了，但没有赋值
var foo
foo // undefined

// 对象没有赋值的属性
var obj = new Object()
obj.attr // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function fun(a) {
  console.log(typeof a) // undefined
  return a
}
fun() // undefined

// 函数没有返回值时，默认返回 undefined
function fun() {}
fun() // undefined
```

## Null

`null` 值表示一个空对象指针，转为数值时为 `0`。

- 在定义将来要保存对象值的变量时，建议使用 `null` 来初始化，不要使用其他值。
- 调用函数时，某个参数未设置任何值，可以传入 `null`，表示该参数为空。

```javascript
typeof null // "object"
typeof undefined // "undefined"

null === undefined // false
null == undefined // true

null === null // true
null == null // true

!null //true
isNaN(1 + null) // false
isNaN(1 + undefined) // true
```

## Boolen

布尔值，取值仅能为 `true`（真）和 `false`（假）的数据类型。

```javascript
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(-0) // false
Boolean(false) // false
Boolean(NaN) // false
Boolean('') // false

Boolean('false') // true
Boolean(3.14) // true
Boolean(true) // true
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
Boolean(Symbol('foo')) // true
```

## Number

`Number` 是一种定义 64 位双精度浮点型的数字数据类型。

![dobule_precision_64_bit_float](../files/images/dobule_precision_64_bit_float.drawio.png)

64 位浮点数是采用**科学计数法**来表示一个数字的格式：`(-1)^sign * 2^(exponent - 1023) * 1.mantissa`

根据国际标准 IEEE 754，JavaScript 浮点数的 64 个二进制位，从最左边开始：

- `sign bit`（符号位）：第 1 位，表示整个数的正负值。`0` 表示正数，`1` 表示负数。
- `exponent`（指数位）：第 2 位到第 12 位（共 11 位），大小范围为 `[0 , 2047]`。

  科学计数法是可以表示大于 1 ，或者小于 1 的数（小数），即：通过正负指数的值来标识显示。

  由于指数位的 11 位不包括符号位，为了达到正负的效果，就引入了 **指数的偏移值**。

  指数具有正负值 （来控制小数点左右移位），按照二进制中负数的规则（取反，补位），指数值为 `[0, 1023]` 区间内为正数，`[1024, 2047]` 内为负数（二进制中负数最高位为 1 ）。

  根据 IEEE 规范， 0 和 2047 两个最值需要做特殊用途，所以这里移除，所以整个规范的指数取值范围是： `[1, 2046]`

  引入指数的偏移值 `bias`（bias = 1023），可以是运算简单，则 `[-1022 + bias, 1023 + bias]` 等同于 `[1, 2046]`，抛去了符号位的影响，最终：1023 就变成了 0 ，1024 变成了 1。

  ```javascript
  // 为何负数是从 1024 开始？

  011 11111111 # 1023
  // 如果该二进制再继续增大，就进入了负数区域（最高位为 1）
  100 00000000 # 1024
  ```

- `mantissa`（尾数位）：第 13 位到第 64 位（共 52 位），小数部分（即有效数字）。

  在科学计数法的显示下，分数部分（`fraction` 也是 `mantissa` 部分之一）最高有效为是 `1` （个位数）

  ```javascript
  1000.001(2)
  2 ^ (3 * 1.000001)(科学计数法标识)
  ```

  `mantissa` 会以 `000001` 来示意，会被规范成 `1.M` 格式 ，其中 `1` 会被隐藏掉，所以最大是表达 `53` 位的数（实际 `mantissa` 只有 `52` 位）

`sign bit`（符号位）决定了一个数的正负，`exponent`（指数位）决定了数值的大小，`mantissa`（尾数位）决定了数值的精度。

以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。

- 小数点前的数字多于 21 位
- 小数点后的零多于 5 个

```javascript
1234567890123456789012 // 1.2345678901234568e+21

0.0000003 // 3e-7
```

### 数值范围

根据国际标准 IEEE 754，64 位双精度浮点数 `exponent`（指数位）部分长度是 11 个二进制位，意味着指数位部分的最大值是 2047（2^11 - 1）。

通过科学计数法标识数值（通过正负指数的值来标识显示），由于指数位的 11 位不包括符号位，为了达到正负的效果，来控制小数点左右移位。按照二进制中负数的规则（取反，补位），指数值为 `[0, 1023]` 区间内为正数，`[1024, 2047]` 内为负数（二进制中负数最高位为 1 ）。

JavaScript 能够表示的数值范围为 `(2^1024, 2^-1023)`（开区间，不包含），超出这个范围的数无法表示。

- 正向溢出：如果一个数大于等于 `2^1024`，则会发生正向溢出。JavaScript 无法表示这么大的数，则会返回 `Infinity`。
- 负向溢出：如果一个数小于等于 `2^-1075` （指数部分最小值 -1023，再加上小数部分的 52 位），则会发生负向溢出。JavaScript 无法表示这么小的数，则会返回 `0`。

```javascript
Math.pow(2, 1024) // Infinity
Math.pow(2, -1075) // 0
```

### 数值的进制

使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供了相关进制的表示方法：

- 十进制：没有前导 `0` 的数值。
- 八进制：有前缀 `0o` 或 `0O` 的数值，或者有前导 `0`、且只用到 `0-7` 的八个阿拉伯数字的数值。
- 十六进制：有前缀 `0x` 或 `0X` 的数值。
- 二进制：有前缀 `0b` 或 `0B` 的数值。

```javascript
0o377 // 八进制，255
0777 // 八进制（只用到 0-7 的八个阿拉伯数字的数值），511
0xff // 十六进制，255
0b11 // 二进制，3

0o88 // 八进制，报错，出现不属于该进制的数字
0xzz // 十六进制，报错，出现不属于该进制的数字
0b22 // 二进制，报错，出现不属于该进制的数字
```

### 特殊数值

- 正零和负零

  JavaScript 的 64 位双精度浮点数之中，有一个二进制位是符号位，任何一个数都有一个对应的负值。

  在 JavaScript 内部存在 `+0` 和 `-0`，区别 64 位双精度浮点数表示法的符号位不同。

  注：`+0` 或 `-0` 当作分母时，返回的值是不相等的。

  ```javascript
  -0 === +0 // true
  0 === -0 // true
  0 === +0 // true

  +0 // 0
  -0 // 0
  (-0).toString() // '0'
  (+0).toString() // '0'

  (1 / +0) === (1 / -0) // false
  ```

- NaN

  `NaN` 表示非数字的值（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）

  ```javascript
  5 - 'x' // NaN

  Math.acos(2) // NaN
  Math.log(-1) // NaN
  Math.sqrt(-1) // NaN

  0 / 0 // NaN

  typeof NaN // 'number'

  NaN === NaN // false
  [NaN].indexOf(NaN) // -1 。indexOf 方法内部使用的是严格相等运算符，所以该方法对 NaN 不成立
  Boolean(NaN) // false

  NaN + 32 // NaN
  NaN - 32 // NaN
  NaN * 32 // NaN
  NaN / 32 // NaN
  ```

- Infinity

  `Infinity` 是一个数值，表示无穷大。用来表示两种场景：

  - 一个正的数值太大，或一个负的数值太小，无法表示。
  - 非 0 数值除以 0，得到 `Infinity` 。

  `Infinity` 有正负之分，`Infinity` 表示正的无穷，`-Infinity` 表示负的无穷。

  `Infinity` 大于一切数值（除了 `NaN`），`-Infinity` 小于一切数值（除了 `NaN`）。

  ```javascript
  Math.pow(2, 1024) // Infinity，数值太大
  1 / 0 // Infinity，非 0 数值除以 0
  0 / 0 // NaN

  Infinity === -Infinity // false

  1 / -0 // -Infinity
  -1 / -0 // Infinity

  Infinity > 1000 // true
  -Infinity < -1000 // true

  Infinity > NaN // false
  Infinity < NaN // false

  -Infinity > NaN // false
  -Infinity < NaN // false

  5 * Infinity // Infinity
  5 - Infinity // -Infinity
  Infinity / 5 // Infinity
  5 / Infinity // 0

  0 * Infinity // NaN
  0 / Infinity // 0
  Infinity / 0 // Infinity

  Infinity + Infinity // Infinity
  Infinity * Infinity // Infinity
  Infinity - Infinity // NaN
  Infinity / Infinity // NaN

  null * Infinity // NaN
  null / Infinity // 0
  Infinity / null // Infinity

  undefined + Infinity // NaN
  undefined - Infinity // NaN
  undefined * Infinity // NaN
  undefined / Infinity // NaN
  Infinity / undefined // NaN
  ```

### 数值相关全局方法

- parseInt()

  `parseInt(string, radix)` 函数：将其第一个参数转换为一个字符串，对该字符串进行解析，然后返回一个整数或 `NaN`。
  - `string` ：被解析的值。如果参数不是一个字符串，则将其转换为字符串 (使用 ToString 抽象操作)。
  - `radix` ：可选值，默认十进制。从 2 到 36 的整数，表示进制的基数。

  ```javascript
  // parseInt 基本用法

  parseInt('123') // 123

  parseInt('   81') // 81，字符串头部有空格，空格会被自动去除

  parseInt(1.23) // 1，如果不是字符串，则会先转为字符串再转换

  // 字符串转为整数，字符依次转换，如果遇到不能转为数字的字符，则不再转换去，返回已经转好的部分
  parseInt('8a') // 8
  parseInt('12**') // 12
  parseInt('12.34') // 12
  parseInt('15e2') // 15
  parseInt('15px') // 15

  // 字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回 NaN
  parseInt('abc') // NaN
  parseInt('.3') // NaN
  parseInt('') // NaN
  parseInt('+') // NaN
  parseInt('+1') // 1

  // 字符串以 0x 或 0X 开头，将其按照十六进制数解析
  parseInt('0x10') // 16
  // 字符串以 0 开头，将其按照 10 进制解析
  parseInt('011') // 11

  // 对于会自动转为科学计数法的数字，会将科学计数法的表示方法视为字符串
  parseInt(1000000000000000000000.5) // 1，等同于 parseInt('1e+21')
  parseInt(0.0000008) // 8，等同于 parseInt('8e-7')
  ```

  ```javascript
  // parseInt 进制转换

  parseInt('1000') // 1000，parseInt('1000', 10) 默认十进制
  parseInt('1000', 2) // 8
  parseInt('1000', 6) // 216
  parseInt('1000', 8) // 512

  // parseInt(string, radix) 中，如果 radix 参数不是数值，会被自动转为一个整数
  // 转换后的整数超出这个范围 2 到 36 之间，则返回 NaN
  // 如果 radix 为 0、undefined 和 null，则直接忽略
  parseInt('10', 37) // NaN
  parseInt('10', 1) // NaN
  parseInt('10', 0) // 10
  parseInt('10', null) // 10
  parseInt('10', undefined) // 10

  // 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值
  // 如果最高位无法转换，则直接返回 NaN
  parseInt('1546', 2) // 1，对于二进制而言，1 是有意义的字符，5、4、6都是无意义的字符
  parseInt('546', 2) // NaN

  // 如果 parseInt 的第一个参数不是字符串，会被先转为字符串
  parseInt(0x11, 36) // 43
  // 等同于 parseInt(String(0x11), 36)，即 parseInt('17', 36)
  // 十六进制的 0x11 会被先转为十进制的 17，再转为字符串，再用三十六进制解读字符串17
  parseInt(0x11, 2) // 1
  // 等同于 parseInt(String(0x11), 2)，即 parseInt('17', 2)
  // 十六进制的 0x11 会被先转为十进制的 17，再转为字符串，再用二进制解读字符串17

  parseInt(011, 2) // NaN
  // 等同于 parseInt(String(011), 2)，即 parseInt(String(9), 2)
  // 011 会被先转为字符串 9，9 不是二进制的有效字符，所以返回 NaN
  ```

- parseFloat()

  `parseFloat(string)` 函数：解析一个参数（必要时先转换为字符串）并返回一个浮点数。

  注：如果给定值不能被转换成数值，则会返回 `NaN`。

  ```javascript
  parseFloat('3.14') // 3.14

  // 如果字符串符合科学计数法，则会进行相应的转换
  parseFloat('314e-2') // 3.14
  parseFloat('0.0314E+2') // 3.14

  // 字符串转为浮点数，字符依次转换，如果遇到不能转为数字的字符，则不再转换去，返回已经转好的部分
  parseFloat('3.14more non-digit characters') // 3.14

  // parseFloat方法会自动过滤字符串前导的空格
  parseFloat('\t\v\r12.34\n ') // 12.34

  // 如果参数不是字符串，则会先转为字符串再转换
  parseFloat([1.23]) // 1.23，等同于 parseFloat(String([1.23]))

  // 如果字符串的第一个字符不能转化为浮点数，则返回NaN
  parseFloat([]) // NaN
  parseFloat('FF2') // NaN
  parseFloat('') // NaN

  // parseFloat的转换结果不同于Number函数

  parseFloat(true)  // NaN
  Number(true) // 1

  parseFloat(null) // NaN
  Number(null) // 0

  parseFloat('') // NaN
  Number('') // 0

  parseFloat('123.45#') // 123.45
  Number('123.45#') // NaN
  ```

- isNaN()

  `isNaN(value)` 函数：用来确定一个值是否为 `NaN` 。如果给定值为 `NaN` ，则返回值为 `true`；否则为 `false`。

  ```javascript
  isNaN(NaN) // true
  isNaN(123) // false

  // isNaN只对数值有效，如果传入其他值，会被先转成数值。
  // 传入字符串的时候，字符串会被先转成 NaN，所以最后返回 true
  isNaN('Hello') // true，相当于 isNaN(Number('Hello'))
  isNaN({}) // true，等同于 isNaN(Number({}))
  isNaN(['xzy']) // true，等同于 isNaN(Number(['xzy']))

  // 对于空数组和只有一个数值成员的数组，isNaN 返回 false
  isNaN([]) // false
  isNaN([123]) // false
  isNaN(['123']) // false
  ```

  使用 `isNaN` 之前，最好判断一下数据类型

  ```javascript
  function isNaN(value) {
    return typeof value === 'number' && isNaN(value);
  }
  ```

  判断 `NaN` 更可靠的方法是，利用 `NaN` 为唯一不等于自身的值的特点

  ```javascript
  function isNaN(value) {
    return value !== value;
  }
  ```

- isFinite()

  `isFinite(testValue)` 函数：用来判断被传入的参数值是否为一个有限数值（finite number）

  - `Infinity`、`-Infinity`、`NaN` 和 `undefined` 会返回 `false`
  - 其他的数值都会返回 `true`

  ```js
  isFinite(Infinity) // false
  isFinite(-Infinity) // false
  isFinite(NaN) // false
  isFinite(undefined) // false
  isFinite(null) // true
  isFinite(-1) // true
  ```

### 数值精度相关问题

- 0.1 + 0.2 !== 0.3

  ```javascript
  0.0001100110011001100110011001100110011001100110011001101 // 0.1 二进制
  0.001100110011001100110011001100110011001100110011001101 // 0.2 二进制

  0.0100110011001100110011001100110011001100110011001100111 // 0.1 + 0.3 = 0.30000000000000004
  0.010011001100110011001100110011001100110011001100110011 // 0.3 二进制
  ```

  类似的计算有：

  - `0.075.toFixed(2) === 0.08` 返回为 `false`
  - `0.075 * 3 === 0.22499999999999998` 返回为 `true`

  浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。

  实际上，这里错误的不是结论，而是比较的方法。正确的比较方法是使用 JavaScript 提供的最小精度值：`Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON`

- 小数转换二进制进位

  ```javascript
  1.1.toString(2) // 1.000110011001100110011001100110011001100110011001101
  1.1.toString(2).length // 53

  0.1.toString(2) // 0.0001100110011001100110011001100110011001100110011001101
  0.1.toString(2).length // 57
  ```

## BigInt

### BigInt 基本使用

`BigInt` 提供了一种方法来表示大于 `2^53 - 1` 的整数，可以表示任意大的整数。

可以用在一个整数字面量后面加 `n` 的方式定义一个 `BigInt`，或者调用函数 `BigInt()`，并传递一个整数值或字符串值。

- 不能用于 `Math` 对象中的方法
- 不能和任何 `Number` 实例混合运算，两者必须转换成同一种类型。`BigInt` 变量在转换成 `Number` 变量可能会丢失精度。

```javascript
const theBiggestInt = 9007199254740991n
const alsoHuge = BigInt(9007199254740991) // 9007199254740991n
const hugeString = BigInt("9007199254740991") // 9007199254740991n
const hugeHex = BigInt("0x1fffffffffffff") // 9007199254740991n
const hugeBin = BigInt("0b11111111111111111111111111111111111111111111111111111") // 9007199254740991n
```

```javascript
// BigInt 和 Number 不是严格相等的，但是宽松相等的
0n === 0 // false
0n == 0 // true

// BigInt 和 Number 可以进行比较
1n < 2 // true
2n > 1 // true
2 > 2 // false
2n > 2 // false
2n >= 2 // true

// BigInt 和 Number 混在一个数组内并排序
const mixed = [4n, 6, -12n, 10, 4, 0, 0n] // [4n, 6, -12n, 10, 4, 0, 0n]
mixed.sort() // [-12n, 0, 0n, 10, 4n, 4, 6]

0n === Object(0n); // false
Object(0n) === Object(0n); // false
// Object 包装的 BigInt 使用 object 的比较规则进行比较，只用同一个对象在比较时才会相等
const o = Object(0n);
o === o // true

Boolean(0n) // false
0n || 12n // 12n
!12n // false
!0n // true
```

### BigInt 相关方法

- BigInt.asIntN()

  `BigInt.asIntN(width, bigint)` 方法：将 `BigInt` 值转换为一个 `-2^(width-1)` 与 `2^(width-1)-1` 之间的有符号整数。
  - `width` ：可存储整数的位数
  - `bigint` ：要存储在指定位数上的整数

  ```javascript
  const max = 2n ** (64n - 1n) - 1n

  BigInt.asIntN(64, max) // 9223372036854775807n
  BigInt.asIntN(64, max + 1n) // -9223372036854775808n
  ```

- BigInt.asUintN()

  `BigInt.asUintN(width, bigint)` 方法：将 `BigInt` 转换为一个 `0` 和 `2^width-1` 之间的无符号整数。
  - `width` ：可存储整数的位数
  - `bigint` ：要存储在指定位数上的整数

  ```javascript
  const max = 2n ** 64n - 1n

  BigInt.asUintN(64, max) // 18446744073709551615n
  BigInt.asUintN(64, max + 1n) // 0n
  ```

## String

`String` 数据类型表示零或多个 16 位 Unicode 字符序列。可以使用双引号（ " ）、单引号（ ' ）或反引号（ ` ）

```javascript
'abc'
"abc"
'key = "value"' // 单引号字符串的内部，可以使用双引号

// 单引号（双引号）字符串的内部，使用单引号（双引号）需在前面加上反斜杠，用来转义
'Did she say \'Hello\'?'
"Did she say \"Hello\"?"
```

字符串 `length` 属性返回字符串的长度，该属性也是无法改变的，但也不会报错。

```javascript
var str = 'hello'
str.length // 5

str.length = 3
str.length // 5
```

字符串可以被视为字符数组，可使用数组的方括号运算符，用来返回某个位置的字符（位置编号从 0 开始）

```javascript
var str = 'hello'
str[0] // "h"
str[1] // "e"
str[4] // "o"

// 数组的方括号中，如果数字超过字符串的长度或不是数字，则返回 undefined
'hello'[1] // "e"
'hello'[5] // undefined
'hello'[-1] // undefined
'hello'['x'] // undefined

// 无法通过数组的方括号改变字符串之中的单个字符
var str = 'hello'
delete str[0]
str // "hello"
str[1] = 'a'
str // "hello"
```

### 字符转义

转义符（`\`，反斜杠）用于表示一些特殊字符

- `\0` ：null（`\u0000`）
- `\b` ：后退键（`\u0008`）
- `\f` ：换页符（`\u000C`）
- `\n` ：换行符（`\u000A`）
- `\r` ：回车键（`\u000D`）
- `\t` ：制表符（`\u0009`）
- `\v` ：垂直制表符（`\u000B`）
- `\'` ：单引号（`\u0027`）
- `\"` ：双引号（`\u0022`）
- `\\` ：反斜杠（`\u005C`）
- `\HHH` ：反斜杠后紧跟三个八进制数（000 到 377），代表一个字符。`HHH` 对应该字符的 Unicode 码点，比如 `\251` 表示版权符号。
- `\xHH` ：`\x` 后面紧跟两个十六进制数（00 到 FF），代表一个字符。`HH` 对应该字符的 Unicode 码点，比如 `\xA9` 表示版权符号。
- `\uXXXX` ：`\u` 后面紧跟四个十六进制数（0000 到 FFFF），代表一个字符。`XXXX` 对应该字符的 Unicode 码点，比如 `\u00A9` 表示版权符号。

```javascript
'\a' // "a"，非特殊字符前面使用反斜杠，则反斜杠会被省略
"Prev \\ Next" // "Prev \ Next"，反斜杠前加反斜杠，用来对自身转义

'\251' // "©"
'\xA9' // "©"
'\u00A9' // "©"

'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
```

### 模板字符量

模板字面量是用反引号（`）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和带标签的模板的特殊结构。

- 多行字符串：模板字面量会保持反引号内部的空格。

  ```javascript
  let templateLiterals = `
    first line
    second line
  `
  ```

- 字符串插值：通过使用占位符 `${expression}` 嵌入待替换的表达式。

  ```javascript
  const a = 5
  const b = 10
  const templateLiterals = `${a} + ${b} = ${a + b}`
  console.log(templateLiterals) // 5 + 10 = 15

  // 嵌套模板字面量
  const nestedTemplateLiterals = `header ${
    isLargeScreen() ? "" : `icon-${item.isCollapsed ? "expander" : "collapser"}`
  }`
  ```

- 带标签的模板（标签函数）：允许使用函数解析模板字面量。

  标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。

  ```javascript
  function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
    console.log('strings : ', strings);
    console.log('aValExpression : ', aValExpression);
    console.log('bValExpression : ', bValExpression);
    console.log('sumExpression : ', sumExpression);
    return 'foobar';
  }

  function zipTag(strings, ...expressions) {
    return (
      strings[0] + expressions.map((e, i) => `${e}${strings[i + 1]}`).join('')
    )
  }

  let a = 6
  let b = 9

  simpleTag`${a} + ${b} = ${a + b}` // 返回 'foobar'
  // strings : [ '', ' + ', ' = ', '' ]
  // aValExpression : 6
  // bValExpression : 9
  // sumExpression : 15

  zipTag`${a} + ${b} = ${a + b}` // "6 + 9 = 15"
  ```

  在标签函数的第一个参数中，存在一个特殊的属性 `raw`，可以通过它来访问模板字符串的原始字符串，而无需转义特殊字符。

  ```javascript
  function tag(strings) {
    console.log(strings.raw[0])
  }

  tag`string text line 1 \n string text line 2`
  // string text line 1 \n string text line 2

  // 使用 String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。
  let str = String.raw`Hi\n${2+3}!` // "Hi\\n5!"
  ```

### 字符集（Unicode）

JavaScript 使用 Unicode 字符集。

JavaScript 引擎内部，所有字符都用 Unicode 表示。解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。

```javascript
var f\u006F\u006F = 'abc' // foo 是 Unicode 形式表示
foo // "abc" ，foo 使用字面形式表示。JavaScript 会自动识别
```

每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。UTF-16 有两种长度：

- 对于码点在 `U+0000` 到 `U+FFFF` 之间的字符，长度为 16 位（即 2 个字节），JavaScript 认为是一个字符（`length` 属性为 1）。
- 对于码点在 `U+10000` 到 `U+10FFFF` 之间的字符，长度为 32 位（即 4 个字节），JavaScript 认为是两个字符（`length` 属性为 2）。

### Base64 转码

Base64 是一种编码方法，可以将任意值转成 `0-9`、`A-Z`、`a-z`、`+` 和 `/` 64 个字符组成的可打印字符。主要用于：

- ASCII 码 0 到 31 的符号都无法打印出来，可以使用 Base64 编码
- 以文本格式传递二进制数据，可以使用 Base64 编码
- 对二进制数据进行编码，可以使用 Base64 编码

在 JavaScript 中，有两个函数被分别用来处理解码和编码 Base64 字符串：

- `btoa()`：从二进制数据 “字符串” 创建一个 Base-64 编码的 ASCII 字符串
- `atob()`：解码 Base-64 编码的字符串数据

```javascript
var string = 'Hello World!';
btoa(string) // "SGVsbG8gV29ybGQh"
atob('SGVsbG8gV29ybGQh') // "Hello World!"

btoa('你好') // 报错，不适合非 ASCII 码的字符

// 将非 ASCII 码字符转为 Base64 编码，可先进行转码

function base64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function base64Decode(str) {
  return decodeURIComponent(atob(str));
}

base64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
base64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"
```

## Symbol

### Symbol 基本使用

`Symbol(description)` 函数会返回 `symbol` 类型的值，`symbol` 值都是唯一的。

- `description` ：可选的，字符串类型。对 `symbol` 的描述，可用于调试但不是访问 `symbol` 本身。

一个 `symbol` 值能作为对象属性的标识符，这是该数据类型仅有的目的。`symbol` 不会被自动转换为字符串。

```javascript
let sym = Symbol()
typeof sym // symbol

let genericSymbol = Symbol()
let otherGenericSymbol = Symbol()
genericSymbol == otherGenericSymbol // false

let fooSymbol = Symbol('foo')
let otherFooSymbol = Symbol('foo')
fooSymbol == otherFooSymbol // false

let newSymbol = new Symbol() // TypeError: Symbol is not a constructor
```

### 全局 Symbol 注册表

使用 `Symbol()` 函数，不会在整个代码库中创建一个可用的全局的 `symbol` 类型。

创建跨文件可用的 `symbol`，使用 `Symbol.for()` 方法和 `Symbol.keyFor()` 方法从全局的 `symbol` 注册表设置和取得 `symbol`。

- `Symbol.for(key)` ：根据给定的键 `key`，来从运行时的 `symbol` 注册表中找到对应的 `symbol`，如果找到了，则返回它，否则，新建一个与该键关联的 `symbol`，并放入全局 `symbol` 注册表中。
- `Symbol.keyFor(sym)` ：用来获取全局 `symbol` 注册表中与某个 `symbol` 关联的键。

```javascript
Symbol.for("foo") // 创建一个全局 symbol 并放入 symbol 注册表中，键为 "foo"
Symbol.for("foo") // 从 symbol 注册表中读取键为 "foo" 的 symbol

Symbol.for("bar") === Symbol.for("bar") // true
Symbol("bar") === Symbol("bar") // false，Symbol() 函数每次都会返回新的一个 symbol

// 为了防止冲突，最好给要放入 symbol 注册表中的 symbol 带上键前缀
Symbol.for("mdn.foo")
Symbol.for("mdn.bar")

// ========================================
// ========================================

var globalSym = Symbol.for("foo")
Symbol.keyFor(globalSym) // "foo"

var localSym = Symbol()
Symbol.keyFor(localSym) // undefined
```

### 使用 Symbol 作为属性

凡是可以使用字符串或数值作为属性的地方，都可以使用 `Symbol`。包括：

- 对象字面量属性
- `Object.defineProperty()` / `Object.defineProperties()` 定义的属性

在对象中查找 `Symbol` 属性：

- `Object.getOwnPropertyNames()` 返回对象实例的常规属性数组
- `Object.getOwnPropertySymbols()` 返回对象实例的 `Symbol` 属性数组
- `Reflect.ownKeys()` 返回常规属性和 `Symbol` 属性数组
- `symbol` 属性不参与 `for..in` 循环

```javascript
let fooSym = Symbol('foo')
let barSym = Symbol('bar')
let bazSym = Symbol('baz')
let quxSym = Symbol('qux')

let obj = {
  [fooSym]: 'foo value',
}
// obj[fooSym] = 'foo value'

Object.defineProperty(obj, barSym, { value: 'bar value' })
Object.defineProperties(obj, {
  [bazSym]: { value: 'baz value' },
  [quxSym]: { value: 'qux value' },
})

console.log(obj)
// {Symbol(foo): 'foo value', Symbol(bar): 'bar value', Symbol(baz): 'baz value', Symbol(qux): 'qux value'}

obj['a'] = '123'

console.log(Object.getOwnPropertyNames(obj))
// ['a']
console.log(Object.getOwnPropertySymbols(obj))
// [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]
console.log(Reflect.ownKeys(obj))
// ['a', Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]
```

### Symbol 的属性

- `Symbol.asyncIterator` ：该符号指定了一个对象的默认异步迭代器。如果一个对象设置了这个属性，则是异步可迭代对象，可用于 `for await...of` 循环。

  ```javascript
  const myAsyncIterable = new Object()
  myAsyncIterable[Symbol.asyncIterator] = async function*() {
      yield "hello";
      yield "async";
      yield "iteration!";
  };

  (async () => {
      for await (const x of myAsyncIterable) {
          console.log(x);
          // expected output:
          //    "hello"
          //    "async"
          //    "iteration!"
      }
  })();
  ```

- `Symbol.prototype.description` ：返回 `Symbol` 对象的可选描述的字符串。

  ```javascript
  Symbol('desc').toString() // "Symbol(desc)"
  Symbol('desc').description // "desc"
  Symbol('').description // ""
  Symbol().description // undefined

  Symbol.iterator.toString() // "Symbol(Symbol.iterator)"
  Symbol.iterator.description // "Symbol.iterator"

  Symbol.for('foo').toString() // "Symbol(foo)"
  Symbol.for('foo').description // "foo"
  ```

- `Symbol.hasInstance` ：判断某对象是否为某构造器的实例。可用于自定义 `instanceof` 操作符在某个类上的行为。

  ```javascript
  function Foo() {}
  let f = new Foo()
  console.log(f instanceof Foo) // true
  console.log(Foo[Symbol.hasInstance](f)) // true

  // 自定义的 instanceof 行为
  class MyArray {
    static [Symbol.hasInstance](instance) {
      return Array.isArray(instance)
    }
  }
  console.log([] instanceof MyArray) // true
  console.log(MyArray[Symbol.hasInstance]([])) // true
  ```

- `Symbol.isConcatSpreadable` ：内置的 `Symbol.isConcatSpreadable` 符号，用于配置某对象作为 `Array.prototype.concat()` 方法的参数时，是否展开其数组元素。

  - 对于数组对象，默认情况下，使用 `concat` 时，会按数组元素展开，然后进行连接（数组元素作为新数组的元素）。重置 `Symbol.isConcatSpreadable` 可以改变默认行为。
  - 对于类似数组的对象，使用 `concat` 时，该对象整体作为新数组的元素，重置 `Symbol.isConcatSpreadable` 可改变默认行为。

  ```javascript
  let alpha = ['a', 'b', 'c']
  let numeric = [1, 2, 3]

  let alphaNumeric = alpha.concat(numeric)
  console.log(alphaNumeric) // ['a', 'b', 'c', 1, 2, 3]

  // 设置 Symbol.isConcatSpreadable 为 false
  // 不展开数组元素进行连接
  numeric[Symbol.isConcatSpreadable] = false
  alphaNumeric = alpha.concat(numeric)
  console.log(alphaNumeric) // ['a', 'b', 'c', Array(3)]

  let fakeArray = {
    length: 2,
    0: 'hello',
    1: 'world',
  }

  // 对于类数组 (array-like) 对象，默认不展开
  // 设置 Symbol.isConcatSpreadable 为 true，展开其元素用于连接
  let alphFakeArray = alpha.concat(fakeArray)
  console.log(alphFakeArray) //  ['a', 'b', 'c', 'hello', 'world']
  ```

- `Symbol.iterator` ：为每一个对象定义了默认的迭代器。可以被 `for...of` 循环使用。

  `for...of` 循环会利用该函数执行迭代操作。循环时，会调用以 `Symbol.iterator` 为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。

  ```javascript
  class Emitter {
    constructor(max) {
      this.max = max
      this.idx = 0
    }
    *[Symbol.iterator]() {
      while (this.idx < this.max) {
        yield this.idx++
      }
    }
  }

  let emitter = new Emitter(5)
  for (const key of emitter) {
    console.log(key)
  }
  // 0 1 2 3 4
  ```

- `Symbol.match` ：指定了匹配的是正则表达式而不是字符串。`String.prototype.match()` 方法会调用此函数。

  `String.prototype.match()` 方法会使用以 `Symbol.match` 为键的函数来对正则表达式求值。

  ```javascript
  console.log(RegExp.prototype[Symbol.match]) // ƒ [Symbol.match]() { [native code] }
  console.log('foobar'.match(/bar/)) // [ 'bar', index: 3, input: 'foobar', groups: undefined ]

  class StringMatcher {
    constructor(str) {
      this.str = str
    }

    [Symbol.match](target) {
      return target.includes(this.str)
    }
  }
  console.log('foobar'.match(new StringMatcher('foo'))) // true
  ```

  `String.prototype.startsWith()`，`String.prototype.endsWith()` 和 `String.prototype.includes()` 会检查其第一个参数是否是正则表达式，是正则表达式就抛出一个 `TypeError`。如果设置 `Symbol.match` 为 false（或者一个假值），表示该对象不打算用作正则表达式对象。

  ```javascript
  let fooRegExp = /foo/
  fooRegExp[Symbol.match] = false

  console.log('/foo/'.startsWith(fooRegExp)) // true
  console.log('/baz/'.endsWith(fooRegExp)) // false
  ```

- `Symbol.matchAll` ：指定方法返回一个迭代器，根据字符串生成正则表达式的匹配项。可以被 `String.prototype.matchAll()` 方法调用。

  ```javascript
  const str = '2016-01-02|2019-03-07'
  const numbers = {
    *[Symbol.matchAll](str) {
      for (const n of str.matchAll(/[0-9]+/g)) yield n[0]
    },
  }
  console.log(Array.from(str.matchAll(numbers)))
  // ["2016", "01", "02", "2019", "03", "07"]
  ```

- `Symbol.replace` ：指定了当一个字符串替换所匹配字符串时所调用的方法。可以被 `String.prototype.replace()` 方法会调用此方法。

  ```javascript
  console.log(RegExp.prototype[Symbol.replace]) // ƒ [Symbol.replace]() { [native code] }
  console.log('foobarbaz'.replace(/bar/, 'qux')) // fooquxbaz

  class StringReplacer {
    constructor(str) {
      this.str = str
    }
    [Symbol.replace](target, replacement) {
      return target.split(this.str).join(replacement)
    }
  }
  console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux')) // barquxbaz
  ```

- `Symbol.search` ：指定了一个搜索方法，接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标。可以被 `String.prototype.search()` 调用。

  ```javascript
  console.log(RegExp.prototype[Symbol.search]) // ƒ [Symbol.search]() { [native code] }
  console.log('foobar'.search(/bar/)) // 3

  class StringSearcher {
    constructor(str) {
      this.str = str
    }

    [Symbol.search](target) {
      return target.indexOf(this.str)
    }
  }
  console.log('foobar'.search(new StringSearcher('foo')))
  ```

- `Symbol.species` ：函数值属性，其被构造函数用以创建派生对象。

  在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。

  用 `Symbol.species` 定义静态的获取器（`getter`）方法，可以覆盖新创建实例的原型定义。

  ```javascript
  class Bar extends Array {}
  class Baz extends Array {
    static get [Symbol.species]() {
      return Array
    }
  }

  let bar = new Bar()
  console.log(bar instanceof Array) // true
  console.log(bar instanceof Bar) // true

  bar = bar.concat('bar')
  console.log(bar instanceof Array) // true
  console.log(bar instanceof Bar) // true

  let baz = new Baz()
  console.log(baz instanceof Array) // true
  console.log(baz instanceof Baz) // true

  baz = baz.concat('baz')
  console.log(baz instanceof Array) // true
  console.log(baz instanceof Baz) // false
  ```

- `Symbol.split` ：指向一个正则表达式的索引处分割字符串的方法。可以被 `String.prototype.split()` 调用。

  `String.prototype.split()` 方法会使用以 `Symbol.split` 为键的函数来对正则表达式求值。

  ```javascript
  console.log(RegExp.prototype[Symbol.split]) // ƒ [Symbol.split]() { [native code] }
  console.log('foobarbaz'.split(/bar/)) // ['foo', 'baz']

  var regExpObj = {
    pat: 'in',
    [Symbol.split](str) {
      return str.split(this.pat)
    },
  }
  'dayinlove'.split(regExpObj) // ["day", "love"]

  class StringSplitter {
    constructor(str) {
      this.str = str
    }
    [Symbol.split](target) {
      return target.split(this.str)
    }
  }
  console.log('barfoobaz'.split(new StringSplitter('foo'))) // ["bar", "baz"]
  ```

- `Symbol.toPrimitive` ：内置的 `symbol` 属性，其指定了一种接受首选类型并返回对象原始值的表示的方法。它被所有的强类型转换制算法优先调用。

  很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。

  对于一个自定义对象实例，通过在该实例的 `Symbol.toPrimitive` 属性上定义一个函数可以改变默认行为。

  ```javascript
  const obj1 = {}
  console.log(+obj1) // NaN
  console.log(`${obj1}`) // [object Object]
  console.log(obj1 + '') // [object Object]

  // 声明一个对象，手动赋予了 Symbol.toPrimitive 属性
  const obj2 = {
    // hint 表示要转换到的原始值的预期类型
    // hint 参数的取值是 "number"、"string" 和 "default" 中的任意一个
    // > "number" hint 用于强制【数字类型】转换算法
    // > "string" hint 用于强制【字符串类型】转换算法
    // > "default" hint 用于强制【原始值】转换算法
    [Symbol.toPrimitive](hint) {
      if (hint === 'number') {
        return 10
      }
      if (hint === 'string') {
        return 'hello'
      }
      return true
    },
  }
  console.log(+obj2) // 10 — hint 参数值是 "number"
  console.log(`${obj2}`) // hello — hint 参数值是 "string"
  console.log(obj2 + '') // true — hint 参数值是 "default"
  ```

  没有 `@@toPrimitive` 属性的对象通过以不同的顺序调用 `valueOf()` 和 `toString()` 方法将其转换为原始值。`@@toPrimitive` 允许完全控制原始转换过程。

- `Symbol.toStringTag` ：内置通用（well-known）`symbol` 是一个字符串值属性，用于创建对象的默认字符串描述。由 `Object.prototype.toString()` 方法内部访问。

  ```javascript
  Object.prototype.toString.call(undefined) // '[object Undefined]'
  Object.prototype.toString.call(null) // '[object Null]'
  Object.prototype.toString.call(true) // '[object Boolean]'
  Object.prototype.toString.call(3.14) // '[object Number]'
  Object.prototype.toString.call('str') // '[object String]'
  Object.prototype.toString.call({ a: 100 }) // '[object Object]'
  Object.prototype.toString.call([1, 2, 3]) // '[object Array]'
  Object.prototype.toString.call(function () {}) // '[object Function]'
  Object.prototype.toString.call(new Map()) // '[object Map]'
  Object.prototype.toString.call(new Set()) // '[object Set]'
  Object.prototype.toString.call(function* () {}) // '[object GeneratorFunction]'
  Object.prototype.toString.call(Promise.resolve()) // '[object Promise]'
  Object.prototype.toString.call(new Date()) // '[object Date]'
  Object.prototype.toString.call(/regex/) // '[object RegExp]'

  class ValidatorClass {
    get [Symbol.toStringTag]() {
      return 'Validator'
    }
  }
  Object.prototype.toString.call(new ValidatorClass()) // "[object Validator]"

  const buttonDom = document.createElement('button');
  console.log(buttonDom.toString()); // "[object HTMLButtonElement]"
  console.log(buttonDom[Symbol.toStringTag]);  // HTMLButtonElement
  ```

- `Symbol.unscopables` ：用于指定对象值，其对象自身和继承的从关联对象的 `with` 环境绑定中排除的属性名称。

  设置该符号并让其映射对应属性的键值为 `true`，可以阻止该属性出现在 `with` 环境绑定中。

  不推荐使用 `with`，因此也不推荐使用 `Symbol.unscopables`。

  ```javascript
  let o = { foo: 'bar' }

  with (o) {
    console.log(foo) // bar
  }

  o[Symbol.unscopables] = {
    foo: true,
  }

  with (o) {
    console.log(foo) // ceError: foo is not defined
  }
  ```

### Symbol 方法

- `Symbol.prototype[@@toPrimitive]` ：可将 `Symbol` 对象转换为原始值。

  `Symbol()[Symbol.toPrimitive](hint)` 指定的 `Symbol` 对象的原始值。

  `hint` 参数未使用时，`Symbol` 的 `[@@toPrimitive]()` 方法返回 `Symbol` 对象的原始值作为数据类型返回。

  ```javascript
  const sym = Symbol("example");
  sym === sym[Symbol.toPrimitive](); // true
  ```

- `Symbol.for(key)` ：根据给定的键 `key`，来从运行时的 `symbol` 注册表中找到对应的 `symbol`，如果找到了，则返回它，否则，新建一个与该键关联的 `symbol`，并放入全局 `symbol` 注册表中。

  ```javascript
  Symbol.for("foo") // 创建一个全局 symbol 并放入 symbol 注册表中，键为 "foo"
  Symbol.for("foo") // 从 symbol 注册表中读取键为 "foo" 的 symbol

  Symbol.for("bar") === Symbol.for("bar") // true
  Symbol("bar") === Symbol("bar") // false，Symbol() 函数每次都会返回新的一个 symbol

  // 为了防止冲突，最好给要放入 symbol 注册表中的 symbol 带上键前缀
  Symbol.for("mdn.foo")
  Symbol.for("mdn.bar")
  ```

- `Symbol.keyFor(sym)` ：用来获取全局 `symbol` 注册表中与某个 `symbol` 关联的键。

  ```javascript
  var globalSym = Symbol.for("foo")
  Symbol.keyFor(globalSym) // "foo"

  var localSym = Symbol()
  Symbol.keyFor(localSym) // undefined
  ```

- `Symbol.prototype.toString()` ：返回当前 symbol 对象的字符串表示

  `Symbol` 对象拥有自己的 `toString` 方法，因而遮蔽了原型链上的 `Object.prototype.toString()`。

  ```javascript
  // symbol 原始值不能转换为字符串，所以只能先转换成它的包装对象，再调用 toString() 方法
  Symbol('foo') + 'bar' // TypeError: Cannot convert a Symbol value to a string

  Symbol('foo').toString() + 'bar' // "Symbol(foo)bar"
  Object(Symbol('foo')).toString() + 'bar' // "Symbol(foo)bar"

  Symbol('desc').toString() // "Symbol(desc)"
  // 内置通用（well-known）symbol
  Symbol.iterator.toString() // "Symbol(Symbol.iterator)
  // global symbols
  Symbol.for('foo').toString() // "Symbol(foo)"
  ```

- `Symbol.prototype.valueOf()` ：返回当前 `symbol` 对象所包含的 `symbol` 原始值。

  ```javascript
  Object(Symbol('foo')) + 'bar'
  // TypeError: Cannot convert a Symbol value to a string
  // 无法隐式的调用 valueOf() 方法

  Object(Symbol('foo')).valueOf() + 'bar'
  // TypeError: Cannot convert a Symbol value to a string
  // 手动调用 valueOf() 方法，虽然转换成了原始值，但 symbol 原始值不能转换为字符串

  Object(Symbol('foo')).toString() + 'bar'
  // "Symbol(foo)bar"，需要手动调用 toString() 方法才行
  ```
