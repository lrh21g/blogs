# 密码

## 加密

加密是为了提升数据的安全性。

加密三要素：

- 数据：明文/密文
- 密钥：定长的字符串，根据加密算法确定其长度。
- 算法：加密算法/解密算法，加解密算法可能相同也可能不同

简单加密算法

- 异或，示例如下：

  - 数据：123
  - 密钥: 666
  - 算法: 异或
  - 加密过程: 123 ^ 666 = 737
  - 解密过程: 737 ^ 666 = 123

- 凯撒加密。将字母按顺序推后起3位起到加密作用。

## 常用加密方式

- 对称加密
  - 加解密使用同一密钥
  - 密钥绝对不能公开（密钥分发困难）
  - 特点：
    - 双向机密性保证
    - 加密效率高
    - 相对于非对称加密强度不高
- 非对称加密
  - 加解密使用不同的密钥（密钥分发容易）
    - 公钥：可以公开的密钥
    - 私钥：不可以公开的密钥
    - 公钥加密，私钥解密（加密）
    - 私钥加密，公钥验证（签名）
  - 特定：
    - 单向机密性保证
    - 加密效率低
    - 相对于对称加密强度更高
- 对称加密与非对称加密
  - 两者之间是互补关系
  - 对称加密的优点就是非对称加密的缺点，非对称加密的优点就是对称加密的缺点
  - 实际开发中，一般两者会结合使用

## 对称加密

对称加密基本概念

- DES、3DES、AES
- 加密 --> 编码（Encoding） --> 二进制
- 解密 --> 解码（Decoding） --> 明文

### DES

[DES](https://baike.baidu.com/item/DES/210508) 全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。DES方式加密的数据并不安全。

DES加解密

- DES是一种将64比特位（8个字节）明文加密成64位比特位密文的对称加密算法
- DES要求密钥长度是56比特位，但是每隔7位会设置一个用于错误检查的比特位，所以DES密钥的长度为64比特位
- DES不会一次将数据全部加密，而是会按照64比特位一组进行分组后再加密

### 3DES

3DES 是三重 DES 加密，称之为 3DES。3DES 方式加密的数据是安全的，但是需要建立在第二个8位密钥与第一个8位密钥不同的前提下。3DES 的加密效率低。

3DED加解密

- 3DES 是基于 DES 的，但是由于需要加密3次，所以密文长度是 DES 的3倍
- 加密过程：加密 --> 解密 --> 加密 --> 密文
- 解密过程：解密 --> 加密 --> 解密 --> 明文

3DES 加密过程中进行解密是为了兼容 DES ，需要控制密钥，如果密钥相同，相当于只进行了一次 DES 加密。示例如下：

- 数据： 12345678
- 密钥： 1111111 12345678 87654321
- 加密过程
  - 12345678 + 11111111 = 23456789
  - 23456789 - 12345678 = 11111111
  - 12345678 + 87654321 = 98765432
- 解密过程
  - 98765432 - 11111111 = 87654321
  - 87654321 + 12345678 = 99999999
  - 99999999 - 87654321 = 12345678

### AES

高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种数据块加密标准。Rijndael的分组长度为 128 比特位（16字节）,密钥长度可以以 32 比特位单位在 128 比特位、256 比特位的范围内进行选择（不过在AES标准中，密钥长度只有 128、192、256 三种）

AES 方式加密的数据安全，会进行 10 - 14 次加密计算。AES会对数据进行分组，按照 128 比特位一组进行分组后加密。

DES 与 AES 的区别

- DES 不安全，AES 安全
- 对原始数据分组的长度不同。DES 以 8 个字节为一组，AES 以 16 个字节为一组
- 对密钥长度的要求不同。DES 要求 8 个字节，AES 可以是 16 个、24 个、32个字节

## 加密分组模式

DES、3DES、AES 都会对数据进行分组，分组之后，在分组数据和密钥进行运算的时候，分为五种不同的运算模式

- ECB(Electronic Codebook) - 电子密码本模式
- CBC(Cipher-Block Chaining) - 密码块链模式
- CFB(Cipher Feedback) - 密文反馈模式
- OFB(Output Feedback) - 输出反馈模式
- CTR(CountTeR) - 计数器模式

### ECB(Electronic Codebook) - 电子密码本模式

- ECB电子密码本模式是最简单的加密模式，将明文消息分为固定大小的块（组）之后，对每个块单独加密（每个块的加密和解密都是独立的），且使用相同的方法进行加密。
- 由于每个块都是相同的方法进行加密，所以一旦一个块被破解，那么所有块都会被破解
- ECB模式规定对原始数据分组之后的每一块数组必须都是8位才能加密，所以如果分组之后一组数据不足8位（加密方式有DES/3DES/AES(16位)），则需要手动填充达到8位才能进行加密

特点：

- 简单高效，密文有规律，容易被破解
- 最后一个明文分组需要被填充，DES/3DES 最后一个分组需要被填充满 8 字节，AES 在 golang 中最后一个分组需要被填充满 16 字节

### CBC(Cipher-Block Chaining) - 密码块链模式

- CBC密码块链模式中每一个分组要先和前一个分组加密后的数据进行异或操作，然后在进行加密
- 由于后一个分组加密依赖于前一个分组，但是第一个分组并没有前一分组，需要手动指定一个初始化向量，用于和第一组进行异或操作。由于第一组数据加密之后的数据都是8位，所以初始化向量也必须是8位

特点：

- 密文无规律，不容易被破解，无规律
- 最后一个明文分组需要被填充，DES/3DES 最后一个分组需要被填充满 8 字节，AES 在 golang 中最后一个分组需要被填充满 16 字节
- 需要初始化向量
  - 长度：与明文分组相等
  - 来源：负责加密的人提供
  - 注意：加解密初始化向量必需一致

### CFB(Cipher Feedback) - 密文反馈模式

- CFB密文反馈模式中，会先对前一个分组密文进行加密，然后再和当前分组进行按位异或
- 由于后一个分组加密依赖于前一个分组，但是第一个分组并没有前一分组，需要手动指定一个长度和分组一样的初始化向量
- 注意：ECB和CBC需要对分组进行填充，但是其他模式都不需要对分组进行填充

特点：

- 密文无规律，不容易被破解，常用
- 最后一个明文分组不需要被填充
- 需要初始化向量
  - 长度：与明文分组相等
  - 来源：负责加密的人提供
  - 注意：加解密初始化向量必需一致

### OFB(Output Feedback) - 输出反馈模式

- OFB输出反馈模式中，需要先对前一个分组密钥进行加密，然后再和当前分组进行按位异或
- 由于后一个分组加密依赖于前一个分组，但是第一个分组并没有前一分组，需要手动指定一个长度和分组一样的初始化向量
- 和 CFB 区别在按位异或的数据来源不一样

特点：

- 密文无规律，不容易被破解，常用
- 最后一个明文分组不需要被填充
- 需要初始化向量
  - 长度：与明文分组相等
  - 来源：负责加密的人提供
  - 注意：加解密初始化向量必需一致

### CTR(CountTeR) - 计数器模式

- CTR计数器模式内部定义了一个计数器，和内部生成的随机数组合成一个密钥，每一组的随机数都是相同的，不同的是计数器保存的值。
- CTR计数器模式会先对生成的密钥进行加密，然后在和当前分组进行按位异或
- 和 CFB 的区别在于按位异或的数据来源不一样

特点：

- 密文无规律，不容易被破解，常用
- 最后一个明文分组不需要被填充
- 不需要初始化向量

### 明文分组填充与填充解密问题

明文分组填充

- 分组数据填充和加密算法没有关系，和加密算法使用的分组模式有关
- DES/3DES/AES加密算法使用 ECB/CBC 分组模式需要填充
- DES/3DES/AES加密算法使用非 ECB/CBC 分组模式不需要填充

填充解密

- 如果加密时对分组数据进行了填充，那么解密后就需要删除填充的数据才能得到原始数据
- 为了方便解密后删除填充数据，一般情况下，需要填充几个字节就会将每个字节的值设置为填充的个数。读取最后一个字节的值，删除对应位数即可
- 为了方便统一处理，对不需要填充的数据，可以填充一组数据，方便后续统一删除处理

## 单向散列函数

单向散列函数，又称单向 Hash 函数、杂凑函数、消息摘要函数。是一种可以把“任意长度数据”转换成“固定长度数据”的一种函数。在单向散列函数中，输入的数据称为原像，输出的数据称为散列值/哈希值/指纹/消息摘要。

常见的单向散列函数：MD4/MD5、SHA-1、SHA-2

单向散列函数特点：

- 任意长度的消息计算出固定长度的散列值
- 消息不同，散列值不同
- 抗碰撞性强，不可逆

单向散列函数应用场景

- 秒传
  - 在服务器上，计算每个文件的散列值，存储文件的时候，将对应的散列值进行存储
  - 当用户上传文件时，会计算文件上传的散列值，然后在服务器上查找是否存在相同的散列值
    - 如果存在相同的散列值，则在服务器上存在相同的文件，实现秒传
    - 如果不存在相同的散列值，则需要慢慢的进行上传
- 数据验证
  - 相同数据利用相同的单向散列函数计算的结果是一致的
- ......

### MD4

MD4是麻省理工学院教授Ronald Rivest于1990年设计的一种信息摘要算法。它是一种用来测试信息完整性的密码散列函数的实行。其摘要长度为128位，一般128位长的MD4散列被表示为32位的十六进制数字。这个算法影响了后来的算法如MD5、SHA 家族和RIPEMD等。

MD4不安全，不推荐使用

### MD5

MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。

MD5不安全，不推荐直接使用，推荐加盐后使用

注意：加盐加密是一种对系统登录口令的加密方式，它实现的方式是将每一个口令跟一个n位随机数相关联，这个n位随机数叫做”盐“（salt）。

实际应用场景：

- 用户注册
  - 用户输入【账号】和【密码】：lrh / 123456
  - 系统为用户生成【salt值】（盐）: aaabbb
  - 系统将【salt值】和【用户密码】连接在一起: aaa123456bbb
  - 对连接后的值进行散列，得到【Hash】值: fdasfdsaf
  - 将【Hash值1】和【salt值】分别放在数据库中: fdasfdsaf / aaabbb
- 用户登录
  - 用户输入【账号】和【密码】：lrh / 123456
  - 系统通过用户名找到对应的【Hash值1】和【salt值】: fdasfdsaf / aaabbb
  - 系统将【salt值】和【用户输入的密码】连接到一起: aaa123456bbb
  - 对连接后的值进行散列，得到【Hash值2】: fdasfdsaf
  - 比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误

### SHA-1

SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。

不同意MD5，SHA-1的消息存在长度上限，不能超过 2 的 64 次方。SHA-1 所产生的摘要比 MD5 长 32 位，若两种散列函数在结构上没有任何问题的话，SHA-1 比 MD5 更安全

SHA-1 并不安全，不推荐使用，在 2005 年被攻破。

### SHA-2 (SHA-224、SHA-256、SHA-384、SHA-512)

SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，由美国国家标准与技术研究院（NIST）在2001年发布。属于SHA算法之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。可以生成一个固定大小的单向散列值。

SHA-2的消息存在长度上限，SHA-256 上限不能超过 2 的 64 次方，SHA-384、SHA-512上限不能超过 2 的 128 次方

SHA-2 产生散列值的长度

- SHA-224 = 224 / 8 = 28 字节
- SHA-256 = 256 / 8 = 32 字节
- SHA-384 = 384 / 8 = 48 字节
- SHA-512 = 512 / 8 = 64 字节

## 非对称加密

对接加密存在密钥分发困难，而非对称加密存在两个密钥：公钥进行加密并可以公开，只能使用私钥进行解密，加密效率低。

使用非对称加密方式分发密钥，可以解决对称加密密钥分发困难的问题。示例如下：A分发对称加密密钥给B

- B 生成非对称加密密钥
- B 将公钥分发给 A
- A 通过公钥加密之后，分发对称加密密钥给 B
- B 通过私钥解密之后，拿到对称加密密钥
- A 和 B 通过对称加密密钥进行通信

### 常见非对称加密

- RSA非对称加密
- ECC椭圆曲线非对称加密

### RSA 非对称加密

RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的

RSA 加密运算公式

- 密文 = 明文 ^ E % N
- 明文的 E 次方，取模 N 之后得到的余数就是密文
- 所以只要知道 E 和 N ，任何人都可进行 RSA 加密，这里的 E（Encryption）、N（Number）就是 RSA 加密的密钥，也就是说 E 和 N 的组合就是公钥，使用 (E, N) 表示公钥。
- 注意：E、N是通过严密的计算得出的

RSA 解密运算公式

- 明文 = 密文 ^ D % N
- 密文的 D 次方，取模 N 之后得到的余数就是明文
- 所以只需要知道 D 和 N ，任何人都可以进行 RSA 解密，这里的 D（Decryption）、N（Number）就是 RSA 解密的密钥，也就是说 D 和 N 的组合就是私钥，使用 (D, N) 表示公钥
- 注意： D、N 是通过严密的计算得出的，并且解密公式中的 N 和加密公式中 N 是同一个数

### ECC椭圆曲线 非对称加密

椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。

和 RSA 一样，椭圆曲线算法也是一种非对称加密算法，比 RSA 效率更高

## 消息认证码

消息认证码（message authentication code）是一种确认数据完整性的技术。

- 数据完整性：确保数据没有被篡改
- 机密性：保障不被其他人知道

由于单向散列函数的值，只要数据和散列函数相同，计算结果就会相同，只要数据发生改变，无论散列函数是否相同，计算结果都会不同，所以可以通过单向散列值作为认证码

示例： A 发送消息给 B

- A 和 B 之间共享一个密钥（对长度没有任何限制）
- A 利用消息和密钥生成对应散列值（原始消息 + 密钥） \* 散列函数 = 散列值
- A 将原始消息和散列值一起发送给 B
- B 利用接受到的原始消息和密钥生成对应散列值（原始消息 + 密钥） \* 散列函数 = 散列值
- B 利用自己生成的散列值和 A 发送的散列值进行比对

## 数字签名

消息认证码的弊端：密码分发困难，没有第三方证明，不能防止反悔

数字签名，只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时是对信息的发送者发送信息真实性的一个有效证明。数字签名是非对称密钥加密技术与数字摘要技术的应用。

数字签名的签名和验证步骤

- A 发送消息给 B
  - A 生成公钥和私钥
  - A 将公钥分发出去
  - A 计算原始消息散列值
  - A 利用私钥对散列值进行加密
  - A 将原始数据和加密后的散列值传递给 B
  - B 接受原始数据和加密后的散列值
  - B 利用公钥解密加密后的散列值
  - B 计算原始消息散列值
  - B 用自己计算的散列值和解密的散列值进行比对

## CA证书

数字签名分发公钥的时候可能被拦截，可通过权威机构进行分发。

借助权威机构分发公钥的步骤：假设 A 给 B 发送消息

- A 生成公钥和私钥
- A 通过权威机构证明公钥是 A 的
- A 将公钥交给权威机构
- 权威机构再生成一对公钥和私钥
- 权威机构用自己的私钥对 A 提供的公钥进行加密，生成一个证书
  - 证书中会写明公钥属于谁，有效期等相关信息
  - 权威机构将生成的证书发给 A
- A 将证书分发给 B
- B 拿到证书后通知权威机构提供的公钥对证书进行验证
  - B 用于验证的公钥是操作系统预装或者自己手动安装的
- B 使用权威机构提供的公钥对证书进行解密，拿到 A 分发的公钥

CA是证书的签发机构，它是公钥基础设施（Public Key Infrastructure，PKI）的核心。CA是负责签发证书、认证证书、管理已颁发证书的机关。

CA证书：权威机构颁发的证书统称为 CA 证书。证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。证书的格式和验证方法普遍遵循X.509 国际标准。

## HTTP/HTTPS

- HTTP: 超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。默认不加密的传输
- HTTPS：超文本传输安全协议（全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。默认加密的传输，HTTPS = HTTP + SSL/TLS
- SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。Secure Socket Layer，为Netscape所研发，用以保障在Internet上数据传输的安全，利用数据加密(Encryption)技术，可确保数据在网络上的传输过程中不会被截取及窃听。
- TSL：传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。

HTTPS传输前的准备

- 服务器生成公钥和私钥
- 服务器将公钥交给CA
- CA利用服务器传递过来的公钥生成证书
  - CA自己生成一对公钥和私钥
  - CA利用私钥对服务器传递过来的公钥进行加密
- CA将证书发给服务器
- 服务器将公钥/私钥/证书存储到服务器上

HTTPS传输数据的流程

- 浏览器给服务器发送一个请求
- 服务器将证书交给浏览器
- 浏览器验证证书是否合法（不合法则自动弹出提示用户）
- 浏览器利用权威机构公钥解密得到服务器的公钥
- 浏览器随机生成一个密钥（用于对称加密）
- 浏览器利用服务器的公钥加密随机生成的密钥
- 浏览器将加密后的密钥发送给服务器
- 服务器利用自己的私钥解密得到密钥
- 浏览器与服务器使用密钥进行通信

HTTPS 的特点：由于流程比HTTP复杂，所以传输效率低于HTTP，安全性高于HTTP
