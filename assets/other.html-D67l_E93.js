import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as s,o as a}from"./app-CsEj30Cd.js";const o={};function n(d,e){return a(),i("div",null,[...e[0]||(e[0]=[s(`<h1 id="其他类型" tabindex="-1"><a class="header-anchor" href="#其他类型"><span>其他类型</span></a></h1><h2 id="text-类型" tabindex="-1"><a class="header-anchor" href="#text-类型"><span>Text 类型</span></a></h2><p><code>Text</code> 文本节点表示文本内容，代表 <code>Element</code> 元素节点和 <code>Attribute</code> 属性节点的文本内容。如果一个节点只包含一段文本，该节点就有一个文本子节点，表示该文本内容。</p><p>空格也会形成文本节点，比如 <code>&lt;p&gt;&lt;/p&gt;</code> 包含一个空格，其子节点就是一个文本节点。</p><p>Text 继承链路： <code>EventTarget &lt;-- Node &lt;-- CharacterData &lt;-- Text</code> 。</p><p>可以使用 <code>new Text()</code> 构造函数创建 <code>Text</code> 对象，该对象带有可选参数 <code>DOMString</code> 作为文本节点的文本内容。</p><h3 id="text-类型属性" tabindex="-1"><a class="header-anchor" href="#text-类型属性"><span>Text 类型属性</span></a></h3><ul><li><p><code>text.data</code> ： 获取或设置文本节点的文本内容。等同于 <code>nodeValue</code> 属性。</p></li><li><p><code>text.wholeText</code> ： 只读属性。返回文本节点及其所有兄弟节点的文本内容。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;p id=&quot;para&quot;&gt;A &lt;em&gt;B&lt;/em&gt; C&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> paraDOM</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getElementById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;para&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">paraDOM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">firstChild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">wholeText</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &#39;A &#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">paraDOM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">firstChild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &#39;A &#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;p id=&quot;para&quot;&gt;A C&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> paraDOM</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getElementById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;para&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;p&gt; 节点下包含两个毗邻的文本节点，所以 wholeText 属性返回两个文本节点的文本内容</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">paraDOM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">firstChild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">wholeText</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &#39;A C&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">paraDOM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">firstChild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // &#39;A &#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>text.length</code> ： 获取文本节点的文本内容长度。</p></li><li><p><code>text.nextSibling</code> ： 获取文本节点的下一个兄弟节点。如果未获取到，返回 <code>null</code> 。</p></li><li><p><code>text.previousSibling</code> ： 获取文本节点的上一个兄弟节点。如果未获取到，返回 <code>null</code> 。</p></li></ul><h3 id="text-类型方法" tabindex="-1"><a class="header-anchor" href="#text-类型方法"><span>Text 类型方法</span></a></h3><ul><li><p><code>text.appendData()</code></p><p><strong>语法</strong> ： <code>text.appendData(text)</code></p><p><strong>描述</strong> ： 在文本节点的末尾添加文本内容。</p></li><li><p><code>text.deleteData()</code></p><p><strong>语法</strong> ： <code>text.deleteData(offset, count)</code></p><p><strong>描述</strong> ： 删除文本节点中文本内容。从 <code>offset</code> 位置开始，删除 <code>count</code> 个字符。</p></li><li><p><code>text.insertData()</code></p><p><strong>语法</strong> ： <code>text.insertData(offset, text)</code></p><p><strong>描述</strong> ： 在文本节点中插入文本内容。从 <code>offset</code> 位置开始，插入文本内容 <code>text</code> 。</p></li><li><p><code>text.replaceData()</code></p><p><strong>语法</strong> ： <code>text.replaceData(offset, count, text)</code></p><p><strong>描述</strong> ： 替换文本节点中的文本内容。从 <code>offset</code> 位置开始，删除 <code>count</code> 个字符，然后插入文本内容 <code>text</code> 。</p></li><li><p><code>text.subStringData()</code></p><p><strong>语法</strong> ： <code>text.subStringData(offset, count)</code></p><p><strong>描述</strong> ： 获取文本节点中的文本内容。返回文本节点中从 <code>offset</code> 位置开始，长度为 <code>count</code> 的子字符串。</p></li><li><p><code>text.remove()</code></p><p><strong>语法</strong> ： <code>text.remove()</code></p><p><strong>描述</strong> ： 从文档树中移除文本节点。</p></li><li><p><code>text.splitText()</code></p><p><strong>语法</strong> ： <code>text.splitText(offset)</code></p><p><strong>描述</strong> ： 将文本节点从 <code>offset</code> 位置（从零开始）分割成两个文本节点。返回分割后的第二个文本节点。如果分割位置不存在，则会报错。</p></li></ul><h2 id="documentfragment-类型" tabindex="-1"><a class="header-anchor" href="#documentfragment-类型"><span>DocumentFragment 类型</span></a></h2><p><code>DocumentFragment</code> 文档片段接口，表示一个没有父对象的最小文档对象。可以插入任意数量的子节点。其不属于当前文档，操作 <code>DocumentFragment</code> 对象不会引起文档的重绘，比直接操作 DOM 树快。</p><p><code>DocumentFragment</code> 继承链路： <code>EventTarget &lt;-- Node &lt;-- DocumentFragment</code> 。</p><p>可以使用 <code>new DocumentFragment()</code> 构造函数创建一个空的 <code>DocumentFragment</code> 对象节点，然后在使用其他 DOM 方法，向其添加子节点。</p><ul><li><p><code>DocumentFragment</code> 节点本身不能被插入当前文档，当作为 DOM 方法的参数，插入当前文档时，是所有子节点被插入当前文档，而不是自身。</p></li><li><p><code>DocumentFragment</code> 节点的子节点被插入当前文档后，自身会变成空节点（<code>textContent</code> 属性为空字符串），可以被再次使用。如需保存 <code>DocumentFragment</code> 节点内容，可以使用 <code>cloneNode</code> 方法。</p></li></ul><p><code>DocumentFragment</code> 节点对象没有属性和方法，全部继承自 <code>Node</code> 节点。 <code>DocumentFragment</code> 节点比 <code>Node</code> 节点多出以下四个属性：</p><ul><li><p><code>DocumentFragment.children</code> ： 只读属性。返回动态的 <code>HTMLCollection</code> 集合对象，包含 <code>DocumentFragment</code> 对象的所有子元素节点。</p></li><li><p><code>DocumentFragment.firstElementChild</code> ： 只读属性。返回 <code>DocumentFragment</code> 对象的第一个子元素节点。如果没有，则返回 <code>null</code> 。</p></li><li><p><code>DocumentFragment.lastElementChild</code> ： 只读属性。返回 <code>DocumentFragment</code> 对象的最后一个子元素节点。如果没有，则返回 <code>null</code> 。</p></li><li><p><code>DocumentFragment.childElementCount</code> ： 只读属性。返回 <code>DocumentFragment</code> 对象的子元素节点数量。</p></li></ul><h2 id="attr-类型" tabindex="-1"><a class="header-anchor" href="#attr-类型"><span>Attr 类型</span></a></h2><p><code>Attr</code> 类型使用对象表示 DOM 元素的属性。</p><p>在 DOM 方法中，可以直接通过字符串的方式获取属性值（例如，<code>element.getAttribute()</code>），使用函数（例如，<code>element.getAttributeNode()</code>）或迭代器访问是，则返回 <code>Attr</code> 类型。</p><p><code>Attr</code> 继承链路： <code>EventTarget &lt;-- Node &lt;-- Attr</code> 。</p><h2 id="comment-类型" tabindex="-1"><a class="header-anchor" href="#comment-类型"><span>Comment 类型</span></a></h2><p><code>Comment</code> 类型表示注释节点。</p><p>在 HTML 和 XML 里，注释（Comments）为 <code>&lt;!--</code> 和 <code>--&gt;</code> 之间的内容。在 XML 里，注释中不能出现字符序列 <code>--</code>。</p><p><code>Comment</code> 类型没有特定的属性，但是从其父类 <code>CharacterData</code> 继承属性，以及间接从 <code>Node</code> 继承部分属性。</p><p>可以使用 <code>new Comment()</code> 构造函数创建 <code>Comment</code> 对象，该对象以可选的 <code>DOMString</code> 参数作为它的文本内容。</p><h2 id="cdatasection-类型" tabindex="-1"><a class="header-anchor" href="#cdatasection-类型"><span>CDATASection 类型</span></a></h2><p><code>CDATASection</code> 接口用于表示 <code>CDATA</code> 片段（CDATA section）。</p><p>在 XML 中，<code>CDATA</code> 可以直接包含未经转义的文本。比如 <code>&lt;</code> 和 <code>&amp;</code>，只要位于 <code>CDATA</code> 片段中，就不需要被转义。</p><h2 id="documenttype-类型" tabindex="-1"><a class="header-anchor" href="#documenttype-类型"><span>DocumentType 类型</span></a></h2><p><code>DocumentType</code> 类型表示了一个包含文档类型的节点 <code>Node</code> 。</p><p><code>DocumentType</code> 继承链路： <code>EventTarget &lt;-- Node &lt;-- DocumentType</code> 。</p>`,32)])])}const p=t(o,[["render",n]]),r=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF/JavaScript/DOM/other.html","title":"其他类型","lang":"zh-CN","frontmatter":{"description":"其他类型 Text 类型 Text 文本节点表示文本内容，代表 Element 元素节点和 Attribute 属性节点的文本内容。如果一个节点只包含一段文本，该节点就有一个文本子节点，表示该文本内容。 空格也会形成文本节点，比如 <p></p> 包含一个空格，其子节点就是一个文本节点。 Text 继承链路： EventTarget <-- Node ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"其他类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-02T16:16:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.LRH\\",\\"url\\":\\"https://lrh21g.github.io/blogs/\\"}]}"],["meta",{"property":"og:url","content":"https://lrh21g.github.io/blogs/%E5%89%8D%E7%AB%AF/JavaScript/DOM/other.html"}],["meta",{"property":"og:site_name","content":"Mr.LRH 博客"}],["meta",{"property":"og:title","content":"其他类型"}],["meta",{"property":"og:description","content":"其他类型 Text 类型 Text 文本节点表示文本内容，代表 Element 元素节点和 Attribute 属性节点的文本内容。如果一个节点只包含一段文本，该节点就有一个文本子节点，表示该文本内容。 空格也会形成文本节点，比如 <p></p> 包含一个空格，其子节点就是一个文本节点。 Text 继承链路： EventTarget <-- Node ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-02T16:16:20.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-02T16:16:20.000Z"}]]},"git":{"createdTime":1698775113000,"updatedTime":1698941780000,"contributors":[{"name":"lrh21g","username":"lrh21g","email":"lingronghai@foxmail.com","commits":2,"url":"https://github.com/lrh21g"}]},"readingTime":{"minutes":3.95,"words":1185},"filePathRelative":"前端/JavaScript/DOM/other.md","excerpt":"\\n<h2>Text 类型</h2>\\n<p><code>Text</code> 文本节点表示文本内容，代表 <code>Element</code> 元素节点和 <code>Attribute</code> 属性节点的文本内容。如果一个节点只包含一段文本，该节点就有一个文本子节点，表示该文本内容。</p>\\n<p>空格也会形成文本节点，比如 <code>&lt;p&gt;&lt;/p&gt;</code> 包含一个空格，其子节点就是一个文本节点。</p>\\n<p>Text 继承链路： <code>EventTarget &lt;-- Node &lt;-- CharacterData &lt;-- Text</code> 。</p>","autoDesc":true}');export{p as comp,r as data};
