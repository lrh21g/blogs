import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,d as o,o as l}from"./app-CwERxs91.js";const i="/blogs/assets/node_relation.drawio-DVoY_JvW.png",n={};function c(s,e){return l(),d("div",null,e[0]||(e[0]=[o('<h1 id="node-类型" tabindex="-1"><a class="header-anchor" href="#node-类型"><span>Node 类型</span></a></h1><p>文档对象模型（DOM）是一个网络文档的编程接口，DOM 将文档表示为节点和对象。</p><p>在 DOM 的上下文中，节点（Node）是节点树中的单个点，包括文档本身、元素、文本以及注释都属于是节点。</p><p>Node 接口是 DOM 树中所有节点类型的基类，定义了所有节点类型的通用属性和方法。</p><h2 id="node-类型属性" tabindex="-1"><a class="header-anchor" href="#node-类型属性"><span>Node 类型属性</span></a></h2><ul><li><p><code>Node.prototype.childNodes</code> ： 返回指定节点的所有子节点集合（<code>NodeList</code> 集合），包含元素节点、文本节点、注释节点等。如果当前节点不包含任何子节点，则返回空的 <code>NodeList</code> 集合。该集合为动态集合，子节点变化时会自动更新。</p></li><li><p><code>Node.prototype.parentNode</code> ： 返回指定节点的父节点，如果没有父节点，则返回 <code>null</code>。父节点只可能是三种类型：元素节点（<code>Element</code>）、文档节点（<code>Document</code>）和文档片段节点（<code>DocumentFragment</code>）。</p></li><li><p><code>Node.prototype.parentElement</code> ： 返回指定节点的父元素节点，如果指定节点没有父节点，或者父节点类型不是元素节点，则返回 <code>null</code>。</p></li><li><p><code>Node.prototype.firstChild</code> ： 返回指定节点的第一个子节点，如果没有子节点，则返回 <code>null</code>。</p></li><li><p><code>Node.prototype.lastChild</code> ： 返回指定节点的最后一个子节点，如果没有子节点，则返回 <code>null</code>。</p></li><li><p><code>Node.prototype.previousSibling</code> ：返回指定节点的上一个兄弟节点，如果没有上一个兄弟节点，则返回 <code>null</code>。</p></li><li><p><code>Node.prototype.nextSibling</code> ： 返回指定节点的下一个兄弟节点，如果没有下一个兄弟节点，则返回 <code>null</code>。</p></li><li><p><code>Node.prototype.isConnected</code> ： 返回布尔值，表示指定节点是否在文档中。</p></li><li><p><code>Node.prototype.nodeName</code> ： 返回指定节点的名称（大写的标签名称，例如：<code>DIV</code>）。不同类型节点的 nodeName 属性值：</p><table><thead><tr><th style="text-align:left;">节点类型</th><th style="text-align:left;">nodeName 属性值</th></tr></thead><tbody><tr><td style="text-align:left;">Document （文档节点）</td><td style="text-align:left;"><code>#document</code></td></tr><tr><td style="text-align:left;">Element （元素节点）</td><td style="text-align:left;">元素的标签名称</td></tr><tr><td style="text-align:left;">Attr （属性节点）</td><td style="text-align:left;">属性的名称，等同于 <code>Attr.name</code> 属性的值</td></tr><tr><td style="text-align:left;">Text （文本节点）</td><td style="text-align:left;"><code>#text</code></td></tr><tr><td style="text-align:left;">Comment （注释节点）</td><td style="text-align:left;"><code>#comment</code></td></tr><tr><td style="text-align:left;">DocumentType （文档类型节点）</td><td style="text-align:left;"><code>#document-type</code></td></tr><tr><td style="text-align:left;">DocumentFragment （文档片段节点）</td><td style="text-align:left;"><code>#document-fragment</code></td></tr><tr><td style="text-align:left;">CDATASection （CDATA 节点）</td><td style="text-align:left;"><code>#cdata-section</code></td></tr><tr><td style="text-align:left;">ProcessingInstruction （处理指令节点）</td><td style="text-align:left;"><code>#processing-instruction</code></td></tr></tbody></table></li><li><p><code>Node.prototype.nodeType</code> ： 返回指定节点的类型。</p><table><thead><tr><th style="text-align:left;">常量</th><th style="text-align:left;">值</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>Node.ELEMENT_NODE</code></td><td style="text-align:left;"><code>1</code></td><td style="text-align:left;">元素节点。例如：<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code></td></tr><tr><td style="text-align:left;"><code>Node.ATTRIBUTE_NODE</code></td><td style="text-align:left;"><code>2</code></td><td style="text-align:left;">元素的属性。例如：<code>class=&quot;right&quot;</code></td></tr><tr><td style="text-align:left;"><code>Node.TEXT_NODE</code></td><td style="text-align:left;"><code>3</code></td><td style="text-align:left;">元素之间或者元素包含的文本节点</td></tr><tr><td style="text-align:left;"><code>Node.CDATA_SECTION_NO</code>DE</td><td style="text-align:left;"><code>4</code></td><td style="text-align:left;">CDATA 片段，例如：<code>&lt;!CDATA[[ … ]]&gt;</code></td></tr><tr><td style="text-align:left;"><code>Node.PROCESSING_INSTRUCTION_NODE</code></td><td style="text-align:left;"><code>7</code></td><td style="text-align:left;">用于 XML 文档的 <code>ProcessingInstruction</code>。例如 <code>&lt;?xml-stylesheet ... ?&gt;</code> 声明</td></tr><tr><td style="text-align:left;"><code>Node.COMMENT_NODE</code></td><td style="text-align:left;"><code>8</code></td><td style="text-align:left;">注释，<code>&lt;!--</code> 和 <code>--&gt;</code> 之间的内容</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_NODE</code></td><td style="text-align:left;"><code>9</code></td><td style="text-align:left;"><code>Document</code> 节点</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_TYPE_NODE</code></td><td style="text-align:left;"><code>10</code></td><td style="text-align:left;">描述文档类型的 <code>DocumentType</code> 节点。例如 <code>&lt;!DOCTYPE html&gt;</code> 用于 HTML5</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_FRAGMENT_NODE</code></td><td style="text-align:left;"><code>11</code></td><td style="text-align:left;">文档片段，作为一个轻量版的 <code>Document</code> 使用</td></tr></tbody></table><p>以下节点类型常量已被弃用且不再使用：<code>Node.ENTITY_REFERENCE_NODE</code>（值为 <code>5</code>）、<code>Node.ENTITY_NODE</code>（值为 <code>6</code>）和 <code>Node.NOTATION_NODE</code>（值为 <code>12</code>）。</p></li><li><p><code>Node.prototype.nodeValue</code> ： 返回或设置指定节点的文本值。只有文本节点（<code>text</code>）、注释节点（<code>comment</code>）和属性节点（<code>attr</code>）有文本值，其他类型的节点一律返回 <code>null</code>。</p></li><li><p><code>Node.prototype.textContent</code> ： 返回指定节点的文本内容，包括子文本节点的内容，以及后代节点的文本内容。如果指定节点没有后代节点，则返回空字符串。如果指定节点是文本节点，则返回文本节点的文本内容。</p></li><li><p><code>Node.prototype.ownerDocument</code> ： 返回指定节点所在的顶层文档对象（<code>Document</code> 对象）。</p></li><li><p><code>Node.prototype.baseURI</code> ： 只读。返回当前网页的绝对路径。当浏览器获取绝对 URL 时，会使用 baseURI 解析相对 URL。一般情况下，由当前网页的 URL （即 <code>window.location</code> 属性）决定，但可以通过 HTML 的 <code>&lt;base&gt;</code> 标签改变属性值。</p></li></ul><h2 id="node-类型节点的关系" tabindex="-1"><a class="header-anchor" href="#node-类型节点的关系"><span>Node 类型节点的关系</span></a></h2><p><img src="'+i+`" alt="node_relation"></p><h2 id="node-类型方法" tabindex="-1"><a class="header-anchor" href="#node-类型方法"><span>Node 类型方法</span></a></h2><ul><li><p><code>Node.prototype.isEqualNode()</code></p><p><strong>语法</strong> ： <code>node.isEqualNode(otherNode)</code></p><p><strong>描述</strong> ： 返回一个布尔值，表示指定节点与另一个节点 <code>otherNode</code> 是否相等（即两个节点的类型相同、属性相同、子节点相同）。</p></li><li><p><code>Node.prototype.isSameNode()</code></p><p><strong>语法</strong> ： <code>node.isSameNode(otherNode)</code></p><p><strong>描述</strong> ： 返回一个布尔值，表示指定节点与另一个节点 <code>otherNode</code> 是否为同一个节点（即两个节点引用是否相同）。</p></li><li><p><code>Node.prototype.contains()</code></p><p><strong>语法</strong> ： <code>node.contains(otherNode)</code></p><p><strong>描述</strong> ： 返回一个布尔值，表示指定节点是否包含另一个节点 <code>otherNode</code>。即 <code>otherNode</code> 是否为指定节点本身、指定节点的子节点、指定节点的后代节点。</p></li><li><p><code>Node.prototype.hasChildNodes()</code></p><p><strong>语法</strong> ： <code>node.hasChildNodes()</code></p><p><strong>描述</strong> ： 返回一个布尔值，表示指定节点是否包含子节点。</p><ul><li>子节点包含所有类型节点，包括元素节点、文本节点、注释节点等。节点只包含一个空格，方法也会返回 <code>true</code>。</li></ul><p><strong>其他</strong> ：</p><ul><li>判断指定节点是否包含子节点，可使用方法如下： <ul><li><code>node.hasChildNodes()</code></li><li><code>node.firstChild !== null</code></li><li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li></ul></li></ul></li><li><p><code>Node.prototype.appendChild()</code></p><p><strong>语法</strong> ： <code>node.appendChild(otherNode)</code></p><p><strong>描述</strong> ： 将一个节点 <code>otherNode</code> 添加到指定节点的子节点列表的末尾。</p><ul><li>如果 <code>otherNode</code> 已经是当前节点的子节点，则将其从原来的位置移动到新的位置，返回值是追加后的子节点 <code>otherNode</code> 。</li><li>如果 <code>otherNode</code> 是文档节点（<code>Document</code>）或者文档片段节点（<code>DocumentFragment</code>），则将其子节点添加到当前节点的子节点列表的末尾，返回值是空文档片段节点（<code>DocumentFragment</code>）。</li></ul></li><li><p><code>Node.prototype.cloneNode()</code></p><p><strong>语法</strong> ： <code>node.cloneNode(deep)</code></p><p><strong>描述</strong> ： 返回指定节点克隆后的节点。</p><ul><li>克隆节点会拷贝节点的所有属性，包括属性上绑定的事件（比如：<code>onclick=&quot;alert(123)&quot;</code>），但是不会拷贝动态绑定的事件（比如：<code>addEventListener()</code> 方法或 <code>on-</code> 属性（<code>node.onclick = fn</code>））。</li><li>方法返回节点不在文档中，即没有任何父节点，需使用 <code>Node.prototype.appendChild()</code> 等方法将其添加到文档中。</li><li>如果原始节点设置了 <code>id</code> 属性（即 <code>id=&quot;xxx&quot;</code>），应该更新克隆节点的 <code>id</code> 属性以保证唯一性。</li></ul><p><strong>参数</strong> ：</p><ul><li><code>deep</code> 参数：表示是否深度克隆。 <ul><li>如果为 <code>true</code>，则会克隆节点的所有后代节点。</li><li>如果为 <code>false</code>，则只克隆当前节点。</li></ul></li></ul></li><li><p><code>Node.prototype.insertBefore()</code></p><p><strong>语法</strong> ： <code>node.insertBefore(newNode, referenceNode)</code></p><p><strong>描述</strong> ： 将一个节点 <code>newNode</code> 插入到指定节点内部的 <code>referenceNode</code> 之前，并返回插入的节点 <code>newNode</code> （如果 <code>newNode</code> 是 <code>DocumentFragment</code> 时，返回空 <code>DocumentFragment</code>）。</p><ul><li><p>没有 <code>insertAfter()</code> 方法，可以使用 <code>insertBefore()</code> 和 <code>Node.nextSibling</code> 来模拟。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 当 childNode 为指定节点的最后一个节点，则 childNode.nextSibling 返回为 null，</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// newNode 会被插入到指定节点的最后，即 childNode 之后</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">parentNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">insertBefore</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">newNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">childNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">nextSibling</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>参数</strong> ：</p><ul><li><code>newNode</code> 参数：表示要插入的节点。</li><li><code>referenceNode</code> 参数：表示参考节点，即 <code>newNode</code> 要插入到 <code>referenceNode</code> 之前。 <ul><li><code>referenceNode</code> 为 <code>null</code> 时，<code>newNode</code> 将被插入到子节点的末尾。</li></ul></li></ul></li><li><p><code>Node.prototype.replaceChild()</code></p><p><strong>语法</strong> ： <code>node.replaceChild(newChild, oldChild)</code></p><p><strong>描述</strong> ： 将指定节点的子节点 <code>oldChild</code> 替换为 <code>newChild</code>，并返回被替换的节点 <code>oldChild</code>。</p><p><strong>参数</strong> ：</p><ul><li><code>newChild</code> 参数：表示要插入的节点。如果该节点已经存在于 DOM 树中，则它首先会被从原始位置删除。</li><li><code>oldChild</code> 参数：表示被替换的节点。</li></ul></li><li><p><code>Node.prototype.removeChild()</code></p><p><strong>语法</strong> ： <code>node.removeChild(childNode)</code></p><p><strong>描述</strong> ： 删除指定节点的子节点 <code>childNode</code>，并返回删除的节点 <code>childNode</code>。如果 <code>childNode</code> 节点不是指定节点的子节点，则会抛出异常。</p></li><li><p><code>Node.prototype.normalize()</code></p><p><strong>语法</strong> ： <code>node.normalize()</code></p><p><strong>描述</strong> ： 规范化指定节点内部的所有文本节点（text），删除空文本节点，合并相邻文本节点。</p></li><li><p><code>Node.prototype.compareDocumentPosition()</code></p><p><strong>语法</strong> ： <code>node.compareDocumentPosition(otherNode)</code></p><p><strong>描述</strong> ： 比较指定节点与另一节点 <code>otherNode</code> 的位置关系，返回值是位掩码。</p><table><thead><tr><th style="text-align:left;">常量名</th><th style="text-align:left;">二进制</th><th style="text-align:left;">十进制</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>000000</code></td><td style="text-align:left;"><code>0</code></td><td style="text-align:left;">两个节点相同</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_POSITION_DISCONNECTED</code></td><td style="text-align:left;"><code>000001</code></td><td style="text-align:left;"><code>1</code></td><td style="text-align:left;">不在同一文档中</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_POSITION_PRECEDING</code></td><td style="text-align:left;"><code>000010</code></td><td style="text-align:left;"><code>2</code></td><td style="text-align:left;"><code>otherNode</code> 在 <code>node</code> 之前</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_POSITION_FOLLOWING</code></td><td style="text-align:left;"><code>000100</code></td><td style="text-align:left;"><code>4</code></td><td style="text-align:left;"><code>otherNode</code> 在 <code>node</code> 之后</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_POSITION_CONTAINS</code></td><td style="text-align:left;"><code>001000</code></td><td style="text-align:left;"><code>8</code></td><td style="text-align:left;"><code>otherNode</code> 包含 <code>node</code></td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_POSITION_CONTAINED_BY</code></td><td style="text-align:left;"><code>010000</code></td><td style="text-align:left;"><code>16</code></td><td style="text-align:left;"><code>otherNode</code> 被 <code>node</code> 包含</td></tr><tr><td style="text-align:left;"><code>Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></td><td style="text-align:left;"><code>100000</code></td><td style="text-align:left;"><code>32</code></td><td style="text-align:left;">待定</td></tr></tbody></table><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;div id=&quot;divDom&quot;&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//   &lt;input id=&quot;inputDom&quot;&gt;&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;/div&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> divDom</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getElementById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;divDom&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> inputDom</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getElementById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;inputDom&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// div 节点包含 input 节点，位置关系二进制位未 010000</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// input 节点在 div 节点后，位置关系二进制位为 000100</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// compareDocumentPosition 方法返回 20 （二进制位 010111，即 010000 + 000100）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">divDom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">compareDocumentPosition</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">inputDom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 20</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>Node.prototype.getRootNode()</code></p><p><strong>语法</strong> ： <code>node.getRootNode(options)</code></p><p><strong>描述</strong> ： 返回指定节点所在文档的根节点（<code>Document</code> 对象）。与 <code>Node.prototype.ownerDocument</code> 属性作用相同。</p><ul><li>当该方法作用于 <code>document</code> 节点自身时，返回 <code>document</code> 节点自身。 <code>Node.prototype.ownerDocument</code> 属性返回 <code>null</code>。</li></ul><p><strong>参数</strong> ：</p><ul><li><code>options</code> 参数：可选参数，用于指定根节点的类型。 <ul><li><code>options.composed</code> ：布尔值，表示是否包含 Shadow DOM 根节点。默认为 <code>false</code>，即不包含 Shadow DOM 根节点。</li></ul></li></ul></li><li><p><code>Node.prototype.isDefaultNamespace()</code></p><p><strong>语法</strong> ： <code>node.isDefaultNamespace(namespaceURI)</code></p><p><strong>描述</strong> ： 返回一个布尔值，表示指定的命名空间 URI 是否为默认命名空间。</p></li><li><p><code>Node.prototype.lookupNamespaceURI()</code></p><p><strong>语法</strong> ： <code>node.lookupNamespaceURI(prefix)</code></p><p><strong>描述</strong> ： 返回指定节点与指定前缀 <code>prefix</code> 对应的命名空间 URI。</p><ul><li>如果没有，返回 <code>null</code> 。</li><li>如果参数为 <code>null</code> ，返回默认的命名空间。</li></ul></li><li><p><code>Node.prototype.lookupPrefix()</code></p><p><strong>语法</strong> ： <code>node.lookupPrefix(namespaceURI)</code></p><p><strong>描述</strong> ： 返回指定节点与指定命名空间 URI <code>namespaceURI</code> 对应的前缀。</p><ul><li>如果没有，返回 <code>null</code>。</li><li>如果有多个绑定的前缀，返回的结果根据浏览器实现而定。</li></ul></li></ul><h2 id="nodelist-类型" tabindex="-1"><a class="header-anchor" href="#nodelist-类型"><span>NodeList 类型</span></a></h2><p><code>NodeList</code> 对象是节点的集合，是一个类数组对象，可以通过索引访问每个节点。</p><p><code>NodeList</code> 实例可以是动态集合（当文档树发生变化时，<code>NodeList</code> 会自动更新），也可以是静态集合。目前只有 <code>Node.prototype.childNodes</code> 返回动态集合，其他方法返回静态集合。</p><h3 id="nodelist-实例属性" tabindex="-1"><a class="header-anchor" href="#nodelist-实例属性"><span>NodeList 实例属性</span></a></h3><ul><li><code>NodeList.prototype.length</code> ： 返回 <code>NodeList</code> 实例包含节点的长度。</li></ul><h3 id="nodelist-实例方法" tabindex="-1"><a class="header-anchor" href="#nodelist-实例方法"><span>NodeList 实例方法</span></a></h3><ul><li><p><code>NodeList.prototype.entries()</code> / <code>NodeList.prototype.keys()</code> / <code>NodeList.prototype.values()</code></p><ul><li><code>nodeList.entries()</code> ： 返回一个迭代器对象，用于遍历 <code>NodeList</code> 实例的键值对。</li><li><code>nodeList.keys()</code> ： 返回一个迭代器对象，用于遍历 <code>NodeList</code> 实例的键名。</li><li><code>nodeList.values()</code> ： 返回一个迭代器对象，用于遍历 <code>NodeList</code> 实例的键值。</li></ul></li><li><p><code>NodeList.prototype.forEach()</code></p><p><strong>语法</strong> ： <code>nodeList.forEach(callback[, thisArg])</code></p><p><strong>描述</strong> ： 遍历 <code>NodeList</code> 实例，为每个节点执行回调函数 <code>callback</code>。</p><p><strong>参数</strong> ：</p><ul><li><code>callback</code> 参数：回调函数，接受三个参数： <ul><li><code>currentValue</code> ：可选值。当前遍历的节点。</li><li><code>currentIndex</code> ：可选值。当前遍历的节点的索引。</li><li><code>listObj</code> ：可选值。当前遍历的 <code>NodeList</code> 实例。</li></ul></li><li><code>thisArg</code> 参数：可选值。用于设置回调函数 <code>callback</code> 内部的 <code>this</code> 指向。</li></ul></li><li><p><code>NodeList.prototype.item()</code></p><p><strong>语法</strong> ： <code>nodeList.item(index)</code></p><p><strong>描述</strong> ： 返回指定索引 <code>index</code> 的节点，如果索引超出范围，则返回 <code>null</code>。一般情况下，可以使用方括号运算符获取。</p></li></ul>`,17)]))}const r=t(n,[["render",c]]),g=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF/JavaScript/DOM/node.html","title":"Node 类型","lang":"zh-CN","frontmatter":{"description":"Node 类型 文档对象模型（DOM）是一个网络文档的编程接口，DOM 将文档表示为节点和对象。 在 DOM 的上下文中，节点（Node）是节点树中的单个点，包括文档本身、元素、文本以及注释都属于是节点。 Node 接口是 DOM 树中所有节点类型的基类，定义了所有节点类型的通用属性和方法。 Node 类型属性 Node.prototype.child...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Node 类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-10-31T17:57:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.LRH\\",\\"url\\":\\"https://lrh21g.github.io/blogs/\\"}]}"],["meta",{"property":"og:url","content":"https://lrh21g.github.io/blogs/%E5%89%8D%E7%AB%AF/JavaScript/DOM/node.html"}],["meta",{"property":"og:site_name","content":"Mr.LRH 博客"}],["meta",{"property":"og:title","content":"Node 类型"}],["meta",{"property":"og:description","content":"Node 类型 文档对象模型（DOM）是一个网络文档的编程接口，DOM 将文档表示为节点和对象。 在 DOM 的上下文中，节点（Node）是节点树中的单个点，包括文档本身、元素、文本以及注释都属于是节点。 Node 接口是 DOM 树中所有节点类型的基类，定义了所有节点类型的通用属性和方法。 Node 类型属性 Node.prototype.child..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-31T17:57:47.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-31T17:57:47.000Z"}]]},"git":{"createdTime":1698775067000,"updatedTime":1698775067000,"contributors":[{"name":"lrh21g","username":"lrh21g","email":"lingronghai@foxmail.com","commits":1,"url":"https://github.com/lrh21g"}]},"readingTime":{"minutes":8.39,"words":2518},"filePathRelative":"前端/JavaScript/DOM/node.md","excerpt":"\\n<p>文档对象模型（DOM）是一个网络文档的编程接口，DOM 将文档表示为节点和对象。</p>\\n<p>在 DOM 的上下文中，节点（Node）是节点树中的单个点，包括文档本身、元素、文本以及注释都属于是节点。</p>\\n<p>Node 接口是 DOM 树中所有节点类型的基类，定义了所有节点类型的通用属性和方法。</p>\\n<h2>Node 类型属性</h2>\\n<ul>\\n<li>\\n<p><code>Node.prototype.childNodes</code> ： 返回指定节点的所有子节点集合（<code>NodeList</code> 集合），包含元素节点、文本节点、注释节点等。如果当前节点不包含任何子节点，则返回空的 <code>NodeList</code> 集合。该集合为动态集合，子节点变化时会自动更新。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.parentNode</code> ： 返回指定节点的父节点，如果没有父节点，则返回 <code>null</code>。父节点只可能是三种类型：元素节点（<code>Element</code>）、文档节点（<code>Document</code>）和文档片段节点（<code>DocumentFragment</code>）。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.parentElement</code> ： 返回指定节点的父元素节点，如果指定节点没有父节点，或者父节点类型不是元素节点，则返回 <code>null</code>。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.firstChild</code> ： 返回指定节点的第一个子节点，如果没有子节点，则返回 <code>null</code>。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.lastChild</code> ： 返回指定节点的最后一个子节点，如果没有子节点，则返回 <code>null</code>。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.previousSibling</code> ：返回指定节点的上一个兄弟节点，如果没有上一个兄弟节点，则返回 <code>null</code>。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.nextSibling</code> ： 返回指定节点的下一个兄弟节点，如果没有下一个兄弟节点，则返回 <code>null</code>。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.isConnected</code> ： 返回布尔值，表示指定节点是否在文档中。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.nodeName</code> ： 返回指定节点的名称（大写的标签名称，例如：<code>DIV</code>）。不同类型节点的 nodeName 属性值：</p>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:left\\">节点类型</th>\\n<th style=\\"text-align:left\\">nodeName 属性值</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:left\\">Document （文档节点）</td>\\n<td style=\\"text-align:left\\"><code>#document</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">Element （元素节点）</td>\\n<td style=\\"text-align:left\\">元素的标签名称</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">Attr （属性节点）</td>\\n<td style=\\"text-align:left\\">属性的名称，等同于 <code>Attr.name</code> 属性的值</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">Text （文本节点）</td>\\n<td style=\\"text-align:left\\"><code>#text</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">Comment （注释节点）</td>\\n<td style=\\"text-align:left\\"><code>#comment</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">DocumentType （文档类型节点）</td>\\n<td style=\\"text-align:left\\"><code>#document-type</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">DocumentFragment （文档片段节点）</td>\\n<td style=\\"text-align:left\\"><code>#document-fragment</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">CDATASection （CDATA 节点）</td>\\n<td style=\\"text-align:left\\"><code>#cdata-section</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">ProcessingInstruction （处理指令节点）</td>\\n<td style=\\"text-align:left\\"><code>#processing-instruction</code></td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n<li>\\n<p><code>Node.prototype.nodeType</code> ： 返回指定节点的类型。</p>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:left\\">常量</th>\\n<th style=\\"text-align:left\\">值</th>\\n<th style=\\"text-align:left\\">描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.ELEMENT_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>1</code></td>\\n<td style=\\"text-align:left\\">元素节点。例如：<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.ATTRIBUTE_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>2</code></td>\\n<td style=\\"text-align:left\\">元素的属性。例如：<code>class=\\"right\\"</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.TEXT_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>3</code></td>\\n<td style=\\"text-align:left\\">元素之间或者元素包含的文本节点</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.CDATA_SECTION_NO</code>DE</td>\\n<td style=\\"text-align:left\\"><code>4</code></td>\\n<td style=\\"text-align:left\\">CDATA 片段，例如：<code>&lt;!CDATA[[ … ]]&gt;</code></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.PROCESSING_INSTRUCTION_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>7</code></td>\\n<td style=\\"text-align:left\\">用于 XML 文档的 <code>ProcessingInstruction</code>。例如 <code>&lt;?xml-stylesheet ... ?&gt;</code> 声明</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.COMMENT_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>8</code></td>\\n<td style=\\"text-align:left\\">注释，<code>&lt;!--</code> 和 <code>--&gt;</code> 之间的内容</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.DOCUMENT_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>9</code></td>\\n<td style=\\"text-align:left\\"><code>Document</code> 节点</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.DOCUMENT_TYPE_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>10</code></td>\\n<td style=\\"text-align:left\\">描述文档类型的 <code>DocumentType</code> 节点。例如 <code>&lt;!DOCTYPE html&gt;</code> 用于 HTML5</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Node.DOCUMENT_FRAGMENT_NODE</code></td>\\n<td style=\\"text-align:left\\"><code>11</code></td>\\n<td style=\\"text-align:left\\">文档片段，作为一个轻量版的 <code>Document</code> 使用</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>以下节点类型常量已被弃用且不再使用：<code>Node.ENTITY_REFERENCE_NODE</code>（值为 <code>5</code>）、<code>Node.ENTITY_NODE</code>（值为 <code>6</code>）和 <code>Node.NOTATION_NODE</code>（值为 <code>12</code>）。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.nodeValue</code> ： 返回或设置指定节点的文本值。只有文本节点（<code>text</code>）、注释节点（<code>comment</code>）和属性节点（<code>attr</code>）有文本值，其他类型的节点一律返回 <code>null</code>。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.textContent</code> ： 返回指定节点的文本内容，包括子文本节点的内容，以及后代节点的文本内容。如果指定节点没有后代节点，则返回空字符串。如果指定节点是文本节点，则返回文本节点的文本内容。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.ownerDocument</code> ： 返回指定节点所在的顶层文档对象（<code>Document</code> 对象）。</p>\\n</li>\\n<li>\\n<p><code>Node.prototype.baseURI</code> ： 只读。返回当前网页的绝对路径。当浏览器获取绝对 URL 时，会使用 baseURI 解析相对 URL。一般情况下，由当前网页的 URL （即 <code>window.location</code> 属性）决定，但可以通过 HTML 的 <code>&lt;base&gt;</code> 标签改变属性值。</p>\\n</li>\\n</ul>","autoDesc":true}');export{r as comp,g as data};
