import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as e}from"./app-CwERxs91.js";const l="/blogs/assets/browser_renderer_process.drawio-BPcOUu-l.png",t="/blogs/assets/react_fiber_mount.drawio-Da3b1iz3.png",h="/blogs/assets/react_fiber_update.drawio-Bwg77Sd6.png",k={};function p(r,i){return e(),a("div",null,i[0]||(i[0]=[n('<h1 id="fiber" tabindex="-1"><a class="header-anchor" href="#fiber"><span>Fiber</span></a></h1><h2 id="react-理念" tabindex="-1"><a class="header-anchor" href="#react-理念"><span>React 理念</span></a></h2><blockquote><p>React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。</p></blockquote><p>React 关键是实现快速响应。制约快速响应的因素有：</p><ul><li><p>CPU 瓶颈。当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</p><ul><li><p>原因</p><p>JavaScript 引擎是单线程运行的，负责解析和执行 JavaScript 脚本程序。与 GUI 渲染线程互斥，防止渲染出现不可预期的结果。另外，异步 I/O 操作底层实际上可能是多线程的在驱动。</p><p>主流浏览器刷新频率是 60Hz （赫兹，频率的单位），即每 16.67ms （= 1000ms / 60Hz）浏览器刷新一次。每 16.67ms 时间内，需要完成的工作如下：</p><ul><li><p>输入事件（Input events）</p><ul><li>Blocking input events （阻塞输入事件）：如 <code>touch</code> 或 <code>wheel</code></li><li>Non-Blocking input events （非阻塞输入事件）：如 <code>click</code> 或 <code>keypress</code></li></ul></li><li><p>JavaScript 引擎解析执行：执行定时器（Timers）事件等回调</p></li><li><p>帧开始（Begin frame）：每一帧事件（Per frame events），如 <code>window resize</code> 、 <code>scroll</code> 、 <code>media query change</code> 、 <code>animation events</code></p></li><li><p>rAF（requestAnimationFrame）：执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</p></li><li><p>页面布局（Layout） ：计算样式（Recalculate style）、更新布局（Update Layout）和 ResizeObserver（监视 Element 内容盒或边框盒或者 SVGElement 边界尺寸的变化）</p></li><li><p>绘制渲染（Paint）：合成更新（Compositing update）、重绘部分节点（Paint invalidation）和创建绘制记录（Paint Record）</p></li><li><p>执行 RIC （RequestIdleCallback）：插入一个函数，该函数将在浏览器空闲时期被调用</p><p>在浏览器繁忙的时候，可能不会有盈余时间，<code>requestIdleCallback</code> 回调可能就不会被执行。 为了避免饿死，可以通过 <code>requestIdleCallback</code> 的第二个参数指定一个超时时间。</p><p>同时，不建议在 <code>requestIdleCallback</code> 中进行 DOM 操作，因为这可能导致样式重新计算或重新布局(比如，操作 DOM 后马上调用 <code>getBoundingClientRect</code>)，时间很难预估，很有可能导致回调执行超时，从而掉帧。</p></li></ul><p><img src="'+l+`" alt="browser_renderer_process.drawio"></p><p>注：如果上述任意步骤占用时间过长，总时间超过过 16.67ms ，就会看到明显的卡顿。</p></li><li><p>解决方案</p><p>当 JavaScript 长时间执行时（如大量计算等），就会出现阻塞样式计算、绘制等工作，出现页面脱帧现象。</p><p>React 通过 Fiber 架构，使 Reconciliation （调和） 过程变成可中断的异步更新。</p><p>在浏览器每一帧的时间中，预留了时间给 JavaScript 线程，React 将渲染更新过程拆分为多个子任务。当预留时间不够用时，React 将线程控制权交还给浏览器执行样式布局和样式绘制等任务，进行 UI 渲染，React 则等待下一帧时间继续被中断的工作。</p></li></ul></li><li><p>I/O 瓶颈。发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</p><p>React 的解决方案是将人机交互研究的结果整合到真实的 UI 中 (opens new window)。</p><p>研究表明，在屏幕之间切换时显示过多的中间加载状态会使切换的速度变慢。从研究得知，悬停和文本输入之类的交互需要在很短的时间内处理，而点击和页面转换可以等待稍长时间而不会感到迟缓。</p><p>React 实现了 <code>Suspense</code> (opens new window)功能及配套的 hook —— <code>useDeferredValue</code></p></li></ul><h2 id="react-架构" tabindex="-1"><a class="header-anchor" href="#react-架构"><span>React 架构</span></a></h2><p>React 架构分为三层：</p><ul><li>Scheduler （调度器） ：任务调度器，根据任务的优先级对任务进行调用执行，高优任务优先进入 Reconciler。</li><li>Reconciler （协调器） ：负责找出变化的组件。</li><li>Renderer （渲染器） ：负责将变化的组件渲染到页面上。</li></ul><h3 id="scheduler-调度器" tabindex="-1"><a class="header-anchor" href="#scheduler-调度器"><span>Scheduler （调度器）</span></a></h3><p>以浏览器每一帧渲染的时间中是否有剩余时间作为任务中断的标准，可以通过 <code>window.requestIdleCallback()</code> API ，该 API 通过插入一个函数，这个函数将在浏览器空闲时期被调用。</p><p>部分浏览器已实现该 API （即：<code>requestIdleCallback</code>），但是该 API 以下问题：</p><ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。如，当浏览器切换标签后，之前标签页注册的 <code>requestIdleCallback</code> 触发的频率会变得很低</li></ul><p>React 实现了功能更完备的 <code>requestIdleCallback</code> polyfill （即 Scheduler），除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。</p><ul><li><code>requestAnimationFrame</code> ：执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</li><li><code>MessageChannel</code> ：创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。</li></ul><p>注： <a href="https://github.com/facebook/react/blob/main/packages/scheduler/README.md" target="_blank" rel="noopener noreferrer">Scheduler</a> 是独立于 React 的。</p><h3 id="reconciler-协调器" tabindex="-1"><a class="header-anchor" href="#reconciler-协调器"><span>Reconciler （协调器）</span></a></h3><p>在 React v15 中， Reconciler 是递归处理虚拟 DOM 的。同时，Reconciler 和 Renderer 是交替工作的，更新一旦开始，中途就无法中断。每当有更新发生时，Reconciler 会做如下工作：</p><ul><li>调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM</li><li>将虚拟 DOM 和上次更新时的虚拟 DOM 对比</li><li>通过对比找出本次更新中变化的虚拟 DOM</li><li>通知 Renderer 将变化的虚拟 DOM 渲染到页面上</li></ul><p>在 React v16+ 中， Reconciler 与 Renderer 不再是交替工作。</p><ul><li>当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟 DOM 打上代表增/删/更新的标记。</li><li>整个 Scheduler 与 Reconciler 的工作都在内存中进行，只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer。</li></ul><p>注： <a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md" target="_blank" rel="noopener noreferrer">react-reconciler</a> 是独立于 React 的。</p><h3 id="renderer-渲染器" tabindex="-1"><a class="header-anchor" href="#renderer-渲染器"><span>Renderer （渲染器）</span></a></h3><p>更新发生时，Renderer 根据 Reconciler 为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。</p><p>由于 React 支持跨平台，所以不同平台有不同的 Renderer。</p><ul><li><a href="https://github.com/facebook/react/blob/main/packages/react-dom/README.md" target="_blank" rel="noopener noreferrer">ReactDOM</a> 渲染器，负责在浏览器环境渲染</li><li><a href="https://github.com/facebook/react/blob/main/packages/react-native-renderer/index.js" target="_blank" rel="noopener noreferrer">ReactNative</a> 渲染器，渲染 App 原生组件</li><li><a href="https://github.com/facebook/react/blob/main/packages/react-test-renderer/README.md" target="_blank" rel="noopener noreferrer">ReactTest</a> 渲染器，渲染出纯 Js 对象用于测试</li><li><a href="https://github.com/facebook/react/blob/main/packages/react-art/README.md" target="_blank" rel="noopener noreferrer">ReactArt</a> 渲染器，渲染到 Canvas, SVG 或 VML (IE8)</li></ul><h2 id="fiber-架构的心智模型" tabindex="-1"><a class="header-anchor" href="#fiber-架构的心智模型"><span>Fiber 架构的心智模型</span></a></h2><h3 id="代数效应" tabindex="-1"><a class="header-anchor" href="#代数效应"><span>代数效应</span></a></h3><p>代数效应是函数式编程中的一个概念，用于将副作用从函数调用中分离。</p><p>对于代数效应的解释与示例，可参考如下文章：</p><ul><li><a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/" target="_blank" rel="noopener noreferrer">通俗易懂的代数效应</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/algebraic-effects-for-the-rest-of-us.md" target="_blank" rel="noopener noreferrer">写给大家的代数效应入门</a></li><li><a href="https://zhuanlan.zhihu.com/p/380855727" target="_blank" rel="noopener noreferrer">干货｜详解 Algebraic Effects 代数效应</a></li></ul><h3 id="代数效应在-react-中的应用" tabindex="-1"><a class="header-anchor" href="#代数效应在-react-中的应用"><span>代数效应在 React 中的应用</span></a></h3><ul><li><p>React Hooks ：类似与 <code>useState</code>、<code>useReducer</code>、<code>useRef</code> 等 Hook，不需要关注 <code>FunctionComponent</code> 的 <code>state</code> 在 Hook 中如何保存，React 会自己处理。</p></li><li><p><code>React.Suspense</code> ：使得组件可以“等待”某些操作结束后，再进行渲染。可以通过 <code>fallback</code> 属性指定加载指示器（loading indicator）。</p></li></ul><h3 id="代数效应与-generator" tabindex="-1"><a class="header-anchor" href="#代数效应与-generator"><span>代数效应与 Generator</span></a></h3><p>React 15 到 React 16，Reconciler （协调器）将同步更新的架构变为异步可中断更新。更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p><p>浏览器原生支持类似的实现，即 <code>Generator</code>。<code>Generator</code> 存在一些缺陷，因此，React 没有采用 <code>Generator</code> 实现协调器</p><ul><li>类似 <code>async</code>，<code>Generator</code> 也是<strong>传染性</strong>的，使用了 <code>Generator</code> 则上下文的其他函数也需要作出改变。</li><li><code>Generator</code> <strong>不能在栈中间让出</strong>。比如，在嵌套的函数调用中间让出, 首先，需要将这些函数都包装成 <code>Generator</code>，另外，这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大。</li><li><code>Generator</code> 执行的中间状态是<strong>上下文关联</strong>的，很难再中间恢复这些状态。</li></ul><p>可参考 <a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener noreferrer">Couldn&#39;t you just use generator functions like other scheduling frameworks have done?</a></p><h3 id="代数效应与-fiber" tabindex="-1"><a class="header-anchor" href="#代数效应与-fiber"><span>代数效应与 Fiber</span></a></h3><p>Fiber 称为纤程，纤程可以看作是协程的一种。</p><ul><li>在 JavaScript 中，协程的实现便是 <code>Generator</code> 。协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。</li><li>可以将纤程(<code>Fiber</code>)、协程(<code>Generator</code>)理解为代数效应思想在 JavaScript 中的体现。</li></ul><p>React Fiber 可以理解为 React 内部实现的一套<strong>状态更新机制</strong>。</p><ul><li>支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。</li><li>每个任务更新单元为 <code>React Element</code> 对应的 <code>Fiber</code> 节点。</li></ul><h2 id="fiber-实现原理" tabindex="-1"><a class="header-anchor" href="#fiber-实现原理"><span>Fiber 实现原理</span></a></h2><h3 id="fiber-的含义" tabindex="-1"><a class="header-anchor" href="#fiber-的含义"><span>Fiber 的含义</span></a></h3><ul><li>从 <strong>架构</strong> 角度 <ul><li>React 15 的 Reconciler 采用递归的方式执行，数据保存在递归调用栈中，被称为 <code>stack Reconciler</code>。</li><li>React 16 的 Reconciler 基于 Fiber 节点实现，被称为 <code>Fiber Reconciler</code>。</li></ul></li><li>从 <strong>静态的数据结构</strong> 角度，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件、类组件、原生组件等）、对应的 DOM 节点等信息。</li><li>从 <strong>动态的工作单元</strong> 角度，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除、被插入页面中、被更新等）。</li></ul><h3 id="fiber-的结构" tabindex="-1"><a class="header-anchor" href="#fiber-的结构"><span>Fiber 的结构</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// react\\packages\\react-reconciler\\src\\ReactFiber.new.js</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FiberNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  tag</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> WorkTag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  pendingProps</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> mixed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  key</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> null</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  mode</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TypeOfMode</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ===== Instance - 作为静态数据结构的属性 =====</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 标识 React 元素的类型，Fiber 对应组件的类型有 FunctionComponent / ClassComponent / HostComponent ...</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">tag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> tag</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // key 属性</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 大部分情况同 type，某些情况不同，比如 FunctionComponent 使用 React.memo 包裹</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">elementType</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 异步组件 resolve 之后返回的内容，一般是 function 或 class</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 对于 FunctionComponent，指函数本身；对于 ClassComponent，指 class；对于 HostComponent，指 DOM节点 tagName 。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   */</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">type</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * Fiber 对应的真实 DOM 节点，不同类型的实例都会记录在 stateNode 上</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * &gt; DOM 组件对应 DOM 节点实例</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * &gt; ClassComponent 对应 Class 实例</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * &gt; FunctionComponent 没有实例，所以 StateNode 值为 null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * state 更新了或 props 更新了均会更新到 stateNode 上</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   */</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">stateNode</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ===== Fiber - 用于连接其他 Fiber节点形成 Fiber 树 =====</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 指向父级 Fiber 节</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 因为作为一个工作单元，return 指节点执行完 completeWork 后会返回的下一个节点。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 子 Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用 return 指代父级节点。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   */</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">return</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 指向自己的子 Fiber 节点</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">child</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 指向自己的第一个兄弟 Fiber 节点，兄弟节点的 return 指向同一个父节点</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">sibling</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">index</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ref</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ===== 作为动态的工作单元的属性 =====</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 新的变动带来的新的 Props，即 nextProps</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">pendingProps</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pendingProps</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 上次渲染完成之后的 Props，即 props</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">memoizedProps</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 该 Fiber 对应的组件产生的 Update 会存放在这个队列里</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">updateQueue</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 上次渲染的时候的 State，即 state</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 新的 state 由 updateQueue 计算得出，并覆盖 memoizedState</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">memoizedState</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 一个列表，存在该 Fiber 依赖的 contexts、events</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependencies</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * mode 有 conCurrentMode 和 strictMode，用于描述当前 Fiber 和其他子树的 Bitfield</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 共存的模式表示这个子树是否默认是异步渲染的</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * Fiber 刚被创建时，会继承父 Fiber</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 其他标识也可以在创建的时候被设置，但是创建之后不该被修改，特别是它的子 Fiber 创建之前</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   */</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">mode</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mode</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ===== 副作用，标记组件需要更新、执行生命周期的工具 =====</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Fiber 节点包含的副作用标识</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">flags</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoFlags</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 子树包含的副作用标识，避免深度遍历</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">subtreeFlags</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoFlags</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 删除的节点，用于执行 unmount 钩子</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">deletions</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ===== 调度优先级相关 =====</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 优先级相关，用于计算过期时间</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lanes</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoLanes</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">childLanes</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoLanes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 指向该 fiber 在另一次更新时对应的 fiber</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 在 Fiber 树更新的过程中，每个 Fiber 都会有一个跟其对应的 Fiber</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 当前屏幕上显示内容对应的 Fiber 树称为 current Fiber 树，正在内存中构建的 Fiber 树称为 workInProgress Fiber 树</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   * 在渲染完成之后它们会交换位置</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   */</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">alternate</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="双缓存-fiber-树" tabindex="-1"><a class="header-anchor" href="#双缓存-fiber-树"><span>双缓存 Fiber 树</span></a></h3><p>React 使用 <strong>双缓存</strong> 来完成 Fiber 树的构建与替换 —— 对应 DOM 树的创建与更新。</p><p>在 React 中最多会同时存在两棵 Fiber 树：</p><ul><li>当前屏幕上显示内容对应的 Fiber 树，称为 <code>current Fiber</code> 树。<code>current Fiber</code> 树中的 Fiber 节点被称为 <code>currentFiber</code> 。</li><li>正在内存中构建的 Fiber 树，称为 <code>workInProgress Fiber</code> 树。<code>workInProgress Fiber</code> 树中的 Fiber 节点被称为 <code>workInProgressFiber</code> 。</li></ul><p><code>currentFiber</code> 与 <code>workInProgressFiber</code>通过 <code>alternate</code> 属性相连接。</p><p>React 应用的根节点通过使 <code>current</code> 指针，在不同 Fiber 树的 <code>rootFiber</code> 间切换，完成 <code>current Fiber</code> 树指向的切换。即，当 <code>workInProgress Fiber</code> 树构建完成，交给 <code>Renderer</code> 渲染在页面上后，应用根节点的 <code>current</code> 指针指向 <code>workInProgress Fiber</code> 树，此时 <code>workInProgress Fiber</code> 树就变为 <code>current Fiber</code> 树。</p><p>每次状态更新都会产生新的 <code>workInProgress Fiber</code> 树，通过 <code>current</code> 与 <code>workInProgress</code> 的替换，完成 DOM 更新。</p><h3 id="fiber-mount" tabindex="-1"><a class="header-anchor" href="#fiber-mount"><span>Fiber mount</span></a></h3><ul><li><p>首先，执行 ReactDOM <code>createRoot()</code> API 会创建 <code>fiberRoot</code> 和 <code>rootFiber</code> 。其中， <code>fiberRoot</code> 是整个应用的根节点，<code>rootFiber</code> 是 <code>&lt;App/&gt;</code> 所在组件树的根节点。</p><p>在应用中，可以多次调用 ReactDOM <code>createRoot()</code> API 渲染不同的组件树，会拥有不同的 <code>rootFiber</code> 。但是，整个应用的根节点只有一个（即：<code>fiberRoot</code>）。</p><p><code>fiberRoot</code> 的 <code>current</code> 会指向当前页面上已渲染内容对应 Fiber 树，即 <code>current Fiber</code> 树。</p><p>由于是首屏渲染，页面中还没有挂载任何 DOM，所以 <code>fiberRoot.current</code> 指向的 <code>rootFiber</code> 没有任何子 Fiber 节点（即 <code>current Fiber</code> 树为空）</p><details class="hint-container details"><summary>createFiberRoot</summary><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// react\\packages\\react-reconciler\\src\\ReactFiberRoot.old.js</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createFiberRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  containerInfo</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> any</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  tag</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RootTag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  hydrate</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  initialChildren</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReactNodeList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  hydrationCallbacks</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> null</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SuspenseHydrationCallbacks</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  isStrictMode</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  concurrentUpdatesByDefaultOverride</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> null</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // TODO: We have several of these arguments that are conceptually part of the</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // host config, but because they are passed in at runtime, we have to thread</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // them through the root constructor. Perhaps we should put them all into a</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // single type, like a DynamicHostConfig that is defined by the renderer.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  identifierPrefix</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  onRecoverableError</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> null</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> mixed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">  transitionCallbacks</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> null</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TransitionTracingCallbacks</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FiberRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FiberRoot</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fiberRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    containerInfo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    tag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    hydrate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    identifierPrefix</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    onRecoverableError</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  ): </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">any</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">enableSuspenseCallback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">hydrationCallbacks</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hydrationCallbacks</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">enableTransitionTracing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">transitionCallbacks</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> transitionCallbacks</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Cyclic construction. This cheats the type system right now because</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // stateNode is any.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> uninitializedFiber</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createHostrootFiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    tag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    isStrictMode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    concurrentUpdatesByDefaultOverride</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  )</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">current</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> uninitializedFiber</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  uninitializedFiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">stateNode</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> root</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">enableCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> initialCache</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    retainCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">initialCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // The pooledCache is a fresh cache instance that is used temporarily</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // for newly mounted boundaries during a render. In general, the</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // pooledCache is always cleared from the root at the end of a render:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // it is either released when render commits, or moved to an Offscreen</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // component if rendering suspends. Because the lifetime of the pooled</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // cache is distinct from the main memoizedState.cache, it must be</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // retained separately.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">pooledCache</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> initialCache</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    retainCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">initialCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> initialState</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RootState</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      element</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> initialChildren</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      isDehydrated</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hydrate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      cache</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> initialCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      transitions</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      pendingSuspenseBoundaries</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    uninitializedFiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">memoizedState</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> initialState</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> initialState</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RootState</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      element</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> initialChildren</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      isDehydrated</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hydrate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">      cache</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">null</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> any</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// not enabled yet</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      transitions: null,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      pendingSuspenseBoundaries: null,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    uninitializedFiber.memoizedState = initialState</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  initializeUpdateQueue(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">uninitializedFiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  return root</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details></li><li><p>接着，进入 <code>render</code> 阶段，根据组件返回的 JSX ，在内存中依次创建 Fiber 节点并连接在一起构建 Fiber 树，称为 <code>workInProgress Fiber</code> 树。</p><p>在构建 <code>workInProgress Fiber</code> 树时，会尝试复用 <code>current Fiber</code> 树中已有的 Fiber 节点内的属性，在首屏渲染时，只有 <code>rootFiber</code> 存在对应的 <code>current fiber</code>（即 <code>rootFiber.alternate</code>）</p></li><li><p>已构建完的 <code>workInProgress Fiber</code> 树在 <code>commit</code> 阶段渲染到页面。<code>fiberRoot</code> 的 <code>current</code> 指针指向 <code>workInProgress Fiber</code> 树使其变为 <code>current Fiber</code> 树。</p></li></ul><p><img src="`+t+'" alt="react_fiber_mount"></p><h3 id="fiber-update" tabindex="-1"><a class="header-anchor" href="#fiber-update"><span>Fiber update</span></a></h3><ul><li><p>当触发状态改变时，会开启一次新的 <code>render</code> 并创建新的 <code>workInProgress Fiber</code> 树。</p><p><code>workInProgress fiber</code> 的创建可以复用 <code>current Fiber</code> 树对应的节点数据。决定是否复用的过程就是 Diff 算法。</p></li><li><p><code>workInProgress Fiber</code> 树在 <code>render</code> 阶段完成构建后，进入 <code>commit</code> 阶段渲染到页面上。渲染完毕后，<code>workInProgress Fiber</code> 树变为 <code>current Fiber</code> 树。</p></li></ul><p><img src="'+h+'" alt="react_fiber_update"></p>',60)]))}const o=s(k,[["render",p]]),g=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%8E%9F%E7%90%86/Fiber.html","title":"Fiber","lang":"zh-CN","frontmatter":{"description":"Fiber React 理念 React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。 React 关键是实现快速响应。制约快速响应的因素有： CPU 瓶颈。当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。 原因 JavaScript 引擎是单线程运行的，负责解析和执行 JavaScript 脚本程序。与 GU...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Fiber\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-28T09:19:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.LRH\\",\\"url\\":\\"https://lrh21g.github.io/blogs/\\"}]}"],["meta",{"property":"og:url","content":"https://lrh21g.github.io/blogs/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%8E%9F%E7%90%86/Fiber.html"}],["meta",{"property":"og:site_name","content":"Mr.LRH 博客"}],["meta",{"property":"og:title","content":"Fiber"}],["meta",{"property":"og:description","content":"Fiber React 理念 React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。 React 关键是实现快速响应。制约快速响应的因素有： CPU 瓶颈。当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。 原因 JavaScript 引擎是单线程运行的，负责解析和执行 JavaScript 脚本程序。与 GU..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-28T09:19:36.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-28T09:19:36.000Z"}]]},"git":{"createdTime":1675418223000,"updatedTime":1740734376000,"contributors":[{"name":"lingronghai","username":"lingronghai","email":"lingronghai@foxmail.com","commits":1,"url":"https://github.com/lingronghai"},{"name":"lrh","username":"lrh","email":"lingronghai@foxmail.com","commits":1,"url":"https://github.com/lrh"}]},"readingTime":{"minutes":12.94,"words":3882},"filePathRelative":"前端框架/React/React原理/Fiber.md","excerpt":"\\n<h2>React 理念</h2>\\n<blockquote>\\n<p>React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。</p>\\n</blockquote>\\n<p>React 关键是实现快速响应。制约快速响应的因素有：</p>\\n<ul>\\n<li>\\n<p>CPU 瓶颈。当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</p>\\n<ul>\\n<li>\\n<p>原因</p>\\n<p>JavaScript 引擎是单线程运行的，负责解析和执行 JavaScript 脚本程序。与 GUI 渲染线程互斥，防止渲染出现不可预期的结果。另外，异步 I/O 操作底层实际上可能是多线程的在驱动。</p>\\n<p>主流浏览器刷新频率是 60Hz （赫兹，频率的单位），即每 16.67ms （= 1000ms / 60Hz）浏览器刷新一次。每 16.67ms 时间内，需要完成的工作如下：</p>\\n<ul>\\n<li>\\n<p>输入事件（Input events）</p>\\n<ul>\\n<li>Blocking input events （阻塞输入事件）：如 <code>touch</code> 或 <code>wheel</code></li>\\n<li>Non-Blocking input events （非阻塞输入事件）：如 <code>click</code> 或 <code>keypress</code></li>\\n</ul>\\n</li>\\n<li>\\n<p>JavaScript 引擎解析执行：执行定时器（Timers）事件等回调</p>\\n</li>\\n<li>\\n<p>帧开始（Begin frame）：每一帧事件（Per frame events），如 <code>window resize</code> 、 <code>scroll</code> 、 <code>media query change</code> 、 <code>animation events</code></p>\\n</li>\\n<li>\\n<p>rAF（requestAnimationFrame）：执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</p>\\n</li>\\n<li>\\n<p>页面布局（Layout） ：计算样式（Recalculate style）、更新布局（Update Layout）和 ResizeObserver（监视 Element 内容盒或边框盒或者 SVGElement 边界尺寸的变化）</p>\\n</li>\\n<li>\\n<p>绘制渲染（Paint）：合成更新（Compositing update）、重绘部分节点（Paint invalidation）和创建绘制记录（Paint Record）</p>\\n</li>\\n<li>\\n<p>执行 RIC （RequestIdleCallback）：插入一个函数，该函数将在浏览器空闲时期被调用</p>\\n<p>在浏览器繁忙的时候，可能不会有盈余时间，<code>requestIdleCallback</code> 回调可能就不会被执行。 为了避免饿死，可以通过 <code>requestIdleCallback</code> 的第二个参数指定一个超时时间。</p>\\n<p>同时，不建议在 <code>requestIdleCallback</code> 中进行 DOM 操作，因为这可能导致样式重新计算或重新布局(比如，操作 DOM 后马上调用 <code>getBoundingClientRect</code>)，时间很难预估，很有可能导致回调执行超时，从而掉帧。</p>\\n</li>\\n</ul>\\n<p></p>\\n<p>注：如果上述任意步骤占用时间过长，总时间超过过 16.67ms ，就会看到明显的卡顿。</p>\\n</li>\\n<li>\\n<p>解决方案</p>\\n<p>当 JavaScript 长时间执行时（如大量计算等），就会出现阻塞样式计算、绘制等工作，出现页面脱帧现象。</p>\\n<p>React 通过 Fiber 架构，使 Reconciliation （调和） 过程变成可中断的异步更新。</p>\\n<p>在浏览器每一帧的时间中，预留了时间给 JavaScript 线程，React 将渲染更新过程拆分为多个子任务。当预留时间不够用时，React 将线程控制权交还给浏览器执行样式布局和样式绘制等任务，进行 UI 渲染，React 则等待下一帧时间继续被中断的工作。</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>I/O 瓶颈。发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</p>\\n<p>React 的解决方案是将人机交互研究的结果整合到真实的 UI 中 (opens new window)。</p>\\n<p>研究表明，在屏幕之间切换时显示过多的中间加载状态会使切换的速度变慢。从研究得知，悬停和文本输入之类的交互需要在很短的时间内处理，而点击和页面转换可以等待稍长时间而不会感到迟缓。</p>\\n<p>React 实现了 <code>Suspense</code> (opens new window)功能及配套的 hook —— <code>useDeferredValue</code></p>\\n</li>\\n</ul>","autoDesc":true}');export{o as comp,g as data};
