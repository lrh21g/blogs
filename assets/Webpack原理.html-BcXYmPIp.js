import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,d,o as i}from"./app-CsEj30Cd.js";const n="/blogs/assets/webpack_tapable.drawio-Cterj93c.png",o="/blogs/assets/webpack.drawio-BMd5oD7O.png",s={};function c(a,t){return i(),l("div",null,[...t[0]||(t[0]=[d(`<h1 id="webpack-原理" tabindex="-1"><a class="header-anchor" href="#webpack-原理"><span>Webpack 原理</span></a></h1><p>Webpack 本质上是一种事件流机制。通过事件流将各种插件串联起来，最终完成 Webpack 的全流程。实现事件流机制的核心是 <code>Tapable</code> 模块。Webpack 负责编译的 <code>Compiler</code> 和创建 Bundle 的 <code>Compilation</code> 都是继承自 <code>Tapable</code> 。</p><h2 id="tapable" tabindex="-1"><a class="header-anchor" href="#tapable"><span>Tapable</span></a></h2><p><code>Tapable</code> 和 Node.js 中的 <code>EventEmitter</code> 类似，包括多种类型，通过事件的注册和监听，触发 Webpack 生命周期中的函数方法。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  SyncHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  SyncBailHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  SyncWaterfallHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  SyncLoopHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  AsyncParallelHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  AsyncParallelBailHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  AsyncSeriesHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  AsyncSeriesBailHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">  AsyncSeriesWaterfallHook</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;tapable&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hook-同步与异步分类" tabindex="-1"><a class="header-anchor" href="#hook-同步与异步分类"><span>Hook 同步与异步分类</span></a></h3><p>Hook 类型可以分为同步（Sync）和异步（Async），异步又分为并行和串行</p><ul><li>同步 Hook <ul><li><code>SyncHook</code> - 串行</li><li><code>SyncBailHook</code> - 串行</li><li><code>SyncWaterfallHook</code> - 串行</li><li><code>SyncLoopHook</code> - 循环</li></ul></li><li>异步 Hook <ul><li><code>AsyncSeries*</code> 串行 <ul><li><code>AsyncSeriesHook</code></li><li><code>AsyncSeriesBailHook</code></li><li><code>AsyncSeriesWaterfallHook</code></li></ul></li><li><code>AsyncParallel*</code> 并行 <ul><li><code>AsyncParallelHook</code></li><li><code>AsyncParallelBailHook</code></li></ul></li></ul></li></ul><h3 id="hook-使用方式分类" tabindex="-1"><a class="header-anchor" href="#hook-使用方式分类"><span>Hook 使用方式分类</span></a></h3><ul><li>Basic ： 基础类型，不关心函数的返回值，不根据返回值做事情，会一直执行到底。包括 <code>SyncHook</code> 、 <code>AsyncParallelHook</code> 、 <code>AsyncSeriesHook</code> 。</li><li>Bail ： 按回调栈顺序依次执行回调，但是如果其中一个回调函数返回结果 <code>result !== undefined</code> ，则退出回调栈调。包括 <code>SyncBailHook</code> 、<code>AsyncSeriesBailHook</code> 、<code>AsyncParallelBailHook</code> 。</li><li>Waterfal ： 瀑布式，如果上一个回调函数的结果 <code>result !== undefined</code>，则会被作为下一个回调函数的第一个参数。包括 <code>SyncWaterfallHook</code> 、 <code>AsyncSeriesWaterfallHook</code> 。</li><li>Loop ： 循环类型，如果该监听函数返回 <code>true</code> ，则这个监听函数会反复执行；如果返回 <code>undefined</code> 则退出循环。包括 <code>SyncLoopHook</code> 。</li></ul><p><img src="`+n+`" alt="webpack_tapable"></p><h3 id="tapable-原理解析" tabindex="-1"><a class="header-anchor" href="#tapable-原理解析"><span>Tapable 原理解析</span></a></h3><p>Tapable 的执行流程可以分为四步：</p><ol><li>使用 <code>tap*</code> 对事件进行注册绑定。根据类型不同，提供三种绑定的方式：<code>tap</code> 、 <code>tapPromise</code> 、 <code>tapAsync</code> ，其中 <code>tapPromise</code> 、 <code>tapAsync</code> 为异步类 Hook 的绑定方法；</li><li>使用 <code>call*</code> 对事件进行触发，根据类型不同，也提供了三种触发的方式： <code>call</code> 、 <code>promise</code> 、 <code>callAsync</code> ；</li><li>生成对应类型的代码片段（要执行的代码实际是拼字符串拼出来的）；</li><li>生成第三步生成的代码片段。</li></ol><h2 id="compiler-和-compilation" tabindex="-1"><a class="header-anchor" href="#compiler-和-compilation"><span>Compiler 和 Compilation</span></a></h2><p><code>Compiler</code> 和 <code>Compilation</code> 都是继承自 <code>Tapable</code></p><ul><li><code>Compiler</code> ： 每个 Webpack 的配置，对应一个 <code>Compiler</code> 对象，记录着整个 Webpack 的生命周期。webpack 启动后会创建 <code>compiler</code> 对象，该对象一直存活知道结束退出。</li><li><code>Compilation</code> ： 在构建的过程中，每次构建都会产生一次 <code>Compilation</code>， <code>Compilation</code> 是构建周期的产物。</li></ul><h3 id="compiler" tabindex="-1"><a class="header-anchor" href="#compiler"><span>Compiler</span></a></h3><p>整个 <code>Compiler</code> 完整地展现了 Webpack 的构建流程：</p><ul><li>准备阶段 ： <code>make</code> 之前做的事情都属于准备阶段，这阶段的 callback 入参以 <code>compiler</code> 为主；</li><li>编译阶段 ： 该阶段以 <code>compilation</code> 的钩子为主，callback 入参以 <code>compilation</code> 为主；</li><li>产出阶段 ： 该阶段从 <code>compilation</code> 开始，最后回到 <code>Compiler</code> 钩子上，callback 传入参数是跟结果相关的数据，包括 <code>stats</code>、<code>error</code>。</li></ul><h4 id="compiler-钩子" tabindex="-1"><a class="header-anchor" href="#compiler-钩子"><span>Compiler 钩子</span></a></h4><table><thead><tr><th style="text-align:center;">钩子名</th><th style="text-align:center;">Tapable 类型</th><th style="text-align:left;">触发时机</th><th style="text-align:center;">传入 callback 的参数</th></tr></thead><tbody><tr><td style="text-align:center;">entryOption</td><td style="text-align:center;">SyncBailHook</td><td style="text-align:left;">在 webpack 中的 entry 配置处理过之后</td><td style="text-align:center;">context，entry</td></tr><tr><td style="text-align:center;">afterPlugins</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">初始化完内置插件之后</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">afterResolvers</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">resolver 完成之后（后面解释resolver是什么）</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">environment</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">准备编译环境，webpack plugins配置初始化完成之后</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">afterEnvironment</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">编译环境准备好之后</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">beforeRun</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">开始正式编译之前</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">run</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">开始编译之后，读取 records 之前；监听模式触发watch-run</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">watchRun</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">监听模式下，一个新的编译触发之后</td><td style="text-align:center;">compiler</td></tr><tr><td style="text-align:center;">normalModuleFactory</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">NormalModuleFactory 创建之后</td><td style="text-align:center;">normalModuleFactory实例</td></tr><tr><td style="text-align:center;">contextModuleFactory</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">ContextModuleFactory 创建之后</td><td style="text-align:center;">contextModuleFactory实例</td></tr><tr><td style="text-align:center;">beforeCompile</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">compilation 实例化需要的参数创建完毕之后</td><td style="text-align:center;">compilationParams</td></tr><tr><td style="text-align:center;">compile</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">一次 compilation 编译创建之前</td><td style="text-align:center;">compilationParams</td></tr><tr><td style="text-align:center;">thisCompilation</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">触发 compilation 事件之前执行compilation，</td><td style="text-align:center;">compilationParams</td></tr><tr><td style="text-align:center;">compilation</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">compilation创建成功之后</td><td style="text-align:center;">compilation，compilationParams</td></tr><tr><td style="text-align:center;">make</td><td style="text-align:center;">AsyncParallelHook</td><td style="text-align:left;">完成编译之前</td><td style="text-align:center;">compilation</td></tr><tr><td style="text-align:center;">afterCompile</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">完成编译和封存（seal）编译产出之后</td><td style="text-align:center;">compilation</td></tr><tr><td style="text-align:center;">shouldEmit</td><td style="text-align:center;">SyncBailHook</td><td style="text-align:left;">发布构建后资源之前触发，回调必须返回true/false，true则继续</td><td style="text-align:center;">compilation</td></tr><tr><td style="text-align:center;">emit</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">生成资源到 output 目录之前</td><td style="text-align:center;">compilation</td></tr><tr><td style="text-align:center;">afterEmit</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">生成资源到 output 目录之后</td><td style="text-align:center;">compilation</td></tr><tr><td style="text-align:center;">done</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">compilation完成之后</td><td style="text-align:center;">stats</td></tr><tr><td style="text-align:center;">failed</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">compilation失败</td><td style="text-align:center;">error</td></tr><tr><td style="text-align:center;">invalid</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">监听模式下，编译无效时</td><td style="text-align:center;">fileName，changeTime</td></tr><tr><td style="text-align:center;">watchClose</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">监听模式停止</td><td style="text-align:center;">无</td></tr></tbody></table><h3 id="compilation" tabindex="-1"><a class="header-anchor" href="#compilation"><span>Compilation</span></a></h3><p>在 <code>Compilation</code> 阶段，模块会被 <strong>加载(loaded)</strong> 、 <strong>封存(sealed)</strong> 、 <strong>优化(optimized)</strong> 、 <strong>分块(chunked)</strong> 、 <strong>哈希(hashed)</strong> 和 <strong>重新创建(restored)</strong>。</p><p><code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以监听（watch）模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展，通过 <code>Compilation</code> 也能读取到 <code>Compiler</code> 对象。</p><p>在 <code>Compilation</code> 中处理的对象分别是 <code>module</code>、<code>chunk</code>、<code>asset</code>，由 <code>modules</code> 组成<code>chunks</code>，由 <code>chunks</code> 生成 <code>assets</code>，处理顺序是：<strong><code>module</code> → <code>modules</code> → <code>chunks</code> → <code>assets</code></strong>（先从单个 <code>module</code> 开始处理，查找依赖关系，最后完成单个 <code>module</code> <code>处理，完成全部modules</code> 之后，开始 <code>chunks</code> 阶段处理，最后在根据优化配置，按需生成 <code>assets</code>）。</p><h4 id="compilation-钩子" tabindex="-1"><a class="header-anchor" href="#compilation-钩子"><span>Compilation 钩子</span></a></h4><table><thead><tr><th style="text-align:center;">钩子名</th><th style="text-align:center;">Tapable 类型</th><th style="text-align:left;">触发时机</th><th style="text-align:center;">传入 callback 的参数</th></tr></thead><tbody><tr><td style="text-align:center;">buildModule</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">在模块构建开始之前触发</td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">rebuildModule</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">在重新构建一个模块之前触发</td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">failedModule</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">模块构建失败时执行</td><td style="text-align:center;">module，error</td></tr><tr><td style="text-align:center;">succeedModule</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">模块构建成功时执行</td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">finishModules</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">所有模块都完成构建</td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">finishRebuildingModule</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">一个模块完成重新构建</td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">seal</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;"><strong>★编译（compilation）停止接收新模块时触发</strong></td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">unseal</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">编译（compilation）开始接收新模块时触发</td><td style="text-align:center;">module</td></tr><tr><td style="text-align:center;">optimizeDependencies</td><td style="text-align:center;">SyncBailHook</td><td style="text-align:left;">依赖优化开始时触发</td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">afterOptimizeDependencies</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">依赖优化结束时触发</td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">optimize</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;"><strong>★优化阶段开始时触发</strong></td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">optimizeModules</td><td style="text-align:center;">SyncBailHook</td><td style="text-align:left;"><strong>★模块的优化</strong></td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">afterOptimizeModules</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">模块优化结束时触发</td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">optimizeChunks</td><td style="text-align:center;">SyncBailHook</td><td style="text-align:left;"><strong>★优化 chunks</strong></td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">afterOptimizeChunks</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">chunk 优化完成之后触发</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">optimizeTree</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;">异步优化依赖树</td><td style="text-align:center;">chunks，modules</td></tr><tr><td style="text-align:center;">afterOptimizeTree</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">异步优化依赖树完成时</td><td style="text-align:center;">chunks，modules</td></tr><tr><td style="text-align:center;">optimizeChunkModules</td><td style="text-align:center;">SyncBailHook</td><td style="text-align:left;">优化单个chunk中的 modules 开始</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">afterOptimizeChunkModules</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">优化单个chunk中的 modules 结束</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">shouldRecord</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;"></td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">reviveModules</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">从 records 中恢复模块信息</td><td style="text-align:center;">modules，records</td></tr><tr><td style="text-align:center;">optimizeModuleOrder</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">将模块从最重要的到最不重要的进行排序</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">beforeModuleIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">处理 modulesId 之前</td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">moduleIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">处理 modulesId</td><td style="text-align:center;">modules</td></tr><tr><td style="text-align:center;">optimizeModuleIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">优化 modulesId</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">afterOptimizeModuleIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">优化 modulesId之后</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">reviveChunks</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">从 records 中恢复 chunk 信息</td><td style="text-align:center;">modules，records</td></tr><tr><td style="text-align:center;">optimizeChunkOrder</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">将 chunk 从最重要的到最不重要的进行排序</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">beforeOptimizeChunkIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">chunk id 优化之前触发</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">optimizeChunkIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">chunk id 优化开始触发</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">afterOptimizeChunkIds</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">chunk id 优化结束触发</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">recordModules</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">将模块信息存储到 records</td><td style="text-align:center;">modules，records</td></tr><tr><td style="text-align:center;">recordChunks</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">将 chunk 信息存储到 records</td><td style="text-align:center;">chunks，records</td></tr><tr><td style="text-align:center;">beforeHash</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">在编译被哈希（hashed）之前</td><td style="text-align:center;">-</td></tr><tr><td style="text-align:center;">afterHash</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">在编译被哈希（hashed）之后</td><td style="text-align:center;">-</td></tr><tr><td style="text-align:center;">record</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">将 compilation 相关信息存储到 records 中</td><td style="text-align:center;">compilation，records</td></tr><tr><td style="text-align:center;">beforeChunkAssets</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">在创建 chunk 资源（asset）之前</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">additionalChunkAssets</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">为 chunk 创建附加资源（asset）</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">additionalAssets</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;"><strong>★为编译（compilation）创建附加资源（asset）</strong></td><td style="text-align:center;">-</td></tr><tr><td style="text-align:center;">optimizeChunkAssets</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;"><strong>★优化所有 chunk 资源（asset）</strong></td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">afterOptimizeChunkAssets</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">chunk 资源（asset）已经被优化</td><td style="text-align:center;">chunks</td></tr><tr><td style="text-align:center;">optimizeAssets</td><td style="text-align:center;">AsyncSeriesHook</td><td style="text-align:left;"><strong>★优化存储在 compilation.assets 中的所有资源（asset）</strong></td><td style="text-align:center;">assets</td></tr><tr><td style="text-align:center;">afterOptimizeAssets</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">优化compilation.assets 中的所有资源（asset）之后</td><td style="text-align:center;">assets</td></tr><tr><td style="text-align:center;">moduleAsset</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">一个模块中的一个资源被添加到编译中</td><td style="text-align:center;">module，filename</td></tr><tr><td style="text-align:center;">chunkAsset</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">一个 chunk 中的一个资源被添加到编译中</td><td style="text-align:center;">chunk，filename</td></tr><tr><td style="text-align:center;">assetPath</td><td style="text-align:center;">SyncWaterfallHook</td><td style="text-align:left;">asset 路径确认之后</td><td style="text-align:center;">filename，data</td></tr><tr><td style="text-align:center;">childCompiler</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;">子编译（compiler）触发</td><td style="text-align:center;">childCompiler，compilerName，compilerIndex</td></tr><tr><td style="text-align:center;">normalModuleLoader</td><td style="text-align:center;">SyncHook</td><td style="text-align:left;"><strong>★普通模块 loader，真正（一个接一个地）加载模块图（graph）中所有模块的函数</strong></td><td style="text-align:center;">loaderContext，module</td></tr></tbody></table><h4 id="stats-对象" tabindex="-1"><a class="header-anchor" href="#stats-对象"><span>Stats 对象</span></a></h4><p>在 Webpack 的回调函数中会得到 <code>stats</code> 对象。这个对象实际来自于 <code>Compilation.getStats()</code>，返回的是主要含有 <code>modules</code>、<code>chunks</code> 和 <code>assets</code> 三个属性值的对象。</p><ul><li><p><code>modules</code> ：记录了所有解析后的模块。在每个 <code>module</code> 中，包含如下信息：</p><ul><li>基本信息：包括最基本的内容、大小、<code>id</code>；</li><li>依赖关系：<code>module.reasons</code> 对象描述了这个模块被加入依赖图表的理由，包含了引入的方式、引入的 <code>module</code> 信息及其对应代码在第几行第几列等，可以通过这个计算出 <code>module</code> 之间的依赖关系图表（<code>graph</code>）；</li><li><code>chunks</code> 和 <code>assets</code> 关系：<code>module.chunks</code> 和 <code>module.assets</code> 包含到 <code>chunks</code> 和 <code>assets</code> 中的对应 <code>id</code> 等；</li><li>被 webpack 处理的后的信息：包含 <code>module.failed</code>、<code>module.errors</code>、<code>module.warnings</code>等。</li></ul></li><li><p><code>chunks</code> ：记录了所有 <code>chunk</code>；在每个 <code>chunk</code> 中，包含如下信息：</p><ul><li>基本信息：包括最基本的内容、大小、<code>id</code>；</li><li>来源：<code>chunk.origins</code> 对象描述了这个模块被加入的理由，包含了引入的方式、引入的 <code>module</code> 信息及其对应代码在第几行第几列等，可以通过这个计算出 <code>module</code> 之间的依赖关系图表（<code>graph</code>）；</li><li>引用关系：<code>chunk.parents</code> 和 <code>chunk.children</code> 被引用和引用的 <code>ids</code>；</li><li>包含和被包含：<code>chunk.files</code> 和 <code>chunk.modules</code> 包含到 <code>assets</code> 和自己包含 <code>modules</code> 中信息等。</li></ul></li><li><p><code>assets</code> ：记录了所有要生成的文件。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;chunkNames&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: [], </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 这个 asset 包含的 chunk</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;chunks&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: [</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 这个 asset 包含的 chunk 的 id</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;emitted&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 表示这个 asset 是否会让它输出到 output 目录</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;10.web.js&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出的文件名</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;size&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1058</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 文件的大小</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><code>Stats</code> 对象本质上来自于 <code>lib/Stats.js</code> 的类实例，常用的方法：</p><ul><li><code>stats.hasWarnings()</code></li><li><code>stats.hasErrors()</code></li><li><code>stats.toJson()</code></li><li><code>stats.toString()</code></li></ul><h2 id="webpack-工作流程" tabindex="-1"><a class="header-anchor" href="#webpack-工作流程"><span>Webpack 工作流程</span></a></h2><ol><li>初始化阶段： <ul><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><strong>创建编译器对象</strong>：用上一步得到的参数创建 <code>Compiler</code> 对象</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 <code>RuleSet</code> 集合、加载配置的插件等</li><li><strong>开始编译</strong>：执行 <code>compiler</code> 对象的 <code>run</code> 方法</li><li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件，调用 <code>compilition.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象（依赖对象，webpack 基于该类型记录模块间依赖关系）</li></ul></li><li>构建阶段： <ul><li><strong>编译模块(make)</strong>：根据 <code>entry</code> 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 <code>AST</code> 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图</li></ul></li><li>生成阶段： <ul><li><strong>输出资源(seal)</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><strong>写入文件系统(emitAssets)</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul></li></ol><p><img src="`+o+'" alt="webpack"></p><ol><li><p>初始化阶段</p><ul><li><p>将 <code>process.args + webpack.config.js</code> 合并成用户配置</p></li><li><p>调用 <code>validateSchema</code> 校验配置</p></li><li><p>调用 <code>getNormalizedWebpackOptions + applyWebpackOptionsBaseDefaults</code> 合并出最终配置</p></li><li><p>创建 <code>compiler</code> 对象</p></li><li><p>遍历用户定义的 <code>plugins</code> 集合，执行插件的 <code>apply</code> 方法</p></li><li><p>调用 <code>new WebpackOptionsApply().process</code> 方法，加载各种内置插件</p><p>主要逻辑集中在 <code>WebpackOptionsApply</code> 类，webpack 内置了数百个插件，这些插件并不需要我们手动配置，<code>WebpackOptionsApply</code> 会在初始化阶段根据配置内容动态注入对应的插件，包括：</p><ul><li>注入 <code>EntryOptionPlugin</code> 插件，处理 <code>entry</code> 配置</li><li>根据 <code>devtool</code> 值判断后续用那个插件处理 <code>sourcemap</code>，可选值：<code>EvalSourceMapDevToolPlugin</code>、<code>SourceMapDevToolPlugin</code>、<code>EvalDevToolModulePlugin</code></li><li>注入 <code>RuntimePlugin</code> ，用于根据代码内容动态注入 webpack 运行时</li></ul></li><li><p>启动 webpack ，触发 <code>lib/webpack.js</code> 文件中 <code>createCompiler</code> 方法</p></li><li><p><code>createCompiler</code> 方法内部调用 <code>WebpackOptionsApply</code> 插件</p></li><li><p><code>WebpackOptionsApply</code> 定义在 <code>lib/WebpackOptionsApply.js</code> 文件，内部根据 <code>entry</code> 配置决定注入 <code>entry</code> 相关的插件，包括：<code>DllEntryPlugin</code>、<code>DynamicEntryPlugin</code>、<code>EntryPlugin</code>、<code>PrefetchPlugin</code>、<code>ProgressPlugin</code>、<code>ContainerPlugin</code></p></li><li><p><code>Entry</code> 相关插件，如 <code>lib/EntryPlugin.js</code> 的 <code>EntryPlugin</code> 监听 <code>compiler.make</code> 钩子</p></li><li><p><code>lib/compiler.js</code> 的 <code>compile</code> 函数内调用 <code>this.hooks.make.callAsync</code></p></li><li><p>触发 <code>EntryPlugin</code> 的 <code>make</code> 回调，在回调中执行 <code>compilation.addEntry</code> 函数</p></li><li><p><code>compilation.addEntry</code> 函数内部经过一坨与主流程无关的 hook 之后，再调用 <code>handleModuleCreate</code> 函数，正式开始构建内容</p></li></ul></li><li><p>构建阶段</p><ul><li>调用 <code>handleModuleCreate</code> ，根据文件类型构建 <code>module</code> 子类</li><li>调用 <code>loader-runner</code> 仓库的 <code>runLoaders</code> 转译 <code>module</code> 内容，通常是从各类资源类型转译为 JavaScript 文本</li><li>调用 <code>acorn</code> 将 JS 文本解析为 <code>AST</code></li><li>遍历 <code>AST</code>，触发各种钩子</li><li>在 <code>HarmonyExportDependencyParserPlugin</code> 插件监听 <code>exportImportSpecifier</code> 钩子，解读 JS 文本对应的资源依赖</li><li>调用 <code>module</code> 对象的 <code>addDependency</code> 将依赖对象加入到 <code>module</code> 依赖列表中</li><li>AST 遍历完毕后，调用 <code>module.handleParseResult</code> 处理模块依赖</li><li>对于 <code>module</code> 新增的依赖，调用 <code>handleModuleCreate</code> ，控制流回到第一步</li><li>所有依赖都解析完毕后，构建阶段结束</li></ul></li><li><p>生成阶段</p><ul><li><p>构建本次编译的 <code>ChunkGraph</code> 对象；</p></li><li><p>遍历 <code>compilation.modules</code> 集合，将 <code>module</code> 按 <code>entry/动态引入</code> 的规则分配给不同的 Chunk 对象；</p></li><li><p><code>compilation.modules</code> 集合遍历完毕后，得到完整的 <code>chunks</code> 集合对象，调用 <code>createXxxAssets</code> 方法</p></li><li><p><code>createXxxAssets</code> 遍历 <code>module/chunk</code> ，调用 <code>compilation.emitAssets</code> 方法将资 <code>assets</code> 信息记录到 <code>compilation.assets</code> 对象中</p></li><li><p>触发 <code>seal</code> 回调，控制流回到 <code>compiler</code> 对象</p><p>这一步的关键逻辑是将 <code>module</code> 按规则组织成 <code>chunks</code> ，webpack 内置的 <code>chunk</code> 封装规则比较简单：</p><ul><li><code>entry</code> 及 <code>entry</code> 触达到的模块，组合成一个 <code>chunk</code></li><li>使用动态引入语句引入的模块，各自组合成一个 <code>chunk</code></li><li><code>chunk</code> 是输出的基本单位，默认情况下这些 <code>chunks</code> 与最终输出的资源一一对应，而通过动态引入语句引入的模块，也对应会打包出相应的资源。</li></ul></li></ul></li></ol><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw" target="_blank" rel="noopener noreferrer">万字总结 一文吃透 Webpack 核心原理</a></li><li><a href="https://www.imooc.com/read/29" target="_blank" rel="noopener noreferrer">Webpack 从零入门到工程化实战</a></li></ul>',39)])])}const y=e(s,[["render",c]]),g=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Webpack/Webpack%E5%8E%9F%E7%90%86/Webpack%E5%8E%9F%E7%90%86.html","title":"Webpack 原理","lang":"zh-CN","frontmatter":{"description":"Webpack 原理 Webpack 本质上是一种事件流机制。通过事件流将各种插件串联起来，最终完成 Webpack 的全流程。实现事件流机制的核心是 Tapable 模块。Webpack 负责编译的 Compiler 和创建 Bundle 的 Compilation 都是继承自 Tapable 。 Tapable Tapable 和 Node.js ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Webpack 原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-28T08:18:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.LRH\\",\\"url\\":\\"https://lrh21g.github.io/blogs/\\"}]}"],["meta",{"property":"og:url","content":"https://lrh21g.github.io/blogs/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Webpack/Webpack%E5%8E%9F%E7%90%86/Webpack%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Mr.LRH 博客"}],["meta",{"property":"og:title","content":"Webpack 原理"}],["meta",{"property":"og:description","content":"Webpack 原理 Webpack 本质上是一种事件流机制。通过事件流将各种插件串联起来，最终完成 Webpack 的全流程。实现事件流机制的核心是 Tapable 模块。Webpack 负责编译的 Compiler 和创建 Bundle 的 Compilation 都是继承自 Tapable 。 Tapable Tapable 和 Node.js ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-28T08:18:46.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-28T08:18:46.000Z"}]]},"git":{"createdTime":1650124793000,"updatedTime":1740730726000,"contributors":[{"name":"lrh21g","username":"lrh21g","email":"837233792@qq.com","commits":1,"url":"https://github.com/lrh21g"},{"name":"lingronghai","username":"lingronghai","email":"lingronghai@foxmail.com","commits":1,"url":"https://github.com/lingronghai"},{"name":"lrh","username":"lrh","email":"lingronghai@foxmail.com","commits":1,"url":"https://github.com/lrh"}]},"readingTime":{"minutes":11.37,"words":3412},"filePathRelative":"前端框架/Webpack/Webpack原理/Webpack原理.md","excerpt":"\\n<p>Webpack 本质上是一种事件流机制。通过事件流将各种插件串联起来，最终完成 Webpack 的全流程。实现事件流机制的核心是 <code>Tapable</code> 模块。Webpack 负责编译的 <code>Compiler</code> 和创建 Bundle 的 <code>Compilation</code> 都是继承自 <code>Tapable</code> 。</p>\\n<h2>Tapable</h2>\\n<p><code>Tapable</code> 和 Node.js 中的 <code>EventEmitter</code> 类似，包括多种类型，通过事件的注册和监听，触发 Webpack 生命周期中的函数方法。</p>","autoDesc":true}');export{y as comp,g as data};
